/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Helpers/assetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/assetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssetsHelper = void 0;\nclass AssetsHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n    static async loadAudio(audioFile, audioContext) {\n        const response = await fetch(audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        return audioBuffer;\n    }\n}\nexports.AssetsHelper = AssetsHelper;\nAssetsHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/assetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/sceneBuilder.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/sceneBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneBuilder = void 0;\nconst scene_1 = __webpack_require__(/*! ../scene */ \"./build/src/Engine/scene.js\");\nclass SceneBuilder {\n    /**\n     * Creates a new SceneBuilder to help construct scenes with automatic timing.\n     * @param totalDuration - The total duration of the animation sequence in milliseconds.\n     */\n    constructor(totalDuration) {\n        this.scenes = [];\n        this.currentTime = 0;\n        this.totalDuration = totalDuration;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and duration.\n     * @param name - The name of the scene.\n     * @param duration - The duration of the scene in milliseconds.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    addScene(name, duration) {\n        const startTime = this.currentTime;\n        this.currentTime += duration;\n        // If the current time exceeds the total duration, adjust the last scene's duration\n        if (this.currentTime > this.totalDuration) {\n            const lastScene = this.scenes[this.scenes.length - 1];\n            if (lastScene) {\n                lastScene.durationInMs = this.totalDuration - lastScene.startTimeinMs;\n            }\n            duration = this.totalDuration - startTime; // Adjust the current scene's duration as well\n        }\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this; // For chaining\n    }\n    /**\n     * Gets the array of scenes with their timing configured.\n     * @returns The array of Scene objects.\n     */\n    getScenes() {\n        return this.scenes;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and a duration that extends to the end of the total duration.\n     * @param name - The name of the scene.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    durationUntilEndInMs(name) {\n        const startTime = this.currentTime;\n        const duration = this.totalDuration - startTime;\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this;\n    }\n}\nexports.SceneBuilder = SceneBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/sceneBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderer/shaderRenderer.js":
/*!***********************************************************!*\
  !*** ./build/src/Engine/ShaderRenderer/shaderRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\nclass ShaderRenderer {\n    /**\n     * Create a Shader\n     *\n     * @param {WebGLProgram} program\n     * @param {number} type\n     * @param {string} source\n     * @memberof DR\n     */\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) { // this.gl.COMPILE_STATUS\n            // gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l: string) =>\n            //         console.error(\"[shader] \" + l))\n            throw new Error(\"Error while compiling vertex/fragment\" + source);\n        }\n        ;\n    }\n    /**\n     * Create and a WebGLProgram\n     *\n     * @param {string} name\n     * @returns {WebGLProgram}\n     * @memberof DR\n     */\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n     *  Create a new WEBGLTexture\n     *\n     * @param {*} data  image or UInt8Array\n     * @returns WebGLTexture\n     * @memberof DR\n     */\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n     * Create a texture cube map\n     *\n     * @param {Array<any>} sources\n     * @param {number} d\n     * @returns {WebGLTexture}\n     * @memberof DR\n     */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n     * add assets ( textures )\n     *\n     * @param {*} assets\n     * @param {()=>void} cb\n     * @returns {this}\n     * @memberof DR\n     */\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n     * add a new buffer / shader program\n     *\n     * @param {string} name\n     * @param {string} vertex\n     * @param {string} fragment\n     * @param {Array<string>} [textures]\n     * @param {*} [customUniforms]\n     * @returns {this}\n     * @memberof DR\n     */\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n     * Set program state ( enable / or disable)\n     *\n     * @param {string} key\n     * @param {boolean} state\n     * @memberof DR\n     */\n    sP(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n     * Render\n     *\n     * @param {number} time\n     * @memberof DR\n     */\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n     * Create render target\n     *\n     * @param {number} width\n     * @param {number} height\n     * @param {Array<string>} textures\n     * @returns {*}\n     * @memberof DR\n     */\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Render loop\n     *\n     * @param {number} t\n     * @param {number} fps\n     * @returns {this}\n     * @memberof DR\n     */\n    run(t, fps) {\n        let pt = performance.now();\n        let interval = 1000 / fps;\n        let dt = 0;\n        const a = (t) => {\n            requestAnimationFrame(a);\n            dt = t - pt;\n            if (dt > interval) {\n                pt = t - (dt % interval);\n                this.update(pt / 1000);\n            }\n        };\n        a(t | 0);\n        return this;\n    }\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     *  Generate a texture and return a canvas element\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {*} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @returns {HTMLCanvasElement}\n     * @memberof DR\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new ShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.ShaderRenderer = ShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderer/shaderRenderer.js?");

/***/ }),

/***/ "./build/src/Engine/entity.js":
/*!************************************!*\
  !*** ./build/src/Engine/entity.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Entity = void 0;\nclass Entity {\n    /**\n     * Creates a new Entity.\n     * @param key - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity.\n     * @param action - The action function that defines the entity's behavior.\n     */\n    constructor(key, w, h, props, action, startTimeinMs, durationInMs) {\n        this.key = key;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Copies the entity's canvas to the target canvas and applies post-processors.\n     * @param targetCanvas - The target canvas to copy to.\n     * @param sequence - The Sequence instance.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n                this.postProcessors.forEach(processor => processor(targetCtx, sequence));\n            }\n        }\n    }\n    /**\n    * Updates the entity's state, clears the canvas, and calls the action function.\n    * @param timeStamp - The current timestamp in the animation.\n    */\n    update(timeStamp) {\n        var _a;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.ctx, this.props);\n            }\n        }\n    }\n}\nexports.Entity = Entity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/entity.js?");

/***/ }),

/***/ "./build/src/Engine/scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nclass Scene {\n    /**\n     * Creates a new Scene.\n     * @param name - The name or identifier for the scene.\n     * @param startTimeinMs - The start time of the scene in milliseconds.\n     * @param durationInMs - The duration of the scene in milliseconds.\n     */\n    constructor(name, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.entities = [];\n    }\n    /**\n     * Adds an entity to the scene.\n     * @param entity - The entity to add.\n     */\n    addEntity(entity) {\n        this.entities.push(entity);\n    }\n    /**\n     * Adds multiple entities to the scene.\n     * @param entities - An array of entities to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntities(...entities) {\n        entities.forEach(entity => this.addEntity(entity));\n        return this;\n    }\n    /**\n     * Gets an entity from the scene by its key.\n     * @param key - The key of the entity to retrieve.\n     * @returns The entity if found, otherwise undefined.\n     */\n    getEntity(key) {\n        return this.entities.find(entity => entity.key === key);\n    }\n    /**\n     * Plays the scene by animating its entities.\n     * @param elapsedTime - The elapsed time in the animation sequence.\n     * @returns A promise that resolves when the scene has finished playing.\n     */\n    play(elapsedTime) {\n        return new Promise((resolve) => {\n            const startTime = performance.now();\n            const animate = () => {\n                const currentTime = performance.now();\n                const sceneElapsedTime = currentTime - startTime + elapsedTime;\n                const adjustedSceneElapsedTime = sceneElapsedTime - this.startTimeinMs;\n                if (adjustedSceneElapsedTime >= 0) {\n                    this.entities.forEach((entity) => {\n                        entity.update(adjustedSceneElapsedTime);\n                    });\n                }\n                if (sceneElapsedTime < this.durationInMs + this.startTimeinMs) {\n                    // The requestAnimationFrame call was removed here. \n                    // The animation loop is now handled in the Sequence class.\n                }\n                else {\n                    resolve(true);\n                }\n            };\n            animate(); // Call animate once to start the initial rendering\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/scene.js?");

/***/ }),

/***/ "./build/src/Engine/sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ./Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nclass Sequence {\n    /**\n     * Adds a post-processing function to the sequence.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Gets the remaining time in the current scene.\n     * @param timeStamp - The current timestamp in the animation.\n     * @returns The remaining time in milliseconds.\n     */\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime);\n    }\n    /**\n     * Creates a new Sequence.\n     * @param target - The canvas element to render the animation on.\n     * @param bpm - The beats per minute for the animation.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param scenes - An array of scenes to include in the sequence.\n     * @param audioFile - An optional URL to an audio file to synchronize the animation with.\n     */\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, scenes, audioFile) {\n        this.target = target;\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.scenes = scenes || [];\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        if (audioFile) {\n            this.audioContext = new AudioContext();\n            this.analyser = this.audioContext.createAnalyser();\n            assetsHelper_1.AssetsHelper.loadAudio(audioFile, this.audioContext)\n                .then(audioBuffer => {\n                this.audioBuffer = audioBuffer;\n                this.onReady();\n            })\n                .catch(error => console.error(\"Error loading audio:\", error));\n        }\n        else {\n            this.onReady();\n        }\n        this.recalculateDuration();\n    }\n    /**\n     * Loads the audio file and initializes the audio context and analyser.\n     * @param audioFile - The URL of the audio file to load.\n     */\n    loadAudio(audioFile) {\n        fetch(audioFile)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n            this.onReady();\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n    }\n    /**\n     * Called when the audio file is loaded or when no audio is used.\n     */\n    onReady() { }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a beat occurs.\n     * @param listener - The function to call when a beat occurs.\n     */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    /**\n     * Adds a scene to the sequence.\n     * @param scene - The scene to add.\n     */\n    addScene(scene) {\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Adds multiple scenes to the sequence.\n     * @param scenes - The scenes to add.\n     * @returns The Sequence instance for chaining.\n     */\n    addScenes(...scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n    * Adds multiple scenes to the sequence.\n    * @param scenes - The scenes to add.\n    * @returns The Sequence instance for chaining.\n    */\n    addSceneArray(scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n     * Removes a scene from the sequence.\n     * @param scene - The scene to remove.\n     */\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Recalculates the total duration of the sequence.\n     */\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    /**\n     * Starts the animation sequence.\n     */\n    play() {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBeat = 0; // Initialize currentBeat to 0\n        this.startTime = performance.now();\n        if (this.audioBuffer) {\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        const animate = (ts) => {\n            const adjustedTimeStamp = ts - this.startTime;\n            this.playCurrentScene(adjustedTimeStamp);\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    /**\n     * Pauses\n   the animation sequence.\n     */\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Stops the animation sequence.\n     */\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Gets the current scene being played.\n     * @returns The current Scene or undefined if no scene is active.\n     */\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    /**\n  * Animates the current scene and handles scene transitions,\n  * audio analysis, and beat/tick events.\n  * @param timeStamp - The adjusted timestamp for the current frame.\n  */\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        this.currentTime = timeStamp; // Update currentTime\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs && timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no current scene is found, check for upcoming scenes\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, end animation\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n            this.currentScene.play(elapsedTime).then(() => {\n                // Scene transition completed\n            });\n        }\n        // FFT analysis (if analyser is available)\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n        }\n        // Clear the target canvas and update/draw entities\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.currentScene.entities.forEach(entity => {\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target, this);\n            }\n        });\n        // Apply post-processing effects\n        if (this.targetCtx) {\n            this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n        }\n        this.handleBeatAndTickEvents(timeStamp); // Handle beat and tick events\n    }\n    /**\n     * Handles beat and tick events based on the current timestamp.\n     * @param timeStamp - The adjusted timestamp for the current frame.\n     */\n    handleBeatAndTickEvents(timeStamp) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1;\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/sequence.js?");

/***/ }),

/***/ "./build/src/Engine/shaderEntity.js":
/*!******************************************!*\
  !*** ./build/src/Engine/shaderEntity.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEntity = void 0;\nconst shaderRenderer_1 = __webpack_require__(/*! ./ShaderRenderer/shaderRenderer */ \"./build/src/Engine/ShaderRenderer/shaderRenderer.js\");\nclass ShaderEntity {\n    /**\n     * Creates a new ShaderEntity.\n     * @param key - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including shader code and render buffers.\n     * @param action - An optional action function to be called before rendering the shaders.\n     */\n    constructor(key, w, h, props, action, startTimeinMs, durationInMs) {\n        this.key = key;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainShaderVertex) {\n            this.shaderRenderer = new shaderRenderer_1.ShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainShaderVertex, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            props.rendeBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else {\n            throw new Error(\"Cannot create ShaderEntity: Missing main shader code.\");\n        }\n    }\n    /**\n * Adds a post-processing function to the entity.\n * @param processor - The post-processing function to add.\n */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            this.action(timeStamp, this.shaderRenderer, this.props);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props);\n                this.shaderRenderer.update(timeStamp / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n}\nexports.ShaderEntity = ShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/shaderEntity.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/fractalOne.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/fractalOne.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fractalOne = void 0;\nexports.fractalOne = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime  time\r\n#define iResolution  resolution\r\n\r\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\r\n\r\nvoid mainImage(out vec4 O, vec2 C)\r\n{\r\n    O=vec4(0);\r\n    vec3 p;\r\n   vec3 r= vec3(iResolution.x,iResolution.y,0.);\r\n\t    \r\n    vec3 d =normalize(vec3((C-.5*r.xy)/r.y,1.)); \r\n for(float i=0.,g=0.,e,s;\r\n        ++i<99.;\r\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\r\n    )\r\n    {\r\n        p=g*d;\r\n        p.z+=iTime*.3;\r\n        p=R(p,normalize(vec3(1,2,3)),.5);   \r\n        s=2.5;\r\n        p=abs(mod(p-1.,2.)-1.)-1.;\r\n        for(int j=0;j++<10;)\r\n            p=1.-abs(p-1.),\r\n            s*=e=-1.8/dot(p,p),\r\n            p=p*e-.7;\r\n            g+=e=abs(p.z)/s+.001;           \r\n     }\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/fractalOne.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/fractalTwo.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/fractalTwo.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fractalTwo = void 0;\nexports.fractalTwo = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform sampler2D iChannel0;\r\n\r\nvec3 mcol=vec3(0.);\r\n\r\nfloat randSeed;\r\nvoid randomize(vec2 c){randSeed=fract(sin(dot(c,vec2(113.421,17.329)))*3134.1234);}\r\nfloat rand(){return fract(sin(randSeed++)*3143.45345);}\r\n\r\n\r\nfloat DE(vec3 p){\r\n\tconst vec3 CSize=vec3(.63248,.78632,.875);\r\n\tfloat DEfactor=1.;\r\n\tfor(int i=0;i<5;i++){\r\n\t\tp=2.*clamp(p,-CSize,CSize)-p;\r\n\t\tfloat k=max(.70968/dot(p,p),1.);\r\n\t\tp*=k;DEfactor*=k;\r\n\t}\r\n\tif(mcol.r>=0.)mcol+=abs(p);\r\n\tfloat rxy=length(p.xy);\r\n\treturn max(rxy-.92784,abs(rxy*p.z)/length(p))/DEfactor;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\treturn DE(p);\r\n}\r\n\r\nvec3 normal(in vec3 p){\r\n\t//    vec2 e = vec2(0.005, -0.005);\r\n\tvec2 e=vec2(1.,-1.)*.5773*.0005;\r\n\treturn normalize(e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx));\r\n}\r\n\r\nvec3 calcNormal(in vec3 pos){\r\n\treturn normal(pos);\r\n}\r\n\r\nmat2 rot(float a){\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\r\n}\r\n\r\n\r\n\r\nmat3 calcLookAtMatrix(in vec3 ro,in vec3 ta,in float roll)\r\n{\r\n\tvec3 ww=normalize(ta-ro);\r\n\tvec3 uu=normalize(cross(ww,vec3(sin(roll),cos(roll),0.)));\r\n\tvec3 vv=normalize(cross(uu,ww));\r\n\treturn mat3(uu,vv,ww);\r\n}\r\nvoid doCamera(out vec3 camPos,out vec3 camTar,in float time)\r\n{\r\n\tfloat an=.3*time+10.;\r\n\tcamPos=vec3(2.772*sin(an),.424,.820*cos(an));\r\n\tcamTar=vec3(1.,.000,-.03);\r\n}\r\nfloat calcIntersection(in vec3 ro,in vec3 rd)\r\n{\r\n\tconst float maxd=20.;\r\n\tconst float precis=.001;\r\n\tfloat h=precis*2.;\r\n\tfloat t=0.;\r\n\tfloat res=-1.;\r\n\tfor(int i=0;i<128;i++){\r\n\t\tif(h<precis||t>maxd)break;\r\n\t\th=map(ro+rd*t);\r\n\t\tt+=h;\r\n\t}\r\n\tif(t<maxd)res=t;\r\n\treturn res;\r\n}\r\n\r\nvec3 path(float t){\r\n\treturn vec3(cos(t),sin(t),-.65+abs(sin(t*.7))*.25)*(2.+sin(t*1.7)*.5)+vec3(0.,0.,1.);\r\n}\r\n\r\nvec3 post(vec3 rgb){\r\n\treturn rgb;\r\n}\r\n\r\nvec4 scene(vec3 ro,vec3 rd,float slider,float time,float pxl){\r\n\t\r\n\trandomize(gl_FragCoord.xy+time);\r\n\t\r\n\tvec3 LP=path(time+1.),p;\r\n\tLP.z+=slider;\r\n\tro.z-=slider;\r\n\t\r\n\tfloat d=map(ro)*.8,t=d*rand(),nt=d,od=1.,ft=0.;\r\n\t\r\n\tvec4 col=vec4(0.,0.,0.,1.);\r\n\t\r\n\tvec4 am,tm=vec4(-1.);\r\n\t\r\n\tfor(int i=0;i<99;i++){\r\n\t\t\r\n\t\tif(nt>t+ft){\r\n\t\t\tp=ro+rd*(t+ft);\r\n\t\t\tp+=(LP-p)*(-p.z)/(LP.z-p.z);\t\t\r\n\t\t}else{\r\n\t\t\tp=ro+rd*t;\r\n\t\t}\r\n\t\t\r\n\t\td=map(p);\r\n\t\t\r\n\t\tif(nt>t+ft){\r\n\t\t\tfloat dL=.05*length(ro+rd*(t+ft)-LP);\r\n\t\t\t\r\n\t\t\tcol.rgb+=col.a*vec3(1.,1.,.7)*exp(-dL*40.)*smoothstep(0.,.01,d);\r\n\t\t\t\r\n\t\t\tif(t+ft+dL>nt){\r\n\t\t\t\tft=0.;\r\n\t\t\t\tt=nt;\r\n\t\t\t\tif(t>20.)break;\r\n\t\t\t}else ft+=dL;\r\n\t\t}else{\r\n\t\t\tif(d<od&&tm.w<0.){\r\n\t\t\t\tfloat alpha=clamp(d/(pxl*t),0.,1.);\r\n\t\t\t\tif(alpha<.95){\r\n\t\t\t\t\tam=vec4(alpha,am.xyz);tm=vec4(t,tm.xyz);\r\n\t\t\t\t\tcol.a*=alpha;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tod=d;\r\n\t\t\tnt=t+d*(.6+.2*rand());\r\n\t\t}\r\n\t}\r\n\t\r\n\tvec3 tcol=vec3(0.);\r\n\t\r\n\tfor(int i=0;i<4;i++){\r\n\t\t\r\n\t\tif(tm.x<0.)continue;\r\n\r\n\t\tmcol=vec3(0.);\r\n\r\n\t\tp=ro+rd*tm.x;\r\n\t\t\r\n\t\tvec3 N=normal(p),L=LP-p;\r\n\t\t\r\n\t\tvec3 scol;\r\n\t\t\r\n\t\tmcol=sin(mcol)*.3+vec3(.8,.6,.4);\r\n\t\tfloat ls=exp(-dot(L,L)*.2);\r\n\t\tp+=L*(-p.z)/L.z;\r\n\t\t\r\n\t\tL=normalize(L);\r\n\t\t\r\n\t\tscol=ls*mcol*max(0.,dot(N,L));\r\n\t\t\r\n\t\tfloat v=max(0.,dot(N,-rd));\r\n\t\t\r\n\t\tscol+=exp(-t)*mcol*v;\r\n\t\td=smoothstep(0.,.005,map(p));\r\n\t\tscol+=ls*vec3(2.,2.,1.7)*max(0.,dot(N,L))*d;\r\n\t\t\r\n\t\tif(rd.z<0.&&d>0.)scol+=ls*vec3(4.,3.,1.4)*pow(max(0.,dot(reflect(rd,N),L)),5.)*(1.-.25*v)*d;\r\n\t\t\r\n\t\ttcol=mix(scol,tcol,am.x);\r\n\t\t\r\n\t\tam=am.yzwx;\r\n\t\ttm=tm.yzwx;\r\n\t}\r\n\t\r\n\tcol.rgb=clamp(col.rgb+tcol,0.,1.);\r\n\t\r\n\treturn vec4(post(col.rgb),t);\r\n\r\n}\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main(void){\r\n\t\r\n\tfloat tm;\r\n\tfloat glow,eglow,totdist=glow=.3;\r\n\tvec2 p=(gl_FragCoord.xy/resolution.xy)+mouse/4.;\r\n\t\r\n\tvec3 ro,ta;\r\n\tdoCamera(ro,ta,time*.1);\r\n\t\r\n\ttm=mod(time,18.85);\r\n\t\r\n\tmat3 camMat=calcLookAtMatrix(ro,ta,0.);\r\n\t\r\n\tvec3 rd=normalize(camMat*vec3(p.xy,1.5+2.));\r\n\t\r\n\tvec4 final=scene(ro,rd,.3,tm*.12,3./resolution.y);\r\n\t\r\n\tfragColor=final;\r\n\t\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/fractalTwo.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainFragment.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainFragment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainFragment = void 0;\nexports.mainFragment = `\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform float sI;\r\n\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform sampler2D iChannel4;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime time\r\n#define res resolution \r\n\r\n\r\n//-------------------------------------------------------------------------------------------\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{\r\n\r\n\tvec4 color = vec4(vec3(0.),1.);\r\n\tvec2 uv = gl_FragCoord.xy / res.xy;\r\n\r\n\tcolor = texture(iChannel0,uv);\r\n\t\r\n\tfragColor = color; //multi1*multi2*blend2;\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainFragment.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainVertex.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainVertex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainVertex = void 0;\nexports.mainVertex = `\r\nlayout(location = 0) in vec2 pos; \r\nout vec4 fragColor;\r\nvoid main(){\r\n    gl_Position = vec4(pos.xy,0.0,1.0);\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainVertex.js?");

/***/ }),

/***/ "./build/wwwroot/src/demo.js":
/*!***********************************!*\
  !*** ./build/wwwroot/src/demo.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sequence_1 = __webpack_require__(/*! ../../src/Engine/sequence */ \"./build/src/Engine/sequence.js\");\nconst entity_1 = __webpack_require__(/*! ../../src/Engine/entity */ \"./build/src/Engine/entity.js\");\nconst shaderEntity_1 = __webpack_require__(/*! ../../src/Engine/shaderEntity */ \"./build/src/Engine/shaderEntity.js\");\nconst mainFragment_1 = __webpack_require__(/*! ../assets/shaders/mainFragment */ \"./build/wwwroot/assets/shaders/mainFragment.js\");\nconst mainVertex_1 = __webpack_require__(/*! ../assets/shaders/mainVertex */ \"./build/wwwroot/assets/shaders/mainVertex.js\");\nconst fractalOne_1 = __webpack_require__(/*! ../assets/shaders/fractalOne */ \"./build/wwwroot/assets/shaders/fractalOne.js\");\nconst typeWriterEffet_1 = __webpack_require__(/*! ./effects/typeWriterEffet */ \"./build/wwwroot/src/effects/typeWriterEffet.js\");\nconst ranndomSquareByTickEffect_1 = __webpack_require__(/*! ./effects/ranndomSquareByTickEffect */ \"./build/wwwroot/src/effects/ranndomSquareByTickEffect.js\");\nconst expandingCircleEffect_1 = __webpack_require__(/*! ./effects/expandingCircleEffect */ \"./build/wwwroot/src/effects/expandingCircleEffect.js\");\nconst starBurstEffct_1 = __webpack_require__(/*! ./effects/starBurstEffct */ \"./build/wwwroot/src/effects/starBurstEffct.js\");\nconst textEffect_1 = __webpack_require__(/*! ./effects/textEffect */ \"./build/wwwroot/src/effects/textEffect.js\");\nconst imageOverlayEffect_1 = __webpack_require__(/*! ./effects/imageOverlayEffect */ \"./build/wwwroot/src/effects/imageOverlayEffect.js\");\nconst textArrayDisplayEffect_1 = __webpack_require__(/*! ./effects/textArrayDisplayEffect */ \"./build/wwwroot/src/effects/textArrayDisplayEffect.js\");\nconst assetsHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nconst fftAnalyzerEffect_1 = __webpack_require__(/*! ./effects/fftAnalyzerEffect */ \"./build/wwwroot/src/effects/fftAnalyzerEffect.js\");\nconst strobeEffect_1 = __webpack_require__(/*! ./effects/strobeEffect */ \"./build/wwwroot/src/effects/strobeEffect.js\");\nconst createBeatShakePostProcessor_1 = __webpack_require__(/*! ./postprocessors/createBeatShakePostProcessor */ \"./build/wwwroot/src/postprocessors/createBeatShakePostProcessor.js\");\nconst fractalTwo_1 = __webpack_require__(/*! ../assets/shaders/fractalTwo */ \"./build/wwwroot/assets/shaders/fractalTwo.js\");\nconst sceneBuilder_1 = __webpack_require__(/*! ../../src/Engine/Helpers/sceneBuilder */ \"./build/src/Engine/Helpers/sceneBuilder.js\");\nconst gridOverlayEffect_1 = __webpack_require__(/*! ./effects/gridOverlayEffect */ \"./build/wwwroot/src/effects/gridOverlayEffect.js\");\nconst bubbleParticles_1 = __webpack_require__(/*! ./effects/bubbleParticles */ \"./build/wwwroot/src/effects/bubbleParticles.js\");\nconst streachingTextEffect_1 = __webpack_require__(/*! ./effects/streachingTextEffect */ \"./build/wwwroot/src/effects/streachingTextEffect.js\");\nconst creditsScroller_1 = __webpack_require__(/*! ./effects/creditsScroller */ \"./build/wwwroot/src/effects/creditsScroller.js\");\nclass SetupDemo {\n    constructor() {\n        this.scenes = [];\n        this.MockedGraph = {\n            canvasWidth: 800,\n            canvasHeight: 450,\n            audioProperties: {\n                bpm: 110,\n                ticks: 8,\n                beat: 0,\n                tick: 0,\n                bar: 0,\n                avgFreq: 0\n            },\n            font: \"Big Shoulders Stencil Text\"\n        };\n        this.sequence = new sequence_1.Sequence(document.querySelector(\"canvas\"), 100, 4, 4, [], \"/wwwroot/assets/music/music.mp3\");\n    }\n    async addAsset(url) {\n        await assetsHelper_1.AssetsHelper.loadImage(url);\n        return this;\n    }\n    addScene(scene) {\n        this.sequence.addScene(scene);\n    }\n    addEntity(key, entity) {\n        const scene = this.scenes.find(pre => {\n            return pre.name === key;\n        });\n        if (scene) {\n            scene.addEntity(entity);\n        }\n        else\n            throw Error(\"No such scene\");\n    }\n}\nconst demo = new SetupDemo();\ndemo.addAsset(\"assets/images/silhouette.png\").then((instance) => {\n    // Create the Scenes\n    // Music length = 139200 ms;\n    var _a;\n    const sceneBuilder = new sceneBuilder_1.SceneBuilder(139200);\n    sceneBuilder.addScene(\"Scene 0\", 20000).\n        addScene(\"Scene 1\", 8000).\n        addScene(\"Scene 2\", 15000).\n        addScene(\"Scene 4\", 15000).\n        addScene(\"Scene 5\", 25000).\n        durationUntilEndInMs(\"Scene 6\");\n    const scenes = sceneBuilder.getScenes();\n    // Set up all effects;\n    const strobeEntity = new entity_1.Entity(\"Strobe\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        color: \"white\", // You can change the color\n        isOn: false,\n        lastBeat: -1, // Initialize to -1 to trigger on the first beat\n    }, (ts, ctx, props, sequence) => (0, strobeEffect_1.strobeEffect)(ts, ctx, props, instance.sequence));\n    const imageOverlayEntity = new entity_1.Entity(\"ImageOverlay\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 0,\n        y: 0,\n        width: instance.MockedGraph.canvasWidth,\n        height: instance.MockedGraph.canvasHeight,\n        image: (_a = assetsHelper_1.AssetsHelper.textureCache.get(\"silhouette.png\")) === null || _a === void 0 ? void 0 : _a.src,\n        opacity: 0.7,\n        fadeIn: true,\n        fadeOut: true,\n        duration: 5,\n    }, (ts, ctx, props) => (0, imageOverlayEffect_1.imageOverlayEffect)(ts, ctx, props));\n    const expandingCircleEntity = new entity_1.Entity(\"ExpandingCircle\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: instance.MockedGraph.canvasWidth / 2,\n        y: instance.MockedGraph.canvasHeight / 2,\n        radius: 0,\n        maxRadius: 450,\n        growthRate: 15,\n        duration: 5 // Scene duration in seconds\n    }, (ts, ctx, props) => (0, expandingCircleEffect_1.expandingCircleEffect)(ts, ctx, props, instance.sequence) // Pass the sequence instance\n    );\n    const starburstEntity = new entity_1.Entity(\"Starburst\", instance.MockedGraph.canvasWidth, // Canvas width\n    instance.MockedGraph.canvasWidth, // Canvas height\n    {\n        x: instance.MockedGraph.canvasWidth / 2, // Example x-coordinate\n        y: instance.MockedGraph.canvasHeight / 2, // Example y-coordinate\n        numPoints: 8, // Example number of points\n        outerRadius: 50,\n        innerRadius: 25,\n        rotation: 0,\n        rotationSpeed: 2, // Example rotation speed\n        hue: 0,\n        saturation: 100,\n        lightness: 50\n    }, starBurstEffct_1.starburstEffect);\n    const typeWriterEntity = new entity_1.Entity(\"Typewriter\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 100,\n        y: 300,\n        text: \"EASY AUDIO SYNCRONIZATON\",\n        index: 0,\n        speed: 5, // 5 characters per second\n        lastCharacterTime: 0,\n        useBPM: true,\n        bpm: instance.MockedGraph.audioProperties.bpm,\n        ticksPerBeat: instance.MockedGraph.audioProperties.ticks\n    }, typeWriterEffet_1.typeWriterEffect);\n    const randomSquareEntity = new entity_1.Entity(\"RandomSquare\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 0,\n        y: 0,\n        size: 0,\n        color: \"red\",\n        lastTick: -1 // Initialize to -1 to add a square on the first bar\n    }, (ts, ctx, props) => (0, ranndomSquareByTickEffect_1.randomSquareEffect)(ts, ctx, props, instance.sequence.tickCounter) // Pass currentBar from Sequence\n    );\n    const gridOverlayEntity = new entity_1.Entity(\"GridOverlay\", 800, // Canvas width\n    450, // Canvas height\n    {\n        rows: 5,\n        cols: 8,\n        cellColor: \"white\",\n        activeCells: new Set(),\n    }, (ts, ctx, props, sequence) => (0, gridOverlayEffect_1.gridOverlayEffect)(ts, ctx, props, instance.sequence));\n    const audioVisualizerEntity = new entity_1.Entity(\"AudioVisualizer\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 0,\n        y: 150,\n        width: instance.MockedGraph.canvasWidth,\n        height: 300,\n        barWidth: 5,\n        barSpacing: 2,\n        numBars: 100,\n        color: \"red\"\n    }, (ts, ctx, props, sequence) => (0, fftAnalyzerEffect_1.audioVisualizerEffect)(ts, ctx, props, instance.sequence));\n    const fractalShaderEntityTwo = new shaderEntity_1.ShaderEntity(\"ShaderEnriry\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        mainFragmentShader: mainFragment_1.mainFragment,\n        mainShaderVertex: mainVertex_1.mainVertex,\n        rendeBuffers: [\n            {\n                name: \"MyShader\",\n                fragment: fractalTwo_1.fractalTwo,\n                vertex: mainVertex_1.mainVertex,\n                textures: []\n            }\n        ]\n    }, (ts, render, propertybag) => {\n    });\n    const fractalShaderEntityOne = new shaderEntity_1.ShaderEntity(\"ShaderEnriry\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        mainFragmentShader: mainFragment_1.mainFragment,\n        mainShaderVertex: mainVertex_1.mainVertex,\n        rendeBuffers: [\n            {\n                name: \"MyShader\",\n                fragment: fractalOne_1.fractalOne,\n                vertex: mainVertex_1.mainVertex,\n                textures: []\n            }\n        ]\n    }, (ts, render, propertybag) => {\n    });\n    const textOverlay = new entity_1.Entity(\"TextEffect\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 100,\n        y: 100,\n        text: \"FULL SHADER SUPPORT\".toUpperCase(),\n        font: \"Big Shoulders Stencil Text\",\n        size: 60,\n        duration: 15 // 5 seconds\n    }, (ts, ctx, props) => (0, textEffect_1.textEffect)(ts, ctx, props, instance.sequence) // Pass the sequence instance\n    );\n    const textArrayDisplayEntity = new entity_1.Entity(\"TextArrayDisplay\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasWidth, {\n        x: 100,\n        y: 200,\n        texts: [\n            \"1-N RENDERPASS\".toUpperCase(),\n            \"POSTPROCESSING\".toUpperCase(),\n            \"1-N TEXTURES\",\n            \"CUSTOM UNIFORMS\",\n        ],\n        font: instance.MockedGraph.font,\n        size: 60,\n        currentBeat: 0,\n    }, (ts, ctx, props) => {\n        (0, textArrayDisplayEffect_1.textArrayDisplayEffect)(ts, ctx, props, instance.sequence);\n    });\n    textArrayDisplayEntity.addPostProcessor((0, createBeatShakePostProcessor_1.createBeatShakePostProcessor)(3));\n    // Add Entities to the Scens\n    // setup a some more test Entities for Scene 0\n    const typeWriter1EntityForFirstScene = new entity_1.Entity(\"Typewriter\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 100,\n        y: 200,\n        text: \"DEMOLISHED-RAILS\",\n        index: 0,\n        speed: 5, // 5 characters per second\n        lastCharacterTime: 0,\n        useBPM: true,\n        bpm: instance.MockedGraph.audioProperties.bpm,\n        ticksPerBeat: instance.MockedGraph.audioProperties.ticks\n    }, typeWriterEffet_1.typeWriterEffect, 1000, 10000);\n    const typeWriter2EntityForFirstScene = new entity_1.Entity(\"Typewriter\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 0,\n        y: 350,\n        text: \"FRAMEWORK DEMO\",\n        index: 0,\n        speed: 5, // 5 characters per second\n        lastCharacterTime: 0,\n        useBPM: true,\n        bpm: instance.MockedGraph.audioProperties.bpm,\n        ticksPerBeat: instance.MockedGraph.audioProperties.ticks\n    }, typeWriterEffet_1.typeWriterEffect, 5000, 10000);\n    const gridOverlayEffectEntity = new entity_1.Entity(\"gridOverlayEffets\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        activeCells: new Set(),\n        cellColor: \"rgba(255,255,0,0.2)\",\n        cols: 4,\n        rows: 4,\n    }, (ts, ctx, props) => (0, gridOverlayEffect_1.gridOverlayEffect)(ts, ctx, props, instance.sequence));\n    const ballEntityProps = {\n        numBalls: 20,\n        balls: [],\n    };\n    const ballEntity = new entity_1.Entity(\"BallEntity\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, ballEntityProps, (ts, ctx, props, sequence) => (0, bubbleParticles_1.ballEffect)(ts, ctx, props, sequence));\n    const stretchingTextProps = {\n        texts: [\"BRING\", \"THE\", \"BEAT\", \"BACK\"],\n        currentIndex: 0,\n        font: \"Poppins\", // Or your custom font\n        color: \"rgba(255,255,255,0.2)\",\n        lastBeat: -1,\n    };\n    const stretchingTextEntity = new entity_1.Entity(\"StretchingText\", 800, // Canvas width\n    450, // Canvas height\n    stretchingTextProps, (ts, ctx, props, sequence) => (0, streachingTextEffect_1.stretchingTextEffect)(ts, ctx, props, instance.sequence));\n    // set up an endScene ( credits )\n    const creditsText = [\n        \"FRAMWORK CODE\",\n        \"MAGNUS 'BAGZY'THOR\",\n        \"EXAMPLE FX'S\",\n        \"MAGNUS 'BAGZY'THOR\",\n        \"MUSIC BY\",\n        \"VIRGILL / MANIACS OF NOISE\",\n        \"GRAPHIS\",\n        \"COOKIEDOUGH\",\n        // ... more lines\n    ];\n    const creditsScrollerProps = {\n        lines: creditsText.map((text, index) => ({\n            text,\n            y: 100 + index * 30, // Initial y position\n            alpha: 0,\n        })),\n        lineHeight: 80,\n        scrollSpeed: 40,\n        fadeInDuration: 0.5,\n        fadeOutDuration: 0.5,\n        font: \"40px Poppins\",\n    };\n    const creditsEntity = new entity_1.Entity(\"CreditsScroller\", instance.MockedGraph.canvasWidth, // Canvas width\n    instance.MockedGraph.canvasHeight, // Canvas height\n    creditsScrollerProps, (ts, ctx, props, sequence) => (0, creditsScroller_1.creditsScrollerEffect)(ts, ctx, props, instance.sequence));\n    creditsEntity.addPostProcessor((0, createBeatShakePostProcessor_1.createBeatShakePostProcessor)(3));\n    // Okey, done setup , add the stuff to scens \n    scenes[0].addEntities(typeWriter1EntityForFirstScene, typeWriter2EntityForFirstScene, gridOverlayEffectEntity, ballEntity, stretchingTextEntity);\n    scenes[1].addEntities(expandingCircleEntity, starburstEntity, imageOverlayEntity);\n    scenes[2].addEntities(audioVisualizerEntity, randomSquareEntity, imageOverlayEntity, imageOverlayEntity, typeWriterEntity);\n    scenes[3].addEntities(strobeEntity, fractalShaderEntityTwo, imageOverlayEntity);\n    scenes[4].addEntities(fractalShaderEntityOne, imageOverlayEntity, textOverlay, textArrayDisplayEntity);\n    scenes[5].addEntities(creditsEntity, imageOverlayEntity, ballEntity);\n    instance.sequence.addSceneArray(scenes);\n    // instance.sequence.addPostProcessor(createCRTJitterPostProcessor(0.1, 5, 30))\n    // add a postprocessor to the RenderResult; \n    //instance.sequence.addPostProcessor(createBeatShakePostProcessor(3));\n});\ndemo.sequence.onReady = () => {\n    const btn = document.querySelector(\"BUTTON\");\n    btn.textContent = \"CLICK TO START!\";\n    btn.addEventListener(\"click\", () => {\n        var _a;\n        (_a = document.querySelector(\"#launch\")) === null || _a === void 0 ? void 0 : _a.remove();\n        demo.sequence.play();\n    });\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/demo.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/bubbleParticles.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/src/effects/bubbleParticles.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ballEffect = void 0;\nconst ballEffect = (ts, ctx, propertybag, sequence) => {\n    const { numBalls, balls } = propertybag;\n    /**\n   * Creates a new ball with random properties.\n   * @param ctx - The 2D rendering context of the canvas.\n   * @param balls - The array to add the new ball to.\n   */\n    function createBall(ctx, balls) {\n        const colors = [\n            \"85, 221, 224\",\n            \"51, 101, 138\",\n            \"47, 72, 88\",\n            \"246, 174, 45\",\n            \"242, 100, 25\"\n        ];\n        const randomColor = colors[Math.floor(Math.random() * colors.length)];\n        const ballProps = {\n            x: ctx.canvas.width / 2,\n            y: ctx.canvas.height / 2,\n            radius: Math.floor(Math.random() * 12) + 4,\n            color: `rgba(${randomColor}, ${Math.random()})`,\n            vx: Math.random() * 8 - 4,\n            vy: Math.random() * 8 - 4,\n        };\n        balls.push(ballProps);\n    }\n    // Create balls if there are not enough\n    while (balls.length < numBalls) {\n        createBall(ctx, balls);\n    }\n    // Update and draw each ball\n    balls.forEach(ball => {\n        ctx.fillStyle = ball.color;\n        // Update position based on velocity\n        ball.x += ball.vx;\n        ball.y += ball.vy;\n        // Reset position if ball goes off-screen\n        if (ball.x + ball.radius > ctx.canvas.width || ball.x - ball.radius < 0) {\n            ball.x = Math.max(ball.radius, Math.min(ball.x, ctx.canvas.width - ball.radius));\n            ball.vx = -ball.vx;\n        }\n        if (ball.y + ball.radius > ctx.canvas.height || ball.y - ball.radius < 0) {\n            ball.y = Math.max(ball.radius, Math.min(ball.y, ctx.canvas.height - ball.radius));\n            ball.vy = -ball.vy;\n        }\n        // Draw the ball\n        ctx.beginPath();\n        ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);\n        ctx.fill();\n    });\n};\nexports.ballEffect = ballEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/bubbleParticles.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/creditsScroller.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/src/effects/creditsScroller.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.creditsScrollerEffect = void 0;\nconst creditsScrollerEffect = (ts, ctx, propertybag, sequence) => {\n    const { lines, lineHeight, scrollSpeed, fadeInDuration, fadeOutDuration } = propertybag;\n    const { width, height } = ctx.canvas;\n    ctx.font = propertybag.font; // Set your desired font\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = \"white\";\n    // Calculate the total duration of the animation\n    const totalDuration = sequence.durationMs / 1000;\n    // Update and draw each line\n    lines.forEach((line, index) => {\n        const sceneStartTime = sequence.currentScene.startTimeinMs / 1000; // Get the scene's start time in seconds\n        const elapsed = ts / 1000 - sceneStartTime - (index * lineHeight) / scrollSpeed;\n        // Fade in and fade out logic\n        if (elapsed < fadeInDuration) {\n            line.alpha = Math.min(1, elapsed / fadeInDuration);\n        }\n        else if (elapsed > totalDuration - fadeOutDuration) {\n            line.alpha = Math.max(0, (totalDuration - elapsed) / fadeOutDuration);\n        }\n        else {\n            line.alpha = 1;\n        }\n        // Update the y position to scroll upwards\n        line.y = height - elapsed * scrollSpeed;\n        // Draw the text\n        ctx.globalAlpha = line.alpha;\n        ctx.fillText(line.text, width / 2, line.y);\n    });\n};\nexports.creditsScrollerEffect = creditsScrollerEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/creditsScroller.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/expandingCircleEffect.js":
/*!************************************************************!*\
  !*** ./build/wwwroot/src/effects/expandingCircleEffect.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expandingCircleEffect = void 0;\nconst expandingCircleEffect = (ts, ctx, propertybag, sequence) => {\n    ctx.fillStyle = \"white\";\n    // Calculate the current radius based on remaining time\n    const remainingTime = sequence.getSceneRemainingTime(ts);\n    const progress = Math.max(0, 1 - remainingTime / (propertybag.duration * 1000)); // Ensure progress is not negative\n    propertybag.radius = propertybag.maxRadius * progress;\n    // Draw the circle\n    ctx.beginPath();\n    ctx.arc(propertybag.x, propertybag.y, propertybag.radius, 0, 2 * Math.PI);\n    ctx.fill();\n};\nexports.expandingCircleEffect = expandingCircleEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/expandingCircleEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/fftAnalyzerEffect.js":
/*!********************************************************!*\
  !*** ./build/wwwroot/src/effects/fftAnalyzerEffect.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.audioVisualizerEffect = void 0;\nconst audioVisualizerEffect = (ts, ctx, propertybag, sequence) => {\n    const { x, y, width, height, barWidth, barSpacing, numBars, color } = propertybag;\n    const frequencyData = sequence.fftData; // Access FFT data from the sequence\n    if (!frequencyData) {\n        return; // No data available\n    }\n    const barCount = Math.min(numBars, frequencyData.length);\n    const barMaxHeight = height;\n    ctx.fillStyle = color;\n    for (let i = 0; i < barCount; i++) {\n        const barHeight = (frequencyData[i] / 255) * barMaxHeight; // Scale bar height\n        const barX = x + i * (barWidth + barSpacing);\n        const barY = y + height - barHeight;\n        ctx.fillRect(barX, barY, barWidth, barHeight);\n    }\n};\nexports.audioVisualizerEffect = audioVisualizerEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/fftAnalyzerEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/gridOverlayEffect.js":
/*!********************************************************!*\
  !*** ./build/wwwroot/src/effects/gridOverlayEffect.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.gridOverlayEffect = void 0;\nconst gridOverlayEffect = (ts, ctx, propertybag, sequence) => {\n    const { rows, cols, cellColor, activeCells } = propertybag;\n    const cellWidth = ctx.canvas.width / cols;\n    const cellHeight = ctx.canvas.height / rows;\n    // Toggle cell activity based on beat\n    if (sequence.currentBeat > activeCells.size) {\n        let randomCellIndex;\n        do {\n            randomCellIndex = Math.floor(Math.random() * (rows * cols));\n        } while (activeCells.has(randomCellIndex));\n        activeCells.add(randomCellIndex);\n    }\n    ctx.fillStyle = cellColor;\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            const cellIndex = row * cols + col;\n            if (activeCells.has(cellIndex)) {\n                const x = col * cellWidth;\n                const y = row * cellHeight;\n                ctx.fillRect(x, y, cellWidth, cellHeight);\n            }\n        }\n    }\n};\nexports.gridOverlayEffect = gridOverlayEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/gridOverlayEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/imageOverlayEffect.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/src/effects/imageOverlayEffect.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageOverlayEffect = void 0;\nconst imageOverlayEffect = (ts, ctx, propertybag) => {\n    const { x, y, width, height, image, opacity, fadeIn, fadeOut, duration } = propertybag;\n    ctx.drawImage(image, x, y, width, height);\n    ctx.globalAlpha = 1;\n};\nexports.imageOverlayEffect = imageOverlayEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/imageOverlayEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/ranndomSquareByTickEffect.js":
/*!****************************************************************!*\
  !*** ./build/wwwroot/src/effects/ranndomSquareByTickEffect.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomSquareEffect = void 0;\nconst randomSquareEffect = (ts, ctx, propertybag, tick) => {\n    if (tick !== propertybag.lastTick) {\n        propertybag.lastTick = tick;\n        ctx.globalAlpha = 0.5;\n        // Generate random properties for the square\n        propertybag.x = Math.random() * ctx.canvas.width;\n        propertybag.y = Math.random() * ctx.canvas.height;\n        propertybag.size = 20 + Math.random() * 50; // Random size between 20 and 70\n        propertybag.color = `hsl(${Math.random() * 360}, 100%, 50%)`; // Random color\n    }\n    // Draw the square\n    ctx.fillStyle = propertybag.color;\n    ctx.fillRect(propertybag.x, propertybag.y, propertybag.size, propertybag.size);\n};\nexports.randomSquareEffect = randomSquareEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/ranndomSquareByTickEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/starBurstEffct.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/src/effects/starBurstEffct.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.starburstEffect = void 0;\nconst starburstEffect = (ts, ctx, propertybag) => {\n    const { x, y, numPoints, outerRadius, innerRadius, rotation, rotationSpeed, hue, saturation, lightness } = propertybag;\n    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n    ctx.beginPath();\n    for (let i = 0; i < numPoints * 2; i++) {\n        const radius = i % 2 === 0 ? outerRadius : innerRadius;\n        const angle = (Math.PI * i) / numPoints + rotation;\n        const px = x + radius * Math.cos(angle);\n        const py = y + radius * Math.sin(angle);\n        if (i === 0) {\n            ctx.moveTo(px, py);\n        }\n        else {\n            ctx.lineTo(px, py);\n        }\n    }\n    ctx.closePath();\n    ctx.fill();\n    propertybag.rotation += rotationSpeed * (Math.PI / 180); // Update rotation\n};\nexports.starburstEffect = starburstEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/starBurstEffct.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/streachingTextEffect.js":
/*!***********************************************************!*\
  !*** ./build/wwwroot/src/effects/streachingTextEffect.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stretchingTextEffect = void 0;\nconst stretchingTextEffect = (ts, ctx, propertybag, sequence) => {\n    const { texts, currentIndex, font, color, lastBeat } = propertybag;\n    if (sequence.currentBeat !== lastBeat) {\n        propertybag.currentIndex = (propertybag.currentIndex + 1) % texts.length; // Cycle through texts\n        propertybag.lastBeat = sequence.currentBeat;\n    }\n    const text = texts[currentIndex];\n    // Calculate the text size to fit the canvas\n    let fontSize = 10;\n    ctx.font = `${fontSize}px ${font}`;\n    let textMetrics = ctx.measureText(text);\n    let textWidth = textMetrics.width;\n    let textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;\n    // Adjust font size to fit the canvas\n    const scaleX = ctx.canvas.width / textWidth;\n    const scaleY = ctx.canvas.height / textHeight;\n    const scale = Math.min(scaleX, scaleY);\n    fontSize *= scale;\n    ctx.font = `${fontSize}px ${font}`;\n    // Recalculate text metrics with the new font size\n    textMetrics = ctx.measureText(text);\n    textWidth = textMetrics.width;\n    textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;\n    // Calculate the x and y coordinates to center the text\n    const x = (ctx.canvas.width - textWidth) / 2;\n    const y = (ctx.canvas.height + textHeight) / 2;\n    ctx.fillStyle = color;\n    ctx.fillText(text, x, y);\n};\nexports.stretchingTextEffect = stretchingTextEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/streachingTextEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/strobeEffect.js":
/*!***************************************************!*\
  !*** ./build/wwwroot/src/effects/strobeEffect.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.strobeEffect = void 0;\nconst strobeEffect = (ts, ctx, propertybag, sequence) => {\n    const { color, isOn, lastBeat } = propertybag;\n    if (sequence.currentBeat !== lastBeat) {\n        propertybag.isOn = !isOn; // Toggle the strobe on/off on each beat\n        propertybag.lastBeat = sequence.currentBeat;\n    }\n    if (isOn) {\n        ctx.fillStyle = color;\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Fill the canvas\n    }\n};\nexports.strobeEffect = strobeEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/strobeEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/textArrayDisplayEffect.js":
/*!*************************************************************!*\
  !*** ./build/wwwroot/src/effects/textArrayDisplayEffect.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textArrayDisplayEffect = void 0;\nconst textArrayDisplayEffect = (ts, ctx, propertybag, sequence // Pass the Sequence instance\n) => {\n    const { x, y, texts, font, size } = propertybag;\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    // Se till att currentBeat är inom gränserna för texts-arrayen\n    const index = Math.min(sequence.currentBeat - 1, texts.length - 1);\n    // Visa texten vid aktuellt index\n    if (index >= 0) {\n        ctx.fillText(texts[index], x, y);\n    }\n};\nexports.textArrayDisplayEffect = textArrayDisplayEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/textArrayDisplayEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/textEffect.js":
/*!*************************************************!*\
  !*** ./build/wwwroot/src/effects/textEffect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textEffect = void 0;\nconst textEffect = (ts, ctx, propertybag, sequence // Pass the Sequence instance\n) => {\n    const { x, y, text, font, size, duration } = propertybag;\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    const sceneRemainingTime = sequence.getSceneRemainingTime(ts);\n    const elapsed = duration - sceneRemainingTime / 1000; // Time elapsed in seconds\n    let alpha = 1;\n    if (elapsed < 1) {\n        alpha = elapsed; // Fade in over 1 second\n    }\n    if (sceneRemainingTime / 1000 < 1) {\n        alpha = sceneRemainingTime / 1000; // Fade out over 1 second\n    }\n    ctx.globalAlpha = alpha;\n    ctx.fillText(text, x, y);\n    ctx.globalAlpha = 1;\n};\nexports.textEffect = textEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/textEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/typeWriterEffet.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/src/effects/typeWriterEffet.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.typeWriterEffect = void 0;\nconst typeWriterEffect = (ts, ctx, propertybag) => {\n    ctx.font = \"68px Big Shoulders Stencil Text\";\n    ctx.fillStyle = \"white\";\n    let elapsedTime = 0;\n    if (propertybag.useBPM) {\n        // Calculate characters per beat\n        const charactersPerBeat = propertybag.speed / (propertybag.bpm / 60);\n        // Elapsed time in beats\n        elapsedTime = (ts - propertybag.lastCharacterTime) / (60000 / propertybag.bpm);\n    }\n    else {\n        // Calculate characters per tick\n        const charactersPerTick = propertybag.speed / ((propertybag.bpm * 4) / 60);\n        // Elapsed time in ticks\n        elapsedTime = (ts - propertybag.lastCharacterTime) / (60000 / (propertybag.bpm * propertybag.ticksPerBeat));\n    }\n    if (elapsedTime >= 1 / propertybag.speed) {\n        propertybag.index++;\n        propertybag.lastCharacterTime = ts;\n    }\n    // Draw the substring\n    const displayText = propertybag.text.substring(0, propertybag.index);\n    // Measure the full text width\n    const fullTextMetrics = ctx.measureText(propertybag.text);\n    const fullTextWidth = fullTextMetrics.width;\n    // Calculate the centered x-coordinate\n    const centeredX = (ctx.canvas.width - fullTextWidth) / 2;\n    ctx.fillText(displayText, centeredX, propertybag.y / 2);\n};\nexports.typeWriterEffect = typeWriterEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/typeWriterEffet.js?");

/***/ }),

/***/ "./build/wwwroot/src/postprocessors/createBeatShakePostProcessor.js":
/*!**************************************************************************!*\
  !*** ./build/wwwroot/src/postprocessors/createBeatShakePostProcessor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createBeatShakePostProcessor = void 0;\nconst createBeatShakePostProcessor = (intensity = 10) => {\n    return (ctx, sequence) => {\n        const offsetX = (Math.random() - 0.5) * intensity * sequence.currentBeat;\n        const offsetY = (Math.random() - 0.5) * intensity * sequence.currentBeat;\n        ctx.drawImage(ctx.canvas, offsetX, offsetY);\n    };\n};\nexports.createBeatShakePostProcessor = createBeatShakePostProcessor;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/postprocessors/createBeatShakePostProcessor.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/demo.js");
/******/ 	
/******/ })()
;