/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Entity.js":
/*!************************************!*\
  !*** ./build/src/Engine/Entity.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Entity = void 0;\nclass Entity {\n    constructor(key, w, h, props, action) {\n        this.key = key;\n        this.props = props;\n        this.action = action;\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    copyToCanvas(targetCanvas) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            targetCtx.drawImage(this.canvas, 0, 0);\n        }\n    }\n    update(timeStamp) {\n        var _a;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props)\n            this.action(timeStamp, this.ctx, this.props);\n    }\n}\nexports.Entity = Entity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/AssetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/AssetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureCacheHelper = void 0;\nclass TextureCacheHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n}\nexports.TextureCacheHelper = TextureCacheHelper;\nTextureCacheHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/AssetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/Scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nclass Scene {\n    constructor(name, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.entities = [];\n    }\n    addEntity(entity) {\n        this.entities.push(entity);\n    }\n    getEntity(key) {\n        return this.entities.find(pre => pre.key === key);\n    }\n    play(elapsedTime) {\n        return new Promise((resolve) => {\n            const startTime = performance.now();\n            const animate = () => {\n                const currentTime = performance.now();\n                const sceneElapsedTime = currentTime - startTime + elapsedTime;\n                const adjustedSceneElapsedTime = sceneElapsedTime - this.startTimeinMs;\n                if (adjustedSceneElapsedTime >= 0) {\n                    this.entities.forEach((entity) => {\n                        const remainingTime = this.durationInMs - adjustedSceneElapsedTime; // Calculate remaining time\n                        entity.update(adjustedSceneElapsedTime);\n                    });\n                }\n                if (sceneElapsedTime < this.durationInMs + this.startTimeinMs) {\n                    //  requestAnimationFrame(animate); // Keep this animation loop\n                }\n                else {\n                    resolve(true);\n                }\n            };\n            animate();\n            // requestAnimationFrame(animate);\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Scene.js?");

/***/ }),

/***/ "./build/src/Engine/Sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/Sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nconst SequencerBase_1 = __webpack_require__(/*! ./SequencerBase */ \"./build/src/Engine/SequencerBase.js\");\nclass Sequence extends SequencerBase_1.SequencerBase {\n    onReady() {\n        throw \"not implemeted\";\n    }\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime); // Ensure remainingTime is not negative\n    }\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, scenes, audioFile) {\n        super(scenes);\n        this.target = target;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        if (audioFile) {\n            this.loadAudio(audioFile);\n        }\n        else {\n            this.onReady();\n        }\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    loadAudio(audioFile) {\n        this.audioContext = new AudioContext();\n        this.analyser = this.audioContext.createAnalyser(); // Create analyser node\n        fetch(audioFile)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n            this.onReady();\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n    }\n    // Add event listener for bars\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    addScene(scene) {\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    play() {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        // Start audio playback\n        if (this.audioBuffer) {\n            // Create a NEW AudioBufferSourceNode each time\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        const animate = (ts) => {\n            // Call playCurrentScene even if there is no current scene\n            this.playCurrentScene(ts);\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs &&\n            timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no scene is found for the current time, check if there's an upcoming scene\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, animation finished\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            let elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n            this.currentScene.play(elapsedTime).then(() => {\n                // You might want to add an event here for when a scene ends\n            });\n        }\n        // FFT analysis\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n            const avgFrequency = this.fftData.reduce((sum, val) => sum + val, 0) / this.fftData.length;\n            // console.log(\"Average frequency:\", avgFrequency);\n        }\n        // Call update() on all entities in the new scene\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.currentScene.entities.forEach(entity => {\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target);\n            }\n        });\n        // BPM and event handling\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            // Bar event handling\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1; // Reset to 1 after a bar is complete\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Sequence.js?");

/***/ }),

/***/ "./build/src/Engine/SequencerBase.js":
/*!*******************************************!*\
  !*** ./build/src/Engine/SequencerBase.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SequencerBase = void 0;\nclass SequencerBase {\n    constructor(scenes) {\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.scenes = scenes || [];\n    }\n}\nexports.SequencerBase = SequencerBase;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/SequencerBase.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderEntity.js":
/*!******************************************!*\
  !*** ./build/src/Engine/ShaderEntity.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEntity = void 0;\nconst ShaderRenderer_1 = __webpack_require__(/*! ./ShaderRenderer/ShaderRenderer */ \"./build/src/Engine/ShaderRenderer/ShaderRenderer.js\");\nclass ShaderEntity {\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props)\n            this.action(timeStamp, this.shaderRenderer, this.props);\n        this.shaderRenderer.update(timeStamp / 1000);\n    }\n    copyToCanvas(targetCanvas) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            targetCtx.drawImage(this.canvas, 0, 0);\n        }\n    }\n    constructor(key, w, h, props, action) {\n        this.key = key;\n        this.props = props;\n        this.action = action;\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainShaderVertex) {\n            this.shaderRenderer = new ShaderRenderer_1.ShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainShaderVertex, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            props.rendeBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else\n            throw \"Cannot create shaderRender\";\n    }\n}\nexports.ShaderEntity = ShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderEntity.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderer/ShaderRenderer.js":
/*!***********************************************************!*\
  !*** ./build/src/Engine/ShaderRenderer/ShaderRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\nclass ShaderRenderer {\n    /**\n     * Create a Shader\n     *\n     * @param {WebGLProgram} program\n     * @param {number} type\n     * @param {string} source\n     * @memberof DR\n     */\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) { // this.gl.COMPILE_STATUS\n            // gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l: string) =>\n            //         console.error(\"[shader] \" + l))\n            throw new Error(\"Error while compiling vertex/fragment\" + source);\n        }\n        ;\n    }\n    /**\n     * Create and a WebGLProgram\n     *\n     * @param {string} name\n     * @returns {WebGLProgram}\n     * @memberof DR\n     */\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n     *  Create a new WEBGLTexture\n     *\n     * @param {*} data  image or UInt8Array\n     * @returns WebGLTexture\n     * @memberof DR\n     */\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n     * Create a texture cube map\n     *\n     * @param {Array<any>} sources\n     * @param {number} d\n     * @returns {WebGLTexture}\n     * @memberof DR\n     */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n     * add assets ( textures )\n     *\n     * @param {*} assets\n     * @param {()=>void} cb\n     * @returns {this}\n     * @memberof DR\n     */\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n     * add a new buffer / shader program\n     *\n     * @param {string} name\n     * @param {string} vertex\n     * @param {string} fragment\n     * @param {Array<string>} [textures]\n     * @param {*} [customUniforms]\n     * @returns {this}\n     * @memberof DR\n     */\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n     * Set program state ( enable / or disable)\n     *\n     * @param {string} key\n     * @param {boolean} state\n     * @memberof DR\n     */\n    sP(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n     * Render\n     *\n     * @param {number} time\n     * @memberof DR\n     */\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n     * Create render target\n     *\n     * @param {number} width\n     * @param {number} height\n     * @param {Array<string>} textures\n     * @returns {*}\n     * @memberof DR\n     */\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Render loop\n     *\n     * @param {number} t\n     * @param {number} fps\n     * @returns {this}\n     * @memberof DR\n     */\n    run(t, fps) {\n        let pt = performance.now();\n        let interval = 1000 / fps;\n        let dt = 0;\n        const a = (t) => {\n            requestAnimationFrame(a);\n            dt = t - pt;\n            if (dt > interval) {\n                pt = t - (dt % interval);\n                this.update(pt / 1000);\n            }\n        };\n        a(t | 0);\n        return this;\n    }\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     *  Generate a texture and return a canvas element\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {*} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @returns {HTMLCanvasElement}\n     * @memberof DR\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new ShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.ShaderRenderer = ShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderer/ShaderRenderer.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/ShaderScene.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/ShaderScene.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shaderScene = void 0;\nexports.shaderScene = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime  time\r\n#define iResolution  resolution\r\n\r\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\r\n\r\nvoid mainImage(out vec4 O, vec2 C)\r\n{\r\n    O=vec4(0);\r\n    vec3 p;\r\n   vec3 r= vec3(iResolution.x,iResolution.y,0.);\r\n\t    \r\n    vec3 d =normalize(vec3((C-.5*r.xy)/r.y,1.)); \r\n for(float i=0.,g=0.,e,s;\r\n        ++i<99.;\r\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\r\n    )\r\n    {\r\n        p=g*d;\r\n        p.z+=iTime*.3;\r\n        p=R(p,normalize(vec3(1,2,3)),.5);   \r\n        s=2.5;\r\n        p=abs(mod(p-1.,2.)-1.)-1.;\r\n        for(int j=0;j++<10;)\r\n            p=1.-abs(p-1.),\r\n            s*=e=-1.8/dot(p,p),\r\n            p=p*e-.7;\r\n            g+=e=abs(p.z)/s+.001;           \r\n     }\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/ShaderScene.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainFragment.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainFragment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainFragment = void 0;\nexports.mainFragment = `\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform float sI;\r\n\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform sampler2D iChannel4;\r\n\r\n\r\nuniform sampler2D[5] channels;\r\n\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime time\r\n#define res resolution \r\n\r\nconst float GA =2.399; \r\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\r\n\r\n\r\nvec3 dof(sampler2D tex,vec2 uv,float rad)\r\n{\r\n\t\r\n\tvec3 acc=vec3(0);\r\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);;\r\n    rad=1.;\r\n\tfor (int j=0;j<80;j++){  \r\n        rad += 1./rad;\r\n\t    angle*=rot;\r\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\r\n\t\tacc+=col.xyz;\r\n\t}\r\n\treturn acc/80.;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{\r\n\r\n\tvec4 color = vec4(vec3(0.),1.);\r\n\r\n\tvec2 uv = gl_FragCoord.xy / res.xy;\r\n\r\n\tfloat blend,blend2,multi1,multi2;\r\n\t\r\n    blend=min (3. *abs(sin((.1*iTime)*3.1415/3.0)),1.); \r\n\r\n    blend2=min(2.5*abs(sin((.1*iTime)*3.1415/3.0)),1.); \r\n    \r\n    multi1=((fract(uv.x*6.-4.*uv.y*(1.-blend2))< 0.5 || uv.y<blend) \r\n    &&(fract(uv.x*6.-4.*uv.y*(1.-blend2))>=0.5 || uv.y>1.-blend))?1.:0.;\r\n\r\n \tmulti2=(fract(uv.x*12.-0.05-8.*uv.y*(1.-blend2))>0.9)?blend2:1.;\r\n   \r\n    uv.y=(fract(uv.x*6.-4.*uv.y*(1.-blend2))<0.5)?uv.y-(1.-blend):uv.y+=(1.-blend);\r\n\t\r\n\tif(sI ==0.0){\r\n\t\t//color = texture(iChannel0,uv);\r\n\t\tcolor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\r\n\t}else if(sI == 1.0){\r\n\t\tcolor = texture(iChannel1,uv);\r\n\t}else if(sI == 2.0){\r\n\t\t\tcolor=vec4(dof(iChannel2,uv,texture(iChannel2,uv).w),1.);\r\n\t}\t\r\n\telse{\r\n\t\tcolor = texture(iChannel3,uv);\r\n\t\t//color=vec4(dof(iChannel1,uv,texture(iChannel1,uv).w),1.);\r\n\t}\r\n\t\r\n\tfragColor = color; //multi1*multi2*blend2;\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainFragment.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainVertex.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainVertex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainVertex = void 0;\nexports.mainVertex = `\r\nlayout(location = 0) in vec2 pos; \r\nout vec4 fragColor;\r\nvoid main(){\r\n    gl_Position = vec4(pos.xy,0.0,1.0);\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainVertex.js?");

/***/ }),

/***/ "./build/wwwroot/src/demo.js":
/*!***********************************!*\
  !*** ./build/wwwroot/src/demo.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Sequence_1 = __webpack_require__(/*! ../../src/Engine/Sequence */ \"./build/src/Engine/Sequence.js\");\nconst Scene_1 = __webpack_require__(/*! ../../src/Engine/Scene */ \"./build/src/Engine/Scene.js\");\nconst Entity_1 = __webpack_require__(/*! ../../src/Engine/Entity */ \"./build/src/Engine/Entity.js\");\nconst ShaderEntity_1 = __webpack_require__(/*! ../../src/Engine/ShaderEntity */ \"./build/src/Engine/ShaderEntity.js\");\nconst mainFragment_1 = __webpack_require__(/*! ../assets/shaders/mainFragment */ \"./build/wwwroot/assets/shaders/mainFragment.js\");\nconst mainVertex_1 = __webpack_require__(/*! ../assets/shaders/mainVertex */ \"./build/wwwroot/assets/shaders/mainVertex.js\");\nconst ShaderScene_1 = __webpack_require__(/*! ../assets/shaders/ShaderScene */ \"./build/wwwroot/assets/shaders/ShaderScene.js\");\nconst typeWriterEffet_1 = __webpack_require__(/*! ./effects/typeWriterEffet */ \"./build/wwwroot/src/effects/typeWriterEffet.js\");\nconst ranndomSquareByTickEffect_1 = __webpack_require__(/*! ./effects/ranndomSquareByTickEffect */ \"./build/wwwroot/src/effects/ranndomSquareByTickEffect.js\");\nconst expandingCircleEffect_1 = __webpack_require__(/*! ./effects/expandingCircleEffect */ \"./build/wwwroot/src/effects/expandingCircleEffect.js\");\nconst starBurstEffct_1 = __webpack_require__(/*! ./effects/starBurstEffct */ \"./build/wwwroot/src/effects/starBurstEffct.js\");\nconst textEffect_1 = __webpack_require__(/*! ./effects/textEffect */ \"./build/wwwroot/src/effects/textEffect.js\");\nconst imageOverlayEffect_1 = __webpack_require__(/*! ./effects/imageOverlayEffect */ \"./build/wwwroot/src/effects/imageOverlayEffect.js\");\nconst textArrayDisplayEffect_1 = __webpack_require__(/*! ./effects/textArrayDisplayEffect */ \"./build/wwwroot/src/effects/textArrayDisplayEffect.js\");\nconst AssetsHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/AssetsHelper */ \"./build/src/Engine/Helpers/AssetsHelper.js\");\nclass SetupDemo {\n    constructor() {\n        this.scenes = [];\n        this.MockedGraph = {\n            canvasWidth: 800,\n            canvasHeight: 450,\n            audioProperties: {\n                bpm: 125,\n                ticks: 4,\n                beat: 0,\n                tick: 0,\n                bar: 0,\n                avgFreq: 0\n            },\n            font: \"Big Shoulders Stencil Text\"\n        };\n        this.sequence = new Sequence_1.Sequence(document.querySelector(\"canvas\"), 125, 4, 4, [], \"/wwwroot/assets/music/music.mp3\");\n    }\n    async addAsset(url) {\n        await AssetsHelper_1.TextureCacheHelper.loadImage(url);\n        return this;\n    }\n    addScene(scene) {\n        this.sequence.addScene(scene);\n    }\n    addEntity(key, entity) {\n        const scene = this.scenes.find(pre => {\n            return pre.name === key;\n        });\n        if (scene) {\n            scene.addEntity(entity);\n        }\n        else\n            throw Error(\"No such scene\");\n    }\n}\nconst demo = new SetupDemo();\ndemo.addAsset(\"assets/images/silhouette.png\").then((instance) => {\n    var _a;\n    const imageOverlayEntity = new Entity_1.Entity(\"ImageOverlay\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: 0,\n        y: 0,\n        width: instance.MockedGraph.canvasWidth,\n        height: instance.MockedGraph.canvasHeight,\n        image: (_a = AssetsHelper_1.TextureCacheHelper.textureCache.get(\"silhouette.png\")) === null || _a === void 0 ? void 0 : _a.src,\n        opacity: 0.7,\n        fadeIn: true,\n        fadeOut: true,\n        duration: 5,\n    }, (ts, ctx, props) => (0, imageOverlayEffect_1.imageOverlayEffect)(ts, ctx, props));\n    const expandingCircleEntity = new Entity_1.Entity(\"ExpandingCircle\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, {\n        x: instance.MockedGraph.canvasWidth / 2,\n        y: instance.MockedGraph.canvasHeight / 2,\n        radius: 0,\n        maxRadius: 450,\n        growthRate: 15,\n        duration: 5 // Scene duration in seconds\n    }, (ts, ctx, props) => (0, expandingCircleEffect_1.expandingCircleEffect)(ts, ctx, props, instance.sequence) // Pass the sequence instance\n    );\n    const starburstEntity = new Entity_1.Entity(\"Starburst\", instance.MockedGraph.canvasWidth, // Canvas width\n    instance.MockedGraph.canvasWidth, // Canvas height\n    {\n        x: instance.MockedGraph.canvasWidth / 2, // Example x-coordinate\n        y: instance.MockedGraph.canvasHeight / 2, // Example y-coordinate\n        numPoints: 8, // Example number of points\n        outerRadius: 50,\n        innerRadius: 25,\n        rotation: 0,\n        rotationSpeed: 2, // Example rotation speed\n        hue: 0,\n        saturation: 100,\n        lightness: 50\n    }, starBurstEffct_1.starburstEffect);\n    const scene1 = new Scene_1.Scene(\"Scene 1\", 0, 5000); // Starts at 0ms, duration 10000ms (10 second)\n    scene1.addEntity(expandingCircleEntity);\n    scene1.addEntity(starburstEntity);\n    scene1.addEntity(imageOverlayEntity);\n    instance.addScene(scene1);\n    const typeWriterProps = {\n        x: 100,\n        y: 300,\n        text: \"LEVEL 50 UNLOCKED - TIME TO PARTY!\",\n        index: 0,\n        speed: 5, // 5 characters per second\n        lastCharacterTime: 0,\n        useBPM: true,\n        bpm: instance.MockedGraph.audioProperties.bpm,\n        ticksPerBeat: instance.MockedGraph.audioProperties.ticks\n    };\n    const typeWriterEntity = new Entity_1.Entity(\"Typewriter\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, typeWriterProps, typeWriterEffet_1.typeWriterEffect);\n    const randomSquareProps = {\n        x: 0,\n        y: 0,\n        size: 0,\n        color: \"red\",\n        lastTick: -1 // Initialize to -1 to add a square on the first bar\n    };\n    const randomSquareEntity = new Entity_1.Entity(\"RandomSquare\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, randomSquareProps, (ts, ctx, props) => (0, ranndomSquareByTickEffect_1.randomSquareEffect)(ts, ctx, props, instance.sequence.tickCounter) // Pass currentBar from Sequence\n    );\n    const scene2 = new Scene_1.Scene(\"Scene 2\", 5000, 15000); // Starts at 1000ms, duration 5000ms\n    scene2.addEntity(randomSquareEntity);\n    scene2.addEntity(imageOverlayEntity);\n    scene2.addEntity(typeWriterEntity);\n    instance.addScene(scene2);\n    const shaderProps = {\n        mainFragmentShader: mainFragment_1.mainFragment,\n        mainShaderVertex: mainVertex_1.mainVertex,\n        rendeBuffers: [\n            {\n                name: \"MyShader\",\n                fragment: ShaderScene_1.shaderScene,\n                vertex: mainVertex_1.mainVertex,\n                textures: []\n            }\n        ]\n    };\n    const fractalShaderEntity = new ShaderEntity_1.ShaderEntity(\"ShaderEnriry\", 1200, instance.MockedGraph.canvasHeight, shaderProps, (ts, render, propertybag) => {\n        // access render here, i'e set uniforms etc using propertyBag or anyting;\n    });\n    const textOverlayProps = {\n        x: 100,\n        y: 100,\n        text: \"Vad du kan förvänta dig....\".toUpperCase(),\n        font: \"Big Shoulders Stencil Text\",\n        size: 60,\n        duration: 15 // 5 seconds\n    };\n    const textOverlay = new Entity_1.Entity(\"TextEffect\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasHeight, textOverlayProps, (ts, ctx, props) => (0, textEffect_1.textEffect)(ts, ctx, props, instance.sequence) // Pass the sequence instance\n    );\n    const textArrayDisplayEntity = new Entity_1.Entity(\"TextArrayDisplay\", instance.MockedGraph.canvasWidth, instance.MockedGraph.canvasWidth, {\n        x: 100, // Exempel x-koordinat\n        y: 200, // Exempel y-koordinat\n        texts: [\n            \"God matt & dryck.\".toUpperCase(),\n            \"..SKRATT & DANS!\".toUpperCase(),\n            \".. C64,AMIGA & PC DEMOS!\",\n            \"..EN ROLIG KVÄLL!\",\n        ],\n        font: instance.MockedGraph.font, // Eller \"Big Shoulders Stencil Text\" om den är laddad\n        size: 60,\n        currentBeat: 0,\n    }, (ts, ctx, props) => {\n        (0, textArrayDisplayEffect_1.textArrayDisplayEffect)(ts, ctx, props, instance.sequence);\n    });\n    const scene3 = new Scene_1.Scene(\"Scene 3\", 15000, 139200); // Starts at 1000ms, duration 5000ms\n    scene3.addEntity(fractalShaderEntity);\n    scene3.addEntity(imageOverlayEntity);\n    scene3.addEntity(textOverlay);\n    scene3.addEntity(textArrayDisplayEntity);\n    instance.addScene(scene3);\n});\ndemo.sequence.onReady = () => {\n    console.log(`click to start demo`);\n    document.addEventListener(\"click\", () => {\n        demo.sequence.play();\n    });\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/demo.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/expandingCircleEffect.js":
/*!************************************************************!*\
  !*** ./build/wwwroot/src/effects/expandingCircleEffect.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expandingCircleEffect = void 0;\nconst expandingCircleEffect = (ts, ctx, propertybag, sequence) => {\n    ctx.fillStyle = \"white\";\n    propertybag.radius =\n        propertybag.maxRadius *\n            (1 - sequence.getSceneRemainingTime(ts) / (propertybag.duration * 1000));\n    // Draw the circle\n    ctx.beginPath();\n    ctx.arc(propertybag.x, propertybag.y, propertybag.radius, 0, 2 * Math.PI);\n    ctx.fill();\n};\nexports.expandingCircleEffect = expandingCircleEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/expandingCircleEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/imageOverlayEffect.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/src/effects/imageOverlayEffect.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageOverlayEffect = void 0;\nconst imageOverlayEffect = (ts, ctx, propertybag) => {\n    const { x, y, width, height, image, opacity, fadeIn, fadeOut, duration } = propertybag;\n    ctx.drawImage(image, x, y, width, height);\n    ctx.globalAlpha = 1;\n};\nexports.imageOverlayEffect = imageOverlayEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/imageOverlayEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/ranndomSquareByTickEffect.js":
/*!****************************************************************!*\
  !*** ./build/wwwroot/src/effects/ranndomSquareByTickEffect.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomSquareEffect = void 0;\nconst randomSquareEffect = (ts, ctx, propertybag, tick) => {\n    if (tick !== propertybag.lastTick) {\n        propertybag.lastTick = tick;\n        ctx.globalAlpha = 0.5;\n        // Generate random properties for the square\n        propertybag.x = Math.random() * ctx.canvas.width;\n        propertybag.y = Math.random() * ctx.canvas.height;\n        propertybag.size = 20 + Math.random() * 50; // Random size between 20 and 70\n        propertybag.color = `hsl(${Math.random() * 360}, 100%, 50%)`; // Random color\n    }\n    // Draw the square\n    ctx.fillStyle = propertybag.color;\n    ctx.fillRect(propertybag.x, propertybag.y, propertybag.size, propertybag.size);\n};\nexports.randomSquareEffect = randomSquareEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/ranndomSquareByTickEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/starBurstEffct.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/src/effects/starBurstEffct.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.starburstEffect = void 0;\nconst starburstEffect = (ts, ctx, propertybag) => {\n    const { x, y, numPoints, outerRadius, innerRadius, rotation, rotationSpeed, hue, saturation, lightness } = propertybag;\n    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n    ctx.beginPath();\n    for (let i = 0; i < numPoints * 2; i++) {\n        const radius = i % 2 === 0 ? outerRadius : innerRadius;\n        const angle = (Math.PI * i) / numPoints + rotation;\n        const px = x + radius * Math.cos(angle);\n        const py = y + radius * Math.sin(angle);\n        if (i === 0) {\n            ctx.moveTo(px, py);\n        }\n        else {\n            ctx.lineTo(px, py);\n        }\n    }\n    ctx.closePath();\n    ctx.fill();\n    propertybag.rotation += rotationSpeed * (Math.PI / 180); // Update rotation\n};\nexports.starburstEffect = starburstEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/starBurstEffct.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/textArrayDisplayEffect.js":
/*!*************************************************************!*\
  !*** ./build/wwwroot/src/effects/textArrayDisplayEffect.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textArrayDisplayEffect = void 0;\nconst textArrayDisplayEffect = (ts, ctx, propertybag, sequence // Pass the Sequence instance\n) => {\n    const { x, y, texts, font, size } = propertybag;\n    console.log(\"caling\");\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    // Se till att currentBeat är inom gränserna för texts-arrayen\n    const index = Math.min(sequence.currentBeat - 1, texts.length - 1);\n    // Visa texten vid aktuellt index\n    if (index >= 0) {\n        ctx.fillText(texts[index], x, y);\n    }\n};\nexports.textArrayDisplayEffect = textArrayDisplayEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/textArrayDisplayEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/textEffect.js":
/*!*************************************************!*\
  !*** ./build/wwwroot/src/effects/textEffect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textEffect = void 0;\nconst textEffect = (ts, ctx, propertybag, sequence // Pass the Sequence instance\n) => {\n    const { x, y, text, font, size, duration } = propertybag;\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    const sceneRemainingTime = sequence.getSceneRemainingTime(ts);\n    const elapsed = duration - sceneRemainingTime / 1000; // Time elapsed in seconds\n    let alpha = 1;\n    if (elapsed < 1) {\n        alpha = elapsed; // Fade in over 1 second\n    }\n    if (sceneRemainingTime / 1000 < 1) {\n        alpha = sceneRemainingTime / 1000; // Fade out over 1 second\n    }\n    ctx.globalAlpha = alpha;\n    ctx.fillText(text, x, y);\n    ctx.globalAlpha = 1;\n};\nexports.textEffect = textEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/textEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/typeWriterEffet.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/src/effects/typeWriterEffet.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.typeWriterEffect = void 0;\nconst typeWriterEffect = (ts, ctx, propertybag) => {\n    ctx.font = \"68px Big Shoulders Stencil Text\";\n    ctx.fillStyle = \"white\";\n    let elapsedTime = 0;\n    if (propertybag.useBPM) {\n        // Calculate characters per beat\n        const charactersPerBeat = propertybag.speed / (propertybag.bpm / 60);\n        // Elapsed time in beats\n        elapsedTime = (ts - propertybag.lastCharacterTime) / (60000 / propertybag.bpm);\n    }\n    else {\n        // Calculate characters per tick\n        const charactersPerTick = propertybag.speed / ((propertybag.bpm * 4) / 60);\n        // Elapsed time in ticks\n        elapsedTime = (ts - propertybag.lastCharacterTime) / (60000 / (propertybag.bpm * propertybag.ticksPerBeat));\n    }\n    if (elapsedTime >= 1 / propertybag.speed) {\n        propertybag.index++;\n        propertybag.lastCharacterTime = ts;\n    }\n    // Draw the substring\n    const displayText = propertybag.text.substring(0, propertybag.index);\n    // Measure the full text width\n    const fullTextMetrics = ctx.measureText(propertybag.text);\n    const fullTextWidth = fullTextMetrics.width;\n    ctx.fillText(displayText, 10, propertybag.y / 2);\n};\nexports.typeWriterEffect = typeWriterEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/typeWriterEffet.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/demo.js");
/******/ 	
/******/ })()
;