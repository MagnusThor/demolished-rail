/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Audio/AudioLoader.js":
/*!***********************************************!*\
  !*** ./build/src/Engine/Audio/AudioLoader.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SonantAudioLoader = exports.DefaultAudioLoader = void 0;\nconst sonant = __importStar(__webpack_require__(/*! sonantx */ \"./node_modules/sonantx/dist/sonantx.bundle.js\"));\nconst EngineLogger_1 = __webpack_require__(/*! ../EngineLogger */ \"./build/src/Engine/EngineLogger.js\");\n// RegularAudioLoader.ts\nclass DefaultAudioLoader {\n    constructor(audioFile) {\n        this.audioFile = audioFile;\n    }\n    async loadAudio(audioContext) {\n        const response = await fetch(this.audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        EngineLogger_1.EngineLogger.log(`audioBuffer duration after decoding is ${audioBuffer.duration} seconds`);\n        return audioBuffer;\n    }\n}\nexports.DefaultAudioLoader = DefaultAudioLoader;\nclass SonantAudioLoader {\n    constructor(songData) {\n        this.songData = songData;\n    } // Replace 'any' with the actual type of your song data\n    async loadAudio(audioContext) {\n        console.log(`Generating audioBuffer - it may take a while`);\n        const audioBuffer = await sonant.generateSong(this.songData, audioContext.sampleRate);\n        EngineLogger_1.EngineLogger.log(`audioBuffer duration after decoding is ${audioBuffer.duration} seconds`);\n        return audioBuffer;\n    }\n}\nexports.SonantAudioLoader = SonantAudioLoader;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Audio/AudioLoader.js?");

/***/ }),

/***/ "./build/src/Engine/Conductor.js":
/*!***************************************!*\
  !*** ./build/src/Engine/Conductor.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Conductor = void 0;\nclass Conductor {\n    constructor() {\n        this.events = [];\n        this.currentTime = 0;\n    }\n    /**\n     * Adds an event to the timeline.\n     * @param event - The event to add.\n     */\n    addEvent(event) {\n        this.events.push(event);\n    }\n    /**\n     * Updates the current time of the timeline.\n     * @param time - The current time in milliseconds.\n     */\n    updateTime(time) {\n        this.currentTime = time;\n    }\n    triggerEvents(sequence) {\n        this.events.forEach(event => {\n            var _a;\n            const { time, beatCount, barCount, action, targetEntity, criteria, props } = event;\n            // Check if the event should be triggered\n            const timeCondition = time !== undefined ? this.currentTime >= time : true; // True if time is not specified\n            const beatCondition = beatCount !== undefined ? sequence.beatCounter >= beatCount : true; // True if beatCount is not specified\n            const barCondition = barCount !== undefined ? sequence.currentBar >= barCount : true; // True if barCount is not specified\n            const criteriaResult = criteria ? criteria() : true;\n            // Combine all conditions\n            if ((timeCondition && beatCondition && barCondition) && // All specified conditions must be true\n                criteriaResult // Criteria must also be true (if provided)\n            ) {\n                const entity = (_a = sequence.currentScene) === null || _a === void 0 ? void 0 : _a.entities.find(e => e.name === targetEntity);\n                if (entity) {\n                    action(entity, props, criteriaResult);\n                }\n            }\n        });\n    }\n}\nexports.Conductor = Conductor;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Conductor.js?");

/***/ }),

/***/ "./build/src/Engine/EngineLogger.js":
/*!******************************************!*\
  !*** ./build/src/Engine/EngineLogger.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EngineLogger = void 0;\nclass EngineLogger {\n    /**\n     * Enables or disables logging.\n     * @param enabled - Whether logging should be enabled or disabled.\n     */\n    static setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Logs messages to the console if logging is enabled.\n     * @param args - The messages to log.\n     */\n    static log(...args) {\n        if (this.enabled) {\n            console.log(...args);\n        }\n    }\n}\nexports.EngineLogger = EngineLogger;\nEngineLogger.enabled = true; // Add a flag to control logging\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/EngineLogger.js?");

/***/ }),

/***/ "./build/src/Engine/Entity/Canvas2DEntity.js":
/*!***************************************************!*\
  !*** ./build/src/Engine/Entity/Canvas2DEntity.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Canvas2DEntity = void 0;\nclass Canvas2DEntity {\n    /**\n     * Creates a new Entity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity.\n     * @param action - The action function that defines the entity's behavior.\n     */\n    constructor(name, props, action, startTimeinMs, durationInMs, w, h) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.w = w;\n        this.h = h;\n        this.postProcessors = [];\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w !== undefined && h !== undefined) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        ;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    bindToScene(scene) {\n        this.scene = scene;\n    }\n    /**\n    * Adds an event listener for when a beat occurs.\n    * @param listener - The function to call when a beat occurs.\n    * @returns The Entity instance for chaining.\n    */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Copies the entity's canvas to the target canvas and applies post-processors.\n     * @param targetCanvas - The target canvas to copy to.\n     * @param sequence - The Sequence instance.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n                this.postProcessors.forEach(processor => processor(targetCtx, sequence));\n            }\n        }\n    }\n    /**\n    * Updates the entity's state, clears the canvas, and calls the action function.\n    * @param timeStamp - The current timestamp in the animation.\n    */\n    update(timeStamp) {\n        var _a, _b;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props) {\n            // Calculate elapsed time relative to the scene's start time    \n            const sceneStartTime = this.getScene().startTimeinMs || 0;\n            const elapsed = timeStamp - sceneStartTime - (this.startTimeinMs || 0);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.ctx, this.props, (_b = this.getScene()) === null || _b === void 0 ? void 0 : _b.sequence, this);\n            }\n        }\n    }\n    /**\n   * Retrieves the Scene instance associated with the entity.\n   * @returns The Sequence instance if available, otherwise null.\n   */\n    getScene() {\n        return this.scene;\n    }\n    /**\n  * Retrieves the Sequence instance associated with the entity.\n  * @returns The Sequence instance if available, otherwise null.\n  */\n    getSequence() {\n        var _a;\n        return (_a = this.scene) === null || _a === void 0 ? void 0 : _a.sequence;\n    }\n}\nexports.Canvas2DEntity = Canvas2DEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity/Canvas2DEntity.js?");

/***/ }),

/***/ "./build/src/Engine/Entity/CompositeEntity.js":
/*!****************************************************!*\
  !*** ./build/src/Engine/Entity/CompositeEntity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompositeEntity = void 0;\nconst Canvas2DEntity_1 = __webpack_require__(/*! ./Canvas2DEntity */ \"./build/src/Engine/Entity/Canvas2DEntity.js\");\n/**\n * A CompositeEntity is a special type of Entity that can contain multiple Blocks.\n * Each block can have its own update function and properties, allowing for modular and reusable components within an entity.\n * @typeparam T - The type of ICompositeEntityProps for the entity.\n */\nclass CompositeEntity extends Canvas2DEntity_1.Canvas2DEntity {\n    /**\n     * Creates a new CompositeEntity.\n     * @param name - The name or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including an array of blocks.\n     */\n    constructor(name, w, h, props) {\n        super(name, props, (ts, ctx, props) => {\n            props.blocks.forEach(block => {\n                // Calculate the elapsed time for the block\n                const elapsed = ts - (block.startTimeinMs || 0);\n                // Check if the block should be rendered based on its lifetime\n                if (elapsed >= 0 && elapsed <= (block.durationInMs || Infinity)) {\n                    block.update(ts, ctx, this);\n                }\n            });\n        }, undefined, undefined, w, h);\n    }\n    /**\n     * Finds a block within the entity by its key.\n     * @param key - The key of the block to find.\n     * @returns The block if found, otherwise undefined.\n     */\n    findBlock(key) {\n        var _a;\n        return (_a = this.props) === null || _a === void 0 ? void 0 : _a.blocks.find(block => block.key === key);\n    }\n}\nexports.CompositeEntity = CompositeEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity/CompositeEntity.js?");

/***/ }),

/***/ "./build/src/Engine/Entity/GLSLShaderEntity.js":
/*!*****************************************************!*\
  !*** ./build/src/Engine/Entity/GLSLShaderEntity.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLSLShaderEntity = void 0;\nconst GlslShaderRenderer_1 = __webpack_require__(/*! ../ShaderRenderers/WebGL/GlslShaderRenderer */ \"./build/src/Engine/ShaderRenderers/WebGL/GlslShaderRenderer.js\");\nclass GLSLShaderEntity {\n    /**\n     * Creates a new ShaderEntity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including shader code and render buffers.\n     * @param action - An optional action function to be called before rendering the shaders.\n     */\n    constructor(name, props, action, w, h, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.w = w;\n        this.h = h;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w && h) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainVertexShader) {\n            this.shaderRenderer = new GlslShaderRenderer_1.GLSLShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainVertexShader, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            this.shaderRenderer.setEntity(this);\n            props.renderBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else {\n            throw new Error(\"Cannot create ShaderEntity: Missing main shader code.\");\n        }\n    }\n    bindToScene(scene) {\n        this.scene = scene;\n    }\n    /**\n * Adds an event listener for when a beat occurs.\n * @param listener - The function to call when a beat occurs.\n * @returns The Entity instance for chaining.§\n */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate elapsed time relative to the scene's start time\n            const sceneStartTime = this.scene ? this.scene.startTimeinMs : 0;\n            const elapsed = timeStamp - sceneStartTime - (this.startTimeinMs || 0);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props, this.getSequence(), this);\n                // Calculate shader time relative to the entity's start time (within the scene)\n                const shaderTime = Math.max(0, elapsed);\n                this.shaderRenderer.update(shaderTime / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n    /**\n    * Retrieves the Scene instance associated with the entity.\n    * @returns The Sequence instance if available, otherwise null.\n    */\n    getScene() {\n        return this.scene;\n    }\n    /**\n     * Retrieves the Sequence instance associated with the entity.\n     * @returns The Sequence instance if available, otherwise null.\n     */\n    getSequence() {\n        var _a;\n        return (_a = this.scene) === null || _a === void 0 ? void 0 : _a.sequence;\n    }\n}\nexports.GLSLShaderEntity = GLSLShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity/GLSLShaderEntity.js?");

/***/ }),

/***/ "./build/src/Engine/Entity/WGSLShaderEntity.js":
/*!*****************************************************!*\
  !*** ./build/src/Engine/Entity/WGSLShaderEntity.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WGSLShaderEntity = void 0;\nconst WgslShaderRenderer_1 = __webpack_require__(/*! ../ShaderRenderers/WebGPU/WgslShaderRenderer */ \"./build/src/Engine/ShaderRenderers/WebGPU/WgslShaderRenderer.js\");\nclass WGSLShaderEntity {\n    constructor(name, props, action, w, h, startTimeinMs, durationInMs) {\n        var _a, _b;\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.w = w;\n        this.h = h;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.canvas = props === null || props === void 0 ? void 0 : props.canvas;\n        if (props === null || props === void 0 ? void 0 : props.shader) {\n            this.shaderRenderer = new WgslShaderRenderer_1.WGSLShaderRenderer(this.canvas, (_a = this.props) === null || _a === void 0 ? void 0 : _a.device, (_b = this.props) === null || _b === void 0 ? void 0 : _b.context);\n            props.renderBuffers.forEach((buffer, index) => {\n                this.shaderRenderer.addRenderPass(buffer.name, buffer.shader, buffer.geometry, buffer.textures);\n            });\n            this.shaderRenderer.addMainRenderPass(props.shader);\n        }\n        else {\n            throw new Error(\"Cannot create WGSLShaderEntity: Missing main shader code.\");\n        }\n    }\n    bindToScene(scene) {\n        this.scene = scene;\n    }\n    /**\n * Adds an event listener for when a beat occurs.\n * @param listener - The function to call when a beat occurs.\n * @returns The Entity instance for chaining.\n */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate elapsed time relative to the scene's start time\n            const sceneStartTime = this.scene ? this.scene.startTimeinMs : 0;\n            const elapsed = timeStamp - sceneStartTime - (this.startTimeinMs || 0);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props, this.getSequence(), this);\n                // Calculate shader time relative to the entity's start time (within the scene)\n                const shaderTime = Math.max(0, elapsed);\n                this.shaderRenderer.update(shaderTime / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n    /**\n  * Retrieves the Scene instance associated with the entity.\n  * @returns The Sequence instance if available, otherwise null.\n  */\n    getScene() {\n        return this.scene;\n    }\n    /**\n     * Retrieves the Sequence instance associated with the entity.\n     * @returns The Sequence instance if available, otherwise null.\n     */\n    getSequence() {\n        var _a;\n        return (_a = this.scene) === null || _a === void 0 ? void 0 : _a.sequence;\n    }\n}\nexports.WGSLShaderEntity = WGSLShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity/WGSLShaderEntity.js?");

/***/ }),

/***/ "./build/src/Engine/Entity/WorldEntity.js":
/*!************************************************!*\
  !*** ./build/src/Engine/Entity/WorldEntity.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorldEntity = void 0;\nconst Canvas2DEntity_1 = __webpack_require__(/*! ./Canvas2DEntity */ \"./build/src/Engine/Entity/Canvas2DEntity.js\");\nconst worldEntityRenderer = (ts, ctx, propertybag, worldEnity) => {\n    const { worldWidth, worldHeight, viewportX, viewportWidth, viewportHeight } = propertybag;\n    // Create a temporary canvas to represent the world\n    const worldCanvas = document.createElement(\"canvas\");\n    worldCanvas.width = worldWidth;\n    worldCanvas.height = worldHeight;\n    const worldCtx = worldCanvas.getContext(\"2d\");\n    // Render the blocks onto the world canvas\n    propertybag.blocks.forEach(block => {\n        const elapsed = ts - (block.startTimeinMs || 0);\n        if (elapsed >= 0 && elapsed <= (block.durationInMs || Infinity)) {\n            block.update(ts, worldCtx, this); // Render on the world canvas\n        }\n    });\n    // check collition detectors attached to the world;\n    worldEnity.checkCollisions();\n    // Draw the portion of the world canvas that is within the viewport\n    ctx.drawImage(worldCanvas, viewportX, 0, viewportWidth, viewportHeight, 0, 0, viewportWidth, viewportHeight);\n};\n/**\n * WorldEntity main purpose is to be used in animations such as small games or implementations\n * requiering interactivity.\n * @export\n * @class WorldEntity\n * @extends {Canvas2DEntity<ICompositeEntityProps<IWorldProps>>}\n */\nclass WorldEntity extends Canvas2DEntity_1.Canvas2DEntity {\n    /**\n     * Creates an instance of WorldEntity.\n     * @param {string} name\n     * @param {IWorldProps} props\n     * @memberof WorldEntity\n     */\n    constructor(name, props) {\n        super(name, props, (ts, ctx, props) => worldEntityRenderer(ts, ctx, props, this), undefined, undefined, props.viewportWidth, props.viewportHeight);\n        this.name = name;\n        this.props = props;\n        this.collisionDetectors = [];\n    }\n    findBlock(key) {\n        var _a;\n        return (_a = this.props) === null || _a === void 0 ? void 0 : _a.blocks.find(block => block.key === key);\n    }\n    /**\n     * Scrolls the viewport horizontally.\n     * @param x - The new x-coordinate of the viewport.\n     */\n    setViewportX(x) {\n        const properties = this.props;\n        properties.viewportX = Math.max(0, Math.min(x, properties.worldWidth - properties.viewportWidth));\n    }\n    /**\n   * Adds a collision detector to the entity.\n   * @param targetKey - The key of the target block.\n   * @param sourceKey - The key of the source block.\n   * @param detectorFn - The collision detection function.\n   * @param onCollision - The callback function to be executed when a collision is detected.\n   */\n    addCollisionDetector(targetKey, sourceKey, detectorFn, onCollision) {\n        this.collisionDetectors.push({ targetKey, sourceKey, detectorFn, onCollision });\n    }\n    /**\n    * Checks for collisions between the registered collision detectors.\n    */\n    checkCollisions() {\n        this.collisionDetectors.forEach(detector => {\n            const targetBlock = this.findBlock(detector.targetKey); // Assuming 'any' for simplicity\n            const sourceBlock = this.findBlock(detector.sourceKey);\n            if (targetBlock && sourceBlock) {\n                if (detector.detectorFn(targetBlock.props, sourceBlock.props)) {\n                    detector.onCollision(targetBlock.props, sourceBlock.props);\n                }\n            }\n        });\n    }\n    /**\n    * Adds a block to the world.\n    * @param block - The block to add.\n    * @param startTime - The optional start time of the block within the scene (in milliseconds).\n    * @param duration - The optional duration of the block within the scene (in milliseconds).\n    * @returns The WorldEntity instance for chaining.\n    */\n    addBlock(block, startTime, duration) {\n        this.props.blocks.push(block);\n        block.startTimeinMs = startTime;\n        block.durationInMs = duration;\n        return this;\n    }\n    /**\n     * Adds multiple blocks to the world.\n     * @param blocks - The blocks to add.\n     * @returns The WorldEntity instance for chaining.\n     */\n    addBlocks(...blocks) {\n        blocks.forEach(block => this.props.blocks.push(block));\n        return this;\n    }\n}\nexports.WorldEntity = WorldEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Entity/WorldEntity.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/AssetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/AssetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssetsHelper = void 0;\nclass AssetsHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n    static async loadAudio(audioFile, audioContext) {\n        const response = await fetch(audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        return audioBuffer;\n    }\n}\nexports.AssetsHelper = AssetsHelper;\nAssetsHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/AssetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/CollisionHelper.js":
/*!*****************************************************!*\
  !*** ./build/src/Engine/Helpers/CollisionHelper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollisionHelper = void 0;\nclass CollisionHelper {\n    /**\n     * Checks for circular collision between two objects.\n     * @param a - The first object with properties x, y, and r (radius).\n     * @param b - The second object with properties x, y, and r (radius).\n     * @returns True if the objects are colliding, false otherwise.\n     */\n    static circularDetection(a, b) {\n        const dx = a.x - b.x;\n        const dy = a.y - b.y;\n        const distanceSquared = dx * dx + dy * dy;\n        const radiiSquared = (a.r + b.r) * (a.r + b.r);\n        return distanceSquared <= radiiSquared;\n    }\n    /**\n     * Checks for rectangular collision between two objects.\n     * @param a - The first object with properties x, y, w (width), and h (height).\n     * @param b - The second object with properties x, y, w (width), and h (height).\n     * @returns True if the objects are colliding, false otherwise.\n     */\n    static rectangularDetection(a, b) {\n        return (a.x < b.x + b.w &&\n            a.x + a.w > b.x &&\n            a.y < b.y + b.h &&\n            a.h + a.y > b.y);\n    }\n}\nexports.CollisionHelper = CollisionHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/CollisionHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/DebugHelper.js":
/*!*************************************************!*\
  !*** ./build/src/Engine/Helpers/DebugHelper.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DebugHelper = void 0;\nclass DebugHelper {\n    /**\n     * Creates a new DebugHelper to display debug information on the screen.\n     * @param sequence - The Sequence instance to get timing and beat information from.\n     * @param startScene - The optional scene number to start the debug display from.\n     */\n    constructor(sequence, startScene = 0) {\n        this.sequence = sequence;\n        this.startScene = startScene;\n        this.divElement = document.createElement(\"div\");\n        this.divElement.style.position = \"fixed\";\n        this.divElement.style.top = \"10px\";\n        this.divElement.style.left = \"10px\";\n        this.divElement.style.backgroundColor = \"rgba(0, 0, 0, 0.8)\";\n        this.divElement.style.color = \"white\";\n        this.divElement.style.padding = \"5px\";\n        this.divElement.style.fontFamily = \"monospace\";\n        this.divElement.style.zIndex = \"1000\";\n        document.body.appendChild(this.divElement);\n        this.startTime = performance.now(); // Initialize startTime\n    }\n    /**\n     * Updates the debug display with the current time, scene, beat, and bar information.\n     */\n    update() {\n        var _a;\n        const elapsedTimeMs = performance.now() - this.startTime; // Calculate elapsed time\n        const elapsedTimeSec = (elapsedTimeMs / 1000).toFixed(2);\n        const currentSceneName = ((_a = this.sequence.currentScene) === null || _a === void 0 ? void 0 : _a.name) || \"None\";\n        const currentBeat = this.sequence.currentBeat;\n        const currentBar = this.sequence.currentBar;\n        const beatCounter = this.sequence.beatCounter;\n        if (this.sequence.currentSceneIndex >= this.startScene) {\n            this.divElement.textContent = `\r\n        Elapsed Time: ${elapsedTimeMs.toFixed(0)}ms (${elapsedTimeSec}s)\r\n        Scene: ${currentSceneName}\r\n        Beat: ${currentBeat} (${beatCounter})\r\n        Bar: ${currentBar}\r\n      `;\n        }\n        else {\n            this.divElement.textContent = \"\";\n        }\n    }\n    addControls() {\n        const container = document.createElement(\"div\");\n        container.style.position = \"fixed\";\n        container.style.bottom = \"10px\";\n        container.style.left = \"10px\";\n        container.style.zIndex\n            = \"1000\";\n        document.body.appendChild(container);\n        // Create the slider\n        const slider = document.createElement(\"input\");\n        slider.type = \"range\";\n        slider.min = \"0\";\n        slider.max = this.sequence.durationMs.toString();\n        slider.value = \"0\";\n        slider.style.width = \"400px\";\n        container.appendChild(slider);\n        // Create the play/pause button\n        const playPauseButton = document.createElement(\"button\");\n        playPauseButton.textContent = \"Pause\";\n        container.appendChild(playPauseButton);\n        // Event listeners for slider and button\n        slider.addEventListener(\"input\", () => {\n            const time = parseInt(slider.value, 10);\n            this.sequence.pause(); // Pause the regular animation loop\n            this.sequence.renderAtTime(time); // Render the scene at the specified time\n        });\n        playPauseButton.addEventListener(\"click\", () => {\n            if (this.sequence.isPlaying) {\n                this.sequence.pause();\n                playPauseButton.textContent = \"Play\";\n            }\n            else {\n                this.sequence.play();\n                playPauseButton.textContent = \"Pause\";\n            }\n        });\n    }\n}\nexports.DebugHelper = DebugHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/DebugHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/EntityBuilder.js":
/*!***************************************************!*\
  !*** ./build/src/Engine/Helpers/EntityBuilder.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityRenderer = exports.EntityBuilder = void 0;\nclass EntityBuilder {\n    constructor() {\n        this.entities = [];\n        this.currentTime = 0;\n    }\n    /**\n     * Adds an entity to the builder with a specified start time and duration.\n     * @param entity - The entity to add.\n     * @param startTime - The start time of the entity within the scene (in milliseconds).\n     * @param duration - The duration of the entity within the scene (in milliseconds).\n     * @returns The EntityBuilder instance for chaining.\n     */\n    addEntity(entity, startTime, duration) {\n        entity.startTimeinMs = startTime !== undefined ? startTime + this.currentTime : undefined;\n        entity.durationInMs = duration;\n        this.currentTime += duration || 0; // Increment currentTime only if duration is provided\n        this.entities.push(entity);\n        return this;\n    }\n    /**\n     * Sets the graph object to be used for adding entities by name.\n     * @param graph - An object containing entities accessible by name.\n     * @returns The EntityBuilder instance for chaining.\n     */\n    setGraph(graph) {\n        this.graph = graph;\n        return this;\n    }\n    /**\n     * Adds an entity from the graph by its name.\n     * @param entityName - The name of the entity in the graph.\n     * @param startTime - The start time of the entity within the scene (in milliseconds).\n     * @param duration - The duration of the entity within the scene (in milliseconds).\n     * @returns The EntityBuilder instance for chaining.\n     */\n    addEntityByName(entityName, startTime, duration) {\n        if (!this.graph) {\n            throw new Error(\"Cannot add entity by name: graph is not set.\");\n        }\n        const entity = this.graph[entityName];\n        if (!entity) {\n            throw new Error(`Entity with name \"${entityName}\" not found in the graph.`);\n        }\n        return this.addEntity(entity, startTime, duration);\n    }\n    /**\n     * Gets the array of entities with their timing configured.\n     * @returns The array of IEntity objects.\n     */\n    getEntities() {\n        return this.entities;\n    }\n}\nexports.EntityBuilder = EntityBuilder;\nclass EntityRenderer {\n    /**\n     * Creates a new EntityRenderer to render entities without a Sequence.\n     * @param canvas - The canvas element to render to.\n     */\n    constructor(canvas) {\n        this.entities = [];\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n    }\n    /**\n     * Adds an entity to the renderer.\n     * @param entity - The entity to add.\n     */\n    addEntity(entity) {\n        this.entities.push(entity);\n        entity.canvas.width = this.canvas.width;\n        entity.canvas.height = this.canvas.height;\n    }\n    /**\n     * Starts the rendering loop.\n     */\n    start() {\n        const animate = (ts) => {\n            this.render(ts);\n            requestAnimationFrame(animate);\n        };\n        requestAnimationFrame(animate);\n    }\n    /**\n     * Renders the entities on the canvas.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    render(timeStamp) {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // Clear the canvas\n        this.entities.forEach(entity => {\n            entity.update(timeStamp);\n            this.copyToCanvas(entity.canvas);\n        });\n    }\n    copyToCanvas(result) {\n        this.ctx.drawImage(result, 0, 0);\n    }\n}\nexports.EntityRenderer = EntityRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/EntityBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/EntityTransitions.js":
/*!*******************************************************!*\
  !*** ./build/src/Engine/Helpers/EntityTransitions.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFadeOutTransition = exports.createFadeInTransition = void 0;\nconst createFadeInTransition = (duration = 1000) => (ctx, progress) => {\n    ctx.globalAlpha = Math.min(1, progress * duration / 1000);\n};\nexports.createFadeInTransition = createFadeInTransition;\nconst createFadeOutTransition = (duration = 1000) => (ctx, progress) => {\n    ctx.globalAlpha = Math.max(0, 1 - (progress * duration / 1000));\n};\nexports.createFadeOutTransition = createFadeOutTransition;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/EntityTransitions.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/InputHelper.js":
/*!*************************************************!*\
  !*** ./build/src/Engine/Helpers/InputHelper.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InputHelper = void 0;\nclass InputHelper {\n    /**\n     * Initializes the Input class by attaching event listeners for keyboard and mouse events.\n     */\n    constructor(parent) {\n        this.keys = new Set();\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.mouseButtons = new Set();\n        this.keyListeners = {};\n        window.addEventListener('keydown', (e) => this.onKeyDown(e));\n        window.addEventListener('keyup', (e) => this.onKeyUp(e));\n        parent.addEventListener('mousemove', (e) => this.onMouseMove(e));\n        parent.addEventListener('mousedown', (e) => this.onMouseDown(e));\n        parent.addEventListener('mouseup', (e) => this.onMouseUp(e));\n    }\n    /**\n     * Checks if a specific key is currently pressed.\n     * @param key - The key to check (e.g., \"a\", \"ArrowUp\", \" \").\n     * @returns True if the key is pressed, false otherwise.\n     */\n    isKeyPressed(key) {\n        return this.keys.has(key);\n    }\n    /**\n     * Gets the current mouse X coordinate.\n     * @returns The mouse X coordinate.\n     */\n    getMouseX() {\n        return this.mouseX;\n    }\n    /**\n     * Gets the current mouse Y coordinate.\n     * @returns The mouse Y coordinate.\n     */\n    getMouseY() {\n        return this.mouseY;\n    }\n    /**\n     * Checks if a specific mouse button is currently pressed.\n     * @param button - The mouse button to check (0 for left, 1 for middle, 2 for right).\n     * @returns True if the button is pressed, false otherwise.\n     */\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    /**\n     * Adds an event listener for a specific key.\n     * @param key - The key to listen for (e.g., \"a\", \"ArrowUp\", \" \").\n     * @param listener - The function to call when the key is pressed.\n     * @returns The Input instance for chaining.\n     */\n    on(key, listener) {\n        if (!this.keyListeners[key]) {\n            this.keyListeners[key] = [];\n        }\n        this.keyListeners[key].push(listener);\n        return this;\n    }\n    // --- Event Handlers ---\n    onKeyDown(event) {\n        this.keys.add(event.key);\n        // Trigger key listeners\n        if (this.keyListeners[event.key]) {\n            this.keyListeners[event.key].forEach(listener => listener());\n        }\n    }\n    onKeyUp(event) {\n        this.keys.delete(event.key);\n    }\n    onMouseMove(event) {\n        this.mouseX = event.clientX;\n        this.mouseY = event.clientY;\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n    }\n}\nexports.InputHelper = InputHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/InputHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/Math/MathHelper.js":
/*!*****************************************************!*\
  !*** ./build/src/Engine/Helpers/Math/MathHelper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MathHelper = void 0;\nconst Point2D_1 = __webpack_require__(/*! ./Point2D */ \"./build/src/Engine/Helpers/Math/Point2D.js\");\nconst Point3D_1 = __webpack_require__(/*! ./Point3D */ \"./build/src/Engine/Helpers/Math/Point3D.js\");\n/**\n * A helper class for common math operations.\n */\nclass MathHelper {\n    /**\n     * Clamps a value between a minimum and maximum value.\n     * @param value - The value to clamp.\n     * @param min - The minimum value.\n     * @param max - The maximum value.\n     * @returns The clamped value.\n     */\n    static clamp(value, min, max) {\n        return Math.max(min, Math.min(value, max));\n    }\n    /**\n     * Linearly interpolates between two values.\n     * @param t - The interpolation factor (between 0 and 1).\n     * @param a - The first value.\n     * @param b - The second value.\n     * @returns The interpolated value.\n     */\n    static lerp(t, a, b) {\n        return a + t * (b - a);\n    }\n    /**\n     * Linearly interpolates between two vectors.\n     * @param t - The interpolation factor (between 0 and 1).\n     * @param a - The first vector.\n     * @param b - The second vector.\n     * @returns The interpolated vector.\n     */\n    static lerpVector(t, a, b) {\n        const x = this.lerp(t, a.x, b.x);\n        const y = this.lerp(t, a.y, b.y);\n        if (a instanceof Point3D_1.Point3D && b instanceof Point3D_1.Point3D) {\n            const z = this.lerp(t, a.z, b.z);\n            return new Point3D_1.Point3D(x, y, z, a.u, a.v);\n        }\n        else {\n            return new Point2D_1.Point2D(x, y);\n        }\n    }\n    /**\n     * Calculates the smoothstep value between two edges.\n     * @param edge0 - The lower edge.\n     * @param edge1 - The upper edge.\n     * @param x - The value to evaluate.\n     * @returns The smoothstep value.\n     */\n    static smoothstep(edge0, edge1, x) {\n        const t = this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        return t * t * (3.0 - 2.0 * t);\n    }\n    /**\n     * Generates a random integer within a specified range.\n     * @param min - The minimum value (inclusive).\n     * @param max - The maximum value (exclusive).\n     * @returns A random integer within the range.\n     */\n    static randomInt(min, max) {\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    /**\n     * Maps a value from one range to another.\n     * @param value - The value to map.\n     * @param inMin - The minimum value of the input range.\n     * @param inMax - The maximum value of the input range.\n     * @param outMin - The minimum value of the output range.\n     * @param outMax - The maximum value of the output range.\n     * @returns The mapped value.\n     */\n    static map(value, inMin, inMax, outMin, outMax) {\n        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n    }\n    /**\n       * Calculates the sine of an angle in degrees.\n       * @param degrees - The angle in degrees.\n       * @returns The sine of the angle.\n       */\n    static sinDeg(degrees) {\n        return Math.sin(degrees * Math.PI / 180);\n    }\n    /**\n     * Calculates the cosine of an angle in degrees.\n     * @param degrees - The angle in degrees.\n     * @returns The cosine of the angle.\n     */\n    static cosDeg(degrees) {\n        return Math.cos(degrees * Math.PI / 180);\n    }\n    /**\n     * Calculates the tangent of an angle in degrees.\n     * @param degrees - The angle in degrees.\n     * @returns The tangent of the angle.\n     */\n    static tanDeg(degrees) {\n        return Math.tan(degrees * Math.PI / 180);\n    }\n    /**\n     * Calculates the arcsine (inverse sine) of a value.\n     * @param value - The value.\n     * @returns The arcsine of the value in degrees.\n     */\n    static asinDeg(value) {\n        return Math.asin(value) * 180 / Math.PI;\n    }\n    /**\n     * Calculates the arccosine (inverse cosine) of a value.\n     * @param value - The value.\n     * @returns The arccosine of the value in degrees.\n     */\n    static acosDeg(value) {\n        return Math.acos(value) * 180 / Math.PI;\n    }\n    /**\n     * Calculates the arctangent (inverse tangent) of a value.\n     * @param value - The value.\n     * @returns The arctangent of the value in degrees.\n     */\n    static atanDeg(value) {\n        return Math.atan(value) * 180 / Math.PI;\n    }\n    /**\n     * Creates a 4x4 identity matrix.\n     * @returns A new 4x4 identity matrix as a Float32Array.\n     */\n    static identityMatrix4x4() {\n        return new Float32Array([\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        ]);\n    }\n    /**\n     * Creates a 4x4 translation matrix.\n     * @param x - The translation in the x-axis.\n     * @param y - The translation in the y-axis.\n     * @param z - The translation in\n   the z-axis.\n     * @returns A new 4x4 translation matrix as a Float32Array.\n     */\n    static translationMatrix4x4(x, y, z) {\n        const matrix = this.identityMatrix4x4();\n        matrix[12] = x;\n        matrix[13] = y;\n        matrix[14] = z;\n        return matrix;\n    }\n    /**\n     * Creates a 4x4 rotation matrix around the X-axis.\n     * @param angle - The rotation angle in degrees.\n     * @returns A new 4x4 rotation matrix as a Float32Array.\n     */\n    static rotationMatrix4x4X(angle) {\n        const rad = angle * Math.PI / 180;\n        const c = Math.cos(rad);\n        const s = Math.sin(rad);\n        const matrix = this.identityMatrix4x4();\n        matrix[5] = c;\n        matrix[6] = -s;\n        matrix[9] = s;\n        matrix[10] = c;\n        return matrix;\n    }\n    /**\n     * Creates a 4x4 rotation matrix around the Y-axis.\n     * @param angle - The rotation angle in degrees.\n     * @returns A new 4x4 rotation matrix as a Float32Array.\n     */\n    static rotationMatrix4x4Y(angle) {\n        const rad = angle * Math.PI / 180;\n        const c = Math.cos(rad);\n        const s = Math.sin(rad);\n        const matrix = this.identityMatrix4x4();\n        matrix[0] = c;\n        matrix[2] = s;\n        matrix[8] = -s;\n        matrix[10] = c;\n        return matrix;\n    }\n    /**\n     * Creates a 4x4 rotation matrix around the Z-axis.\n     * @param angle - The rotation angle in degrees.\n     * @returns A new 4x4 rotation matrix as a Float32Array.\n     */\n    static rotationMatrix4x4Z(angle) {\n        const rad = angle * Math.PI / 180;\n        const c = Math.cos(rad);\n        const s = Math.sin(rad);\n        const matrix = this.identityMatrix4x4();\n        matrix[0] = c;\n        matrix[1] = -s;\n        matrix[4] = s;\n        matrix[5] = c;\n        return matrix;\n    }\n    /**\n     * Multiplies two 4x4 matrices.\n     * @param a - The first matrix.\n     * @param b - The second matrix.\n     * @returns A new 4x4 matrix representing the product of a and b.\n     */\n    static multiplyMatrices4x4(a, b) {\n        const result = new Float32Array(16);\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                let sum = 0;\n                for (let k = 0; k < 4; k++) {\n                    sum += a[i * 4 + k] * b[k * 4 + j];\n                }\n                result[i * 4 + j] = sum;\n            }\n        }\n        return result;\n    }\n    /**\n    * Creates a quaternion from an axis and an angle.\n    * @param axis - The rotation axis as a Point3D.\n    * @param angle - The rotation angle in degrees.\n    * @returns A new quaternion as a Float32Array.\n    */\n    static createQuaternion(axis, angle) {\n        const rad = angle * Math.PI / 180;\n        const s = Math.sin(rad / 2);\n        return new Float32Array([\n            axis.x * s,\n            axis.y * s,\n            axis.z * s,\n            Math.cos(rad / 2)\n        ]);\n    }\n    /**\n     * Multiplies two quaternions.\n     * @param q1 - The first quaternion.\n     * @param q2 - The second quaternion.\n     * @returns A new quaternion representing the product of q1 and q2.\n     */\n    static multiplyQuaternions(q1, q2) {\n        const [x1, y1, z1, w1] = q1;\n        const [x2, y2, z2, w2] = q2;\n        return new Float32Array([\n            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,\n            w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2,\n            w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2,\n            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        ]);\n    }\n    /**\n     * Normalizes a quaternion.\n     * @param q - The quaternion to normalize.\n     * @returns A new normalized quaternion.\n     */\n    static normalizeQuaternion(q) {\n        const [x, y, z, w] = q;\n        const magnitude = Math.sqrt(x * x + y * y + z * z + w * w);\n        return new Float32Array([x / magnitude, y / magnitude, z / magnitude, w / magnitude]);\n    }\n    /**\n     * Calculates the conjugate of a quaternion.\n     * @param q - The quaternion.\n     * @returns A new quaternion representing the conjugate of q.\n     */\n    static conjugateQuaternion(q) {\n        const [x, y, z, w] = q;\n        return new Float32Array([-x, -y, -z, w]);\n    }\n    /**\n     * Converts a 4x4 rotation matrix to a quaternion.\n     * @param m - The rotation matrix as a Float32Array.\n     * @returns A new quaternion as a Float32Array.\n     */\n    static rotationMatrixToQuaternion(m) {\n        const tr = m[0] + m[5] + m[10];\n        let S, x, y, z, w;\n        if (tr > 0) {\n            S = Math.sqrt(tr + 1.0) * 2; // S=4*qw \n            w = 0.25 * S;\n            x = (m[6] - m[9]) / S;\n            y = (m[8] - m[2]) / S;\n            z = (m[1] - m[4]) / S;\n        }\n        else if ((m[0] > m[5]) && (m[0] > m[10])) {\n            S = Math.sqrt(1.0 + m[0] - m[5] - m[10]) * 2; // S=4*qx \n            x = 0.25 * S;\n            y = (m[1] + m[4]) / S;\n            z = (m[8] + m[2]) / S;\n            w = (m[6] - m[9]) / S;\n        }\n        else if (m[5] > m[10]) {\n            S = Math.sqrt(1.0 + m[5] - m[0] - m[10]) * 2; // S=4*qy\n            y = 0.25 * S;\n            x = (m[1] + m[4]) / S;\n            z = (m[6] + m[9]) / S;\n            w = (m[8] - m[2]) / S;\n        }\n        else {\n            S = Math.sqrt(1.0 + m[10] - m[0] - m[5]) * 2; // S=4*qz\n            z = 0.25 * S;\n            x = (m[8] + m[2]) / S;\n            y = (m[6] + m[9]) / S;\n            w = (m[1] - m[4]) / S;\n        }\n        return new Float32Array([x, y, z, w]);\n    }\n    /**\n     * Creates a quaternion from Euler angles (in degrees).\n     * @param x - The rotation angle around the X-axis in degrees.\n     * @param y - The rotation angle around the Y-axis in degrees.\n     * @param z - The rotation angle around the Z-axis in degrees.\n     * @returns A new quaternion as a Float32Array.\n     */\n    static fromEulerAngles(x, y, z) {\n        const roll = x * Math.PI / 180;\n        const pitch = y * Math.PI / 180;\n        const yaw = z * Math.PI / 180;\n        const cy = Math.cos(yaw * 0.5);\n        const sy = Math.sin(yaw * 0.5);\n        const cp = Math.cos(pitch * 0.5);\n        const sp = Math.sin(pitch * 0.5);\n        const cr = Math.cos(roll * 0.5);\n        const sr = Math.sin(roll * 0.5);\n        return new Float32Array([\n            sr * cp * cy - cr * sp * sy,\n            cr * sp * cy + sr * cp * sy,\n            cr * cp * sy - sr * sp * cy,\n            cr * cp * cy + sr * sp * sy\n        ]);\n    }\n}\nexports.MathHelper = MathHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/Math/MathHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/Math/Point2D.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/Math/Point2D.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Point2D = void 0;\nclass Point2D {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Calculates the distance between this point and another point.\n     * @param other - The other point.\n     * @returns The distance between the two points.\n     */\n    distanceTo(other) {\n        const dx = this.x - other.x;\n        const dy = this.y - other.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Calculates the angle between this point (as a vector) and another point.\n     * @param other - The other point.\n     * @returns The angle between the two vectors in radians.\n     */\n    angleTo(other) {\n        const dot = this.dot(other);\n        const mag1 = this.length();\n        const mag2 = other.length();\n        return Math.acos(dot / (mag1 * mag2));\n    }\n    /**\n     * Calculates the dot product of this point (as a vector) and another point.\n     * @param other - The other point.\n     * @returns The dot product.\n     */\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n    /**\n     * Calculates the length of the vector represented by the point.\n     * @returns The length of the vector.\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n}\nexports.Point2D = Point2D;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/Math/Point2D.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/Math/Point3D.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/Math/Point3D.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Point3D = void 0;\nconst Point2D_1 = __webpack_require__(/*! ./Point2D */ \"./build/src/Engine/Helpers/Math/Point2D.js\");\nclass Point3D extends Point2D_1.Point2D {\n    constructor(x, y, z, u, v) {\n        super(x, y); // Call the superclass constructor\n        this.z = z;\n        this.u = u;\n        this.v = v;\n    }\n    /**\n* Rotates the point around the X-axis by the given angle.\n* @param angle - The angle in degrees.\n* @returns A new Point3D representing the rotated point.\n*/\n    rotateX(angle) {\n        const rad = angle * Math.PI / 180;\n        const cosa = Math.cos(rad);\n        const sina = Math.sin(rad);\n        const y = this.y * cosa - this.z * sina;\n        const z = this.y * sina + this.z * cosa;\n        return new Point3D(this.x, y, z, this.u, this.v);\n    }\n    /**\n     * Rotates the point around the Y-axis by the given angle.\n     * @param angle - The angle in degrees.\n     * @returns A new Point3D representing the rotated point.\n     */\n    rotateY(angle) {\n        const rad = angle * Math.PI / 180;\n        const cosa = Math.cos(rad);\n        const sina = Math.sin(rad);\n        const z = this.z * cosa - this.x * sina;\n        const x = this.z * sina + this.x * cosa;\n        return new Point3D(x, this.y, z, this.u, this.v);\n    }\n    /**\n     * Rotates the point around the Z-axis by the given angle.\n     * @param angle - The angle in degrees.\n     * @returns A new Point3D representing the rotated point.\n     */\n    rotateZ(angle) {\n        const rad = angle * Math.PI / 180;\n        const cosa = Math.cos(rad);\n        const sina = Math.sin(rad);\n        const x = this.x * cosa - this.y * sina;\n        const y = this.x * sina + this.y * cosa;\n        return new Point3D(x, y, this.z, this.u, this.v);\n    }\n    /**\n     * Calculates the length of the vector represented by the point.\n     * @returns The length of the vector.\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Scales the point's coordinates by the given scale factor.\n     * @param scale - The scale factor.\n     */\n    scale(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n    }\n    /**\n     * Normalizes the point, making it a unit vector with length 1.\n     * @returns True if the normalization was successful, false otherwise (if the length is 0).\n     */\n    normalize() {\n        const length = this.length();\n        if (length !== 0) {\n            this.x /= length;\n            this.y /= length;\n            this.z /= length;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Calculates the angle between this point (as a vector) and another point.\n     * @param bvector - The other point.\n     * @returns The angle between the two vectors in radians.\n     */\n    angle(bvector) {\n        const anorm = new Point3D(this.x, this.y, this.z, this.u, this.v);\n        anorm.normalize();\n        const bnorm = new Point3D(bvector.x, bvector.y, bvector.z, this.u, this.v);\n        bnorm.normalize();\n        const dotval = anorm.dot(bnorm);\n        return Math.acos(dotval);\n    }\n    /**\n     * Calculates the cross product of this point (as a vector) and another point.\n     * @param vectorB - The other point.\n     */\n    cross(vectorB) {\n        const tempvec = new Point3D(this.x, this.y, this.z, this.u, this.v);\n        tempvec.x = (this.y * vectorB.z) - (this.z * vectorB.y);\n        tempvec.y = (this.z * vectorB.x) - (this.x * vectorB.z);\n        tempvec.z = (this.x * vectorB.y) - (this.y\n            * vectorB.x);\n        this.x = tempvec.x;\n        this.y = tempvec.y;\n        this.z = tempvec.z;\n    }\n    /**\n     * Calculates the dot product of this point (as a vector) and another point.\n     * @param vectorB - The other point.\n     * @returns The dot product.\n     */\n    dot(vectorB) {\n        return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;\n    }\n    /**\n     * Projects the point onto a 2D plane given the view parameters.\n     * @param viewWidth - The width of the view.\n     * @param viewHeight - The height of the view.\n     * @param fov - The field of view.\n     * @param viewDistance - The view distance.\n     * @returns A new Point3D representing the projected point.\n     */\n    project(viewWidth, viewHeight, fov, viewDistance) {\n        const factor = fov / (viewDistance + this.z);\n        const x = this.x * factor + viewWidth / 2;\n        const y = this.y * factor + viewHeight / 2;\n        return new Point3D(x, y, this.z, this.u, this.v);\n    }\n}\nexports.Point3D = Point3D;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/Math/Point3D.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/PostProcessors.js":
/*!****************************************************!*\
  !*** ./build/src/Engine/Helpers/PostProcessors.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createInvertPostProcessor = exports.createGrayscalePostProcessor = exports.createBlurPostProcessor = void 0;\nconst createBlurPostProcessor = (blurAmount = 5) => {\n    return (ctx) => {\n        ctx.filter = `blur(${blurAmount}px)`; // Apply blur filter\n        ctx.drawImage(ctx.canvas, 0, 0); // Redraw the canvas with the filter\n        ctx.filter = \"none\"; // Reset the filter\n    };\n};\nexports.createBlurPostProcessor = createBlurPostProcessor;\nconst createGrayscalePostProcessor = () => {\n    return (ctx) => {\n        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n        const data = imageData.data;\n        for (let i = 0; i < data.length; i += 4) {\n            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n            data[i] = avg; // Red\n            data[i + 1] = avg; // Green\n            data[i + 2] = avg; // Blue\n        }\n        ctx.putImageData(imageData, 0, 0);\n    };\n};\nexports.createGrayscalePostProcessor = createGrayscalePostProcessor;\nconst createInvertPostProcessor = () => {\n    return (ctx) => {\n        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n        const data = imageData.data;\n        for (let i = 0; i < data.length; i += 4) {\n            data[i] = 255 - data[i]; // Red\n            data[i + 1] = 255 - data[i + 1]; // Green\n            data[i + 2] = 255 - data[i + 2]; // Blue\n        }\n        ctx.putImageData(imageData, 0, 0);\n    };\n};\nexports.createInvertPostProcessor = createInvertPostProcessor;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/PostProcessors.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/SceneBuilder.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/SceneBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneBuilder = void 0;\nconst Scene_1 = __webpack_require__(/*! ../Scene */ \"./build/src/Engine/Scene.js\");\nclass SceneBuilder {\n    /**\n     * Creates a new SceneBuilder to help construct scenes with automatic timing.\n     * @param totalDuration - The total duration of the animation sequence in milliseconds.\n     */\n    constructor(totalDuration) {\n        this.scenes = [];\n        this.currentTime = 0;\n        this.totalDuration = totalDuration;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and duration.\n     * @param name - The name of the scene.\n     * @param duration - The duration of the scene in milliseconds.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    addScene(name, duration) {\n        const startTime = this.currentTime;\n        this.currentTime += duration;\n        // If the current time exceeds the total duration, adjust the last scene's duration\n        if (this.currentTime > this.totalDuration) {\n            const lastScene = this.scenes[this.scenes.length - 1];\n            if (lastScene) {\n                lastScene.durationInMs = this.totalDuration - lastScene.startTimeinMs;\n            }\n            duration = this.totalDuration - startTime; // Adjust the current scene's duration as well\n        }\n        const scene = new Scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this; // For chaining\n    }\n    /**\n     * Gets the array of scenes with their timing configured.\n     * @returns The array of Scene objects.\n     */\n    getScenes() {\n        return this.scenes;\n    }\n    /**\n     * Gets the total duration of all scenes added to the builder.\n     * @returns The total duration in milliseconds.\n     */\n    get totalScenesDuration() {\n        return this.scenes.reduce((total, scene) => total + scene.durationInMs, 0);\n    }\n    /**\n     * Adds a scene to the builder with a specified name and a duration that extends to the end of the total duration.\n     * @param name - The name of the scene.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    durationUntilEndInMs(name) {\n        const startTime = this.currentTime;\n        const duration = this.totalDuration - startTime;\n        const scene = new Scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this;\n    }\n}\nexports.SceneBuilder = SceneBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/SceneBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/SequenceHelper.js":
/*!****************************************************!*\
  !*** ./build/src/Engine/Helpers/SequenceHelper.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SequenceHelper = void 0;\nclass SequenceHelper {\n    /**\n     * Calculates the duration in milliseconds for a given number of beats.\n     * @param bpm - The beats per minute.\n     * @param numBeats - The number of beats.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForBeats(bpm, numBeats) {\n        const millisecondsPerBeat = 60000 / bpm;\n        return numBeats * millisecondsPerBeat;\n    }\n    /**\n     * Calculates the duration in milliseconds for a given number of bars.\n     * @param bpm - The beats per minute.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param numBars - The number of bars.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForBars(bpm, beatsPerBar, numBars) {\n        const millisecondsPerBar = (60000 / bpm) * beatsPerBar;\n        return numBars * millisecondsPerBar;\n    }\n    /**\n     * Calculates the duration in milliseconds for a given number of ticks.\n     * @param bpm - The beats per minute.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param numTicks - The number of ticks.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForTicks(bpm, ticksPerBeat, numTicks) {\n        const millisecondsPerTick = 60000 / (bpm * ticksPerBeat);\n        return numTicks * millisecondsPerTick;\n    }\n}\nexports.SequenceHelper = SequenceHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/SequenceHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/TextureHelper.js":
/*!***************************************************!*\
  !*** ./build/src/Engine/Helpers/TextureHelper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CanvasTextureGen = exports.TextureGenerator = exports.TextureGeneratorBase = void 0;\n/**\n * Base class for texture generation, providing helper methods for vector math, noise functions, and color manipulation.\n */\nclass TextureGeneratorBase {\n    /**\n     * Creates a new TextureBase instance.\n     * Initializes the permutation table for Perlin noise.\n     */\n    constructor() {\n        this.perm = this.seed(255);\n    }\n    /**\n     * Creates a vector (array) with the given components.\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param a - The w component (optional).\n     * @returns An array representing the vector.\n     */\n    vec(x, y, z, a) {\n        return [x, y, z, a].filter(v => v !== undefined);\n    }\n    /**\n     * Normalizes a vector (array).\n     * @param a - The vector to normalize.\n     * @returns The normalized vector.\n     */\n    normalize(a) {\n        const l = this.length(a);\n        return l !== 0 ? this.func(a, (v) => v / l) : a;\n    }\n    /**\n * Calculates the absolute value of the product of two numbers and multiplies it by a scaling factor (default 255).\n * @param a - The first number.\n * @param b - The second number.\n * @param c - The scaling factor (optional, defaults to 255).\n * @returns The scaled absolute product.\n */\n    scaledAbsProduct(a, b, c) {\n        return Math.abs(a * b) * (c || 255);\n    }\n    /**\n     * Calculates the absolute values of the components of a vector (array).\n     * @param a - The vector.\n     * @returns A new vector with the absolute values of the components.\n     */\n    abs(a) {\n        return a.map(v => Math.abs(v));\n    }\n    /**\n     * Applies a function to each component of a vector (array).\n     * @param a - The vector.\n     * @param exp - The function to apply.\n     * @returns A new vector with the function applied to each component.\n     */\n    func(a, exp) {\n        return a.map(exp);\n    }\n    /**\n     * Scales a value from one range to another.\n     * @param v - The value to scale.\n     * @param w - The width of the source range.\n     * @returns The scaled value.\n     */\n    toScale(v, w) {\n        return (v / w) * 2 - 1;\n    }\n    /**\n     * Calculates the dot product of two vectors (arrays).\n     * @param a - The first vector.\n     * @param b - The second vector.\n     * @returns The dot product.\n     */\n    dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    /**\n     * Calculates the length of a vector (array).\n     * @param a - The vector.\n     * @returns The length of the vector.\n     */\n    length(a) {\n        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    }\n    /**\n     * Fade function for Perlin noise.\n     * @param t - The input value.\n     * @returns The faded value.\n     */\n    fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    /**\n     * Clamps a value between a minimum and maximum value.\n     * @param n - The value to clamp.\n     * @param a - The minimum value.\n     * @param b - The maximum value.\n     * @returns The clamped value.\n     */\n    clamp(n, a, b) {\n        return Math.max(a, Math.min(n, b));\n    }\n    /**\n     * Linear interpolation between two values.\n     * @param t - The interpolation factor (between 0 and 1).\n     * @param a - The first value.\n     * @param b - The second value.\n     * @returns The interpolated value.\n     */\n    lerp(t, a, b) {\n        return a + t * (b - a);\n    }\n    /**\n     * Gradient function for Perlin noise.\n     * @param hash - The hash value.\n     * @param x - The x coordinate.\n     * @param y - The y coordinate.\n     * @param z - The z coordinate.\n     * @returns The gradient value.\n     */\n    grad(hash, x, y, z) {\n        const h = hash & 15;\n        const u = h < 8 ? x : y;\n        const v = h < 4 ? y : (h === 12 || h === 14) ? x : z;\n        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n    }\n    /**\n     * Scales a value from -1 to 1 to 0 to 1.\n     * @param n - The value to scale.\n     * @returns The scaled value.\n     */\n    scale(n) {\n        return (1 + n) / 2;\n    }\n    /**\n     * Generates a permutation table for Perlin noise.\n     * @param n - The size of the permutation table.\n     * @returns The permutation table as an array of numbers.\n     */\n    seed(n) {\n        const p = [];\n        const a = Array.from({ length: n }, (_, i) => i); // Use Array.from for better readability\n        for (let b = 0; b < n; b++) {\n            const c = Math.floor(n * Math.random());\n            [a[b], a[c]] = [a[c], a[b]]; // Use destructuring assignment for swapping\n        }\n        for (let i = 0; i < n; i++) {\n            p[n + i] = p[i] = a[i];\n        }\n        return p;\n    }\n    /**\n     * Calculates Perlin noise value at the given coordinates.\n     * @param x - The x coordinate.\n     * @param y - The y coordinate.\n     * @param z - The z coordinate.\n     * @returns The Perlin noise value.\n     */\n    noise(x, y, z) {\n        const p = this.perm;\n        const X = Math.floor(x) & 255;\n        const Y = Math.floor(y) & 255;\n        const Z = Math.floor(z) & 255;\n        x -= Math.floor(x);\n        y -= Math.floor(y);\n        z -= Math.floor(z);\n        const u = this.fade(x);\n        const v = this.fade(y);\n        const w = this.fade(z);\n        const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1]\n            + Z;\n        const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;\n        return this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(p[AA], x, y, z), this.grad(p[BA], x - 1, y, z)), this.lerp(u, this.grad(p[AB], x, y - 1, z), this.grad(p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(p[AA + 1], x, y, z - 1), this.grad(p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(p[AB + 1], x, y - 1, z - 1), this.grad(p[BB + 1], x - 1, y - 1, z - 1)))));\n    }\n}\nexports.TextureGeneratorBase = TextureGeneratorBase;\nclass TextureGenerator extends TextureGeneratorBase {\n    constructor(width, height) {\n        super();\n        this.width = width;\n        this.height = height;\n        this.frag = (pixel, x, y, w, h, v, fn) => {\n            let r = pixel[0];\n            var g = pixel[1];\n            var b = pixel[2];\n            let t = this.helpers;\n            var res = fn.apply(t, [[r, b, g], x, y, w, h, v]);\n            return res;\n        };\n        let c = document.createElement(\"canvas\");\n        c.width = width;\n        c.height = height;\n        this.ctx = c.getContext(\"2d\");\n        this.ctx.fillStyle = \"#0\";\n        this.ctx.fillRect(0, 0, this.width, this.height);\n        this.buffer = this.ctx.getImageData(0, 0, this.width, this.height);\n        this.helpers = new TextureGeneratorBase();\n    }\n    static createTexture(width, height, fn) {\n        let instance = new TextureGenerator(width, height);\n        instance.render(fn);\n        return instance; //.toBase64();\n    }\n    render(fn) {\n        let buffer = this.buffer;\n        let w = this.width, h = this.height;\n        let s = this.helpers.toScale;\n        for (var idx, x = 0; x < w; x++) {\n            for (var y = 0; y < h; y++) {\n                idx = (x + y * w) * 4;\n                var r = buffer.data[idx + 0];\n                var g = buffer.data[idx + 1];\n                var b = buffer.data[idx + 2];\n                let v = [s(x, w), s(y, w), 0];\n                var pixel = this.frag([r, g, b], x, y, w, h, v, fn);\n                buffer.data[idx + 0] = pixel[0];\n                buffer.data[idx + 1] = pixel[1];\n                buffer.data[idx + 2] = pixel[2];\n            }\n        }\n        this.ctx.putImageData(buffer, 0, 0);\n    }\n    toBase64() {\n        return this.ctx.canvas.toDataURL(\"image/png\");\n    }\n    toBlob(cb) {\n        this.ctx.canvas.toBlob(cb, \"image/png\");\n    }\n}\nexports.TextureGenerator = TextureGenerator;\nclass CanvasTextureGen extends TextureGenerator {\n    constructor(x, y, w, h) {\n        super(w, h);\n    }\n    D(fn) {\n        let res = fn.apply(this.helpers, [this.ctx, 0, 0, this.width, this, this.height]);\n        return res;\n    }\n    static createTexture(width, height, fn) {\n        let instance = new CanvasTextureGen(0, 0, width, height);\n        instance.D(fn);\n        return instance; //.toBase64();\n    }\n}\nexports.CanvasTextureGen = CanvasTextureGen;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/TextureHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/Scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst Canvas2DEntity_1 = __webpack_require__(/*! ./Entity/Canvas2DEntity */ \"./build/src/Engine/Entity/Canvas2DEntity.js\");\nclass Scene {\n    /**\n    * Adds a WGSL post-processing effect to the scene.\n    * @param sequence - The Sequence instance.\n    * @param device - GPUDevice\n    * @param wgslEntity - The WGSLShaderEntity to use for post-processing.\n    */\n    addWgslPostProcessor(sequence, device, wgslEntity) {\n        wgslEntity.bindToScene(this);\n        sequence.addWgslPostProcessor(this, device, (ctx, scene, device) => {\n            const targetTexture = device.createTexture({\n                size: { width: ctx.canvas.width, height: ctx.canvas.height },\n                format: 'rgba8unorm',\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\n                    | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING\n            });\n            // Copy the canvas contents to the texture\n            device.queue.copyExternalImageToTexture(// Access device and queue from sequence\n            { source: ctx.canvas }, { texture: targetTexture }, { width: ctx.canvas.width, height: ctx.canvas.height });\n            // Find the texture in the shader renderer and update its data\n            const textureData = wgslEntity.shaderRenderer.textures.find((texture) => texture.key === wgslEntity.props.textureKey);\n            if (textureData) {\n                textureData.data = targetTexture;\n            }\n            else {\n                console.warn(`Texture with key \"${wgslEntity.props.textureKey}\" not found in the shader renderer.`);\n            }\n            wgslEntity.shaderRenderer.update(sequence.currentTime / 1000);\n            wgslEntity.copyToCanvas(ctx.canvas, this.sequence);\n            return;\n        });\n    }\n    /**\n     * Creates a new Scene.\n     * @param name - The name or identifier for the scene.\n     * @param startTimeinMs - The start time of the scene in milliseconds.\n     * @param durationInMs - The duration of the scene in milliseconds.\n     */\n    constructor(name, startTimeinMs, durationInMs, width, height) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.width = width;\n        this.height = height;\n        this.entities = [];\n        this.transitionOutListeners = [];\n        this.transitionInListeners = [];\n    }\n    /**\n     * Adds an entity to the scene.\n     * @param entity - The entity to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntity(entity) {\n        // If the entity's canvas dimensions are not set, use the scene's dimensions\n        if (!entity.w && !entity.h) {\n            entity.canvas.width = this.width || 800;\n            entity.canvas.height = this.height || 450;\n        }\n        entity.bindToScene(this);\n        this.entities.push(entity);\n        return this;\n    }\n    /**\n     * Adds multiple entities to the scene.\n     * @param entities - An array of entities to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntities(...entities) {\n        entities.forEach(entity => this.addEntity(entity));\n        return this;\n    }\n    /**\n     * Gets an entity from the scene by its key.\n     * @param key - The key of the entity to retrieve.\n     * @returns The entity if found, otherwise undefined.\n     */\n    getEntity(key) {\n        return this.entities.find(entity => entity.name === key);\n    }\n    addPostProcessorToEntities(processor) {\n        this.entities.forEach(entity => {\n            if (entity instanceof Canvas2DEntity_1.Canvas2DEntity) { // Check if the entity is an instance of the Entity class\n                entity.addPostProcessor(processor);\n            }\n        });\n    }\n    /**\n      * Adds a transition-in effect to the scene.\n      * @param sequence - The Sequence instance associated with the scene.\n      * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n      * @param duration - The duration of the transition in milliseconds.\n      * @param listener - The transition function to apply.\n      */\n    transitionIn(sequence, startTime, duration, listener) {\n        this.transitionInListeners.push(listener);\n        sequence.addSceneTransitionIn(this, startTime, duration, (ctx, scene, progress) => {\n            this.transitionInListeners.forEach(listener => listener(ctx, scene, progress));\n        });\n    }\n    /**\n    * Adds a transition-out effect to the scene.\n    * @param sequence - The Sequence instance associated with the scene.\n    * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n    * @param duration - The duration of the transition in milliseconds.\n    * @param listener - The transition function to apply.\n    */\n    transitionOut(sequence, startTime, duration, listener) {\n        this.transitionOutListeners.push(listener);\n        sequence.addSceneTransitionOut(this, startTime, duration, (ctx, scene, progress) => {\n            this.transitionOutListeners.forEach(listener => listener(ctx, scene, progress));\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Scene.js?");

/***/ }),

/***/ "./build/src/Engine/Sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/Sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nclass Sequence {\n    /**\n   * Adds a WGSL post-processing effect to the sequence for a specific scene.\n   * @param scene - The scene to apply the effect to.\n   * @param processor - The WGSL post-processing function.\n   */\n    addWgslPostProcessor(scene, device, processor) {\n        this.wgslPostProcessors.push({ scene, processor, device: device });\n    }\n    /**\n  * Adds an event listener for when the frame rate drops below a threshold.\n  * @param listener - The function to call when the frame rate is low.\n  */\n    onLowFrameRate(listener) {\n        this.lowFrameRateListeners.push(listener);\n    }\n    /**\n* Sets the function to be used for resetting the rendering context when switching scenes.\n* @param resetFunction - The function to call to reset the context.\n*/\n    setContextResetFunction(resetFunction) {\n        this.resetContext = resetFunction;\n    }\n    /**\n     * Adds a transition-out listener for a specific scene.\n     * @param scene - The scene to add the listener to.\n     * @param startTime - The time (in milliseconds) relative to the end of the scene when the transition should start.\n     * @param listener - The transition function to apply.\n     */\n    addSceneTransitionOut(scene, startTime, duration, listener) {\n        this.sceneTransitionOutListeners.push({ scene, startTime, duration, listener });\n    }\n    /**\n     * Adds a transition-in listener for a specific scene.\n     * @param scene - The scene to add the listener to.\n     * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n     * @param listener - The transition function to apply.\n     */\n    addSceneTransitionIn(scene, startTime, duration, listener) {\n        this.sceneTransitionInListeners.push({ scene, startTime, duration, listener });\n    }\n    /**\n     * Adds a post-processing function to the sequence.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Gets the remaining time in the current scene.\n     * @param timeStamp - The current timestamp in the animation.\n     * @returns The remaining time in milliseconds.\n     */\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime);\n    }\n    /**\n   * Creates a new Sequence.\n   * @param target - The canvas element to render the animation on.\n   * @param bpm - The beats per minute for the animation.\n   * @param ticksPerBeat - The number of ticks per beat.\n   * @param beatsPerBar - The number of beats per bar.\n   * @param audioLoader - The IAudioLoader instance to load the audio.\n   * @param scenes - An optional array of scenes to include in the sequence.\n   * @param maxFps - The maximum frames per second (not yet implemented).\n   */\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, audioLoader, scenes, maxFps = 60 // not implemened at the moment\n    ) {\n        this.target = target;\n        this.maxFps = maxFps;\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.previousBeat = 0; // Store the previous beat value\n        this.previousTick = 0; // Store the previous tick value\n        this.previousBar = 0; // Store the previous bar value\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.frameListeners = [];\n        this.postProcessors = [];\n        this.wgslPostProcessors = [];\n        this.lowFrameRateListeners = [];\n        this.sceneTransitionInListeners = [];\n        this.sceneTransitionOutListeners = [];\n        this.resetContext = (ctx) => {\n            ctx.globalAlpha = 1; // Default reset function\n        };\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        this.audioContext = new AudioContext();\n        this.analyser = this.audioContext.createAnalyser();\n        this.audioLoader = audioLoader;\n    }\n    /**\n  * Asynchronously initializes the Sequence by loading the audio.\n  * @returns A Promise that resolves to the Sequence instance.\n  */\n    async initialize() {\n        await this.audioLoader.loadAudio(this.audioContext)\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n        return this;\n    }\n    /**\n     * Adds an event listener for each frame.\n     * @param listener - The function to call on each frame.\n     */\n    onFrame(listener) {\n        this.frameListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a beat occurs.\n     * @param listener - The function to call when a beat occurs.\n     */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    /**\n     * Adds a scene to the sequence.\n     * @param scene - The scene to add.\n     */\n    addScene(scene) {\n        if (!scene.width && scene.height) {\n            scene.width = this.target.width;\n            scene.height = this.target.height;\n        }\n        // pass the sequence to the Scene\n        scene.sequence = this;\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Adds multiple scenes to the sequence.\n     * @param scenes - The scenes to add.\n     * @returns The Sequence instance for chaining.\n     */\n    addScenes(...scenes) {\n        scenes.forEach(scene => {\n            this.scenes.push(scene);\n        });\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n    * Adds multiple scenes to the sequence.\n    * @param scenes - The scenes to add.\n    * @returns The Sequence instance for chaining.\n    */\n    addSceneArray(scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n     * Removes a scene from the sequence.\n     * @param scene - The scene to remove.\n     */\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Recalculates the total duration of the sequence.\n     */\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    /**\n     * Render a specific time\n     *\n     * @param {number} time\n     */\n    renderAtTime(time) {\n        var _a;\n        this.currentTime = time; // Update the currentTime\n        // Find the active scene for the given time\n        const currentSceneIndex = this.scenes.findIndex(scene => time >= scene.startTimeinMs && time < scene.startTimeinMs + scene.durationInMs);\n        if (currentSceneIndex !== -1) {\n            this.currentSceneIndex = currentSceneIndex;\n            const elapsedTime = time - this.currentScene.startTimeinMs;\n            // Update and draw entities\n            (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n            this.currentScene.entities.forEach(entity => {\n                entity.update(time);\n                if (this.target) {\n                    entity.copyToCanvas(this.target, this);\n                }\n            });\n            // Apply post-processing\n            if (this.targetCtx) {\n                this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n            }\n            this.triggerEventsForTime(time);\n        }\n    }\n    /**\n * Triggers beat, tick, and bar listeners for a given time.\n * @param time - The time in milliseconds.\n */\n    triggerEventsForTime(time) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        // Calculate beat, tick, and bar values for the given time\n        const beat = Math.floor(time / beatIntervalMs) + 1;\n        const tick = Math.floor((time % beatIntervalMs) / tickIntervalMs);\n        const bar = Math.floor(beat / this.beatsPerBar) + 1;\n        // Trigger listeners if the values have changed\n        if (beat !== this.currentBeat) {\n            this.currentBeat = beat;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, time, this.beatCounter));\n            this.beatCounter++;\n        }\n        if (tick !== this.currentTick) {\n            this.currentTick = tick;\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, time, this.tickCounter));\n            this.tickCounter++;\n        }\n        if (bar !== this.currentBar) {\n            this.currentBar = bar;\n            this.barListeners.forEach(listener => listener(this.currentBar));\n        }\n        // Trigger frame listeners\n        this.frameListeners.forEach(listener => listener(this.currentSceneIndex, time));\n    }\n    /**\n       * Starts the animation sequence.\n       * @param maxFps - The maximum frames per second.\n       */\n    play(maxFps) {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBeat = 0;\n        this.startTime = performance.now();\n        if (maxFps) {\n            this.maxFps = maxFps;\n        }\n        console.log(`Rendering at ${this.maxFps}`);\n        let then = performance.now();\n        const interval = 1000 / this.maxFps;\n        let frameCount = 0;\n        let lastFpsUpdateTime = 0;\n        const animate = (ts) => {\n            const now = performance.now();\n            const delta = now - then;\n            if (delta > interval) {\n                then = now - (delta % interval);\n                const adjustedTimeStamp = ts - this.startTime;\n                this.playCurrentScene(adjustedTimeStamp);\n                frameCount++;\n                if (now - lastFpsUpdateTime >= 1000) {\n                    const fps = frameCount / ((now - lastFpsUpdateTime) / 1000);\n                    frameCount = 0;\n                    lastFpsUpdateTime = now;\n                    if (fps < this.maxFps * 0.8) {\n                        this.lowFrameRateListeners.forEach(listener => listener(fps));\n                    }\n                }\n            }\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        // Start audio playback\n        if (this.audioBuffer) {\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    /**\n     * Pauses\n   the animation sequence.\n     */\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Stops the animation sequence.\n     */\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Gets the current scene being played.\n     * @returns The current Scene or undefined if no scene is active.\n     */\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    /**\n  * Animates the current scene and handles scene transitions,\n  * audio analysis, and beat/tick events.\n  * @param timeStamp - The adjusted timestamp for the current frame.\n  */\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        this.currentTime = timeStamp; // Update currentTime\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs && timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no current scene is found, check for upcoming scenes\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, end animation\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            // Reset the rendering context\n            this.resetContext(this.targetCtx);\n            // Set scene dimensions if not already set\n            if (!this.currentScene.width) {\n                this.currentScene.width = this.target.width;\n            }\n            if (!this.currentScene.height) {\n                this.currentScene.height = this.target.height;\n            }\n        }\n        // FFT analysis (if analyser is available)\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n        }\n        // Clear the target canvas and update/draw entities\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.sceneTransitionInListeners.forEach(({ scene, startTime, duration, listener }) => {\n            if (scene === this.currentScene) {\n                const sceneElapsedTime = this.currentTime - scene.startTimeinMs;\n                if (sceneElapsedTime >= startTime && sceneElapsedTime <= startTime + duration) {\n                    const transitionProgress = (sceneElapsedTime - startTime) / duration; // Calculate progress based on duration\n                    listener(this.targetCtx, scene, transitionProgress);\n                }\n            }\n        });\n        this.currentScene.entities.forEach(entity => {\n            var _a, _b;\n            // Update the conductor's time and trigger events\n            (_a = this.conductor) === null || _a === void 0 ? void 0 : _a.updateTime(timeStamp);\n            (_b = this.conductor) === null || _b === void 0 ? void 0 : _b.triggerEvents(this);\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target, this);\n            }\n            // Trigger entity events only when the values change\n            if (this.currentBeat !== this.previousBeat) {\n                entity.beatListeners.forEach((listener) => listener(timeStamp, this.beatCounter, entity.props));\n            }\n            if (this.currentTick !== this.previousTick) {\n                entity.tickListeners.forEach((listener) => listener(timeStamp, this.tickCounter, entity.props));\n            }\n            if (this.currentBar !== this.previousBar) {\n                entity.barListeners.forEach((listener) => listener(timeStamp, this.currentBar, entity.props));\n            }\n        });\n        // Update previous values for the sequence AFTER processing all entities\n        if (this.currentBeat !== this.previousBeat) {\n            this.previousBeat = this.currentBeat;\n        }\n        if (this.currentTick !== this.previousTick) {\n            this.previousTick = this.currentTick;\n        }\n        if (this.currentBar !== this.previousBar) {\n            this.previousBar = this.currentBar;\n        }\n        this.sceneTransitionOutListeners.forEach(({ scene, startTime, duration, listener }) => {\n            if (scene === this.currentScene) {\n                const sceneElapsedTime = this.currentTime - scene.startTimeinMs;\n                if (sceneElapsedTime >= startTime && sceneElapsedTime <= startTime + duration) {\n                    const transitionProgress = (sceneElapsedTime - startTime) / duration; // Calculate progress based on duration\n                    listener(this.targetCtx, scene, transitionProgress);\n                }\n            }\n        });\n        // Apply post-processing effects\n        if (this.targetCtx) {\n            this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n        }\n        // Apply WGSL post-processing effects\n        const wgslPostProcessor = this.wgslPostProcessors.find(p => p.scene === this.currentScene);\n        if (wgslPostProcessor) {\n            wgslPostProcessor.processor(this.targetCtx, this.currentScene, wgslPostProcessor.device);\n        }\n        else {\n            // ... (rest of the rendering logic) ...\n        }\n        this.handleBeatAndTickEvents(timeStamp); // Handle beat and tick events\n        // Trigger frame listeners\n        this.frameListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp));\n    }\n    /**\n     * Handles beat and tick events based on the current timestamp.\n     * @param timeStamp - The adjusted timestamp for the current frame.\n     */\n    handleBeatAndTickEvents(timeStamp) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1;\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Sequence.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGL/GlslShaderRenderer.js":
/*!**********************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGL/GlslShaderRenderer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GLSLShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\n/**\n * The `GLSLShaderRenderer` class is responsible for managing WebGL rendering,\n * including shader programs, textures, and render targets. It provides methods for\n * adding and updating buffers, rendering scenes, and managing resources.\n */\nclass GLSLShaderRenderer {\n    /**\n       * Sets the entity associated with this renderer.\n       * @param entity - The entity to associate with the renderer.\n       */\n    setEntity(entity) {\n        this.entity = entity;\n    }\n    /**\n* Creates a shader of the specified type and attaches it to the program.\n* @param program - The WebGLProgram to attach the shader to.\n* @param type - The type of shader (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER).\n* @param source - The shader source code.\n* @throws Error if the shader compilation fails.\n*/\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) {\n            gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l) => console.error(\"[shader] \" + l));\n            throw new Error(`Error while compiling vertex/fragment: ` + source);\n        }\n        ;\n    }\n    /**\n* Creates\na new WebGLProgram and adds it to the list of programs.\n* @param name - The name of the program.\n* @returns The created WebGLProgram.\n*/\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n* Creates a new WebGLTexture.\n* @param data - The image or Uint8Array data for the texture.\n* @param d - The texture unit index.\n* @returns The created WebGLTexture.\n*/\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n       * Creates a cube map texture.\n       * @param sources - An array of image sources for the cube map faces.\n       * @param d - The texture unit index.\n       * @returns The created WebGLTexture.\n       */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n* Adds assets (textures) to the renderer.\n* @param assets - An object containing texture data.\n* @param cb - A callback function to be called after the assets are loaded.\n* @returns The GLSLShaderRenderer instance for chaining.\n*/\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n* Adds a buffer (shader program) to the renderer.\n* @param name - The name of the buffer.\n* @param vertex - The vertex shader code.\n* @param fragment - The fragment shader code.\n* @param textures - An optional array of texture names.\n* @param customUniforms - An optional object containing custom uniform functions.\n* @returns The GLSLShaderRenderer instance for chaining.\n*/\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n* Sets the state of a shader program.\n* @param key - The name of the shader program.\n* @param state - Whether the program should be enabled or disabled.\n*/\n    setProgramState(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n* Updates the renderer and executes all shader programs.\n* @param time - The current time in seconds.\n*/\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time, this.entity);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n* Creates a render target.\n* @param width - The width of the render target.\n* @param height - The height of the render target.\n* @param textures - An array of texture names to use in the render target.\n* @param customUniforms - An object containing custom uniform functions.\n* @returns The created RenderTarget object.\n*/\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Starts the rendering loop with a fixed timestep.\n     * @param t - The initial time in milliseconds.\n     * @param fps - The desired frames per second.\n     * @returns The GLSLShaderRenderer instance for chaining.\n     */\n    run(t, fps) {\n        let previousTime = performance.now();\n        let interval = 1000 / fps;\n        let deltaTime = 0;\n        const animate = (currentTime) => {\n            requestAnimationFrame(animate);\n            deltaTime = currentTime - previousTime;\n            if (deltaTime > interval) {\n                previousTime = currentTime - (deltaTime % interval);\n                this.update(previousTime / 1000);\n            }\n        };\n        animate(t | 0);\n        return this;\n    }\n    /**\n* Creates a new GLSLShaderRenderer.\n* @param canvas - The canvas element to render to.\n* @param v - The vertex shader code.\n* @param f - The fragment shader code.\n* @param cU - Optional custom uniforms.\n*/\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     * Generate a GLSLShaderRenderer\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {string} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @return {*}  {HTMLCanvasElement}\n     * @memberof GLSLShaderRenderer\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new GLSLShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.GLSLShaderRenderer = GLSLShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGL/GlslShaderRenderer.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/DefaultMainShader.js":
/*!**********************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/DefaultMainShader.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultMainShader = void 0;\nexports.defaultMainShader = {\n    vertex: /* wgsl */ `\r\n    \r\n    struct VertexOutput {\r\n      @builtin(position) Position  : vec4<f32>,\r\n      @location(0) TexCoord  : vec2<f32>,\r\n  }\r\n  \r\n  @vertex\r\n  fn main_vertex(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n  \r\n      var positions = array<vec2<f32>, 6>(\r\n          vec2<f32>( 1.0,  1.0),\r\n          vec2<f32>( 1.0, -1.0),\r\n          vec2<f32>(-1.0, -1.0),\r\n          vec2<f32>( 1.0,  1.0),\r\n          vec2<f32>(-1.0, -1.0),\r\n          vec2<f32>(-1.0,  1.0)\r\n      );\r\n  \r\n      var texCoords = array<vec2<f32>, 6>(\r\n          vec2<f32>(1.0, 0.0),\r\n          vec2<f32>(1.0, 1.0),\r\n          vec2<f32>(0.0, 1.0),\r\n          vec2<f32>(1.0, 0.0),\r\n          vec2<f32>(0.0, 1.0),\r\n          vec2<f32>(0.0, 0.0)\r\n      );\r\n  \r\n      var output : VertexOutput;\r\n      output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n      output.TexCoord = texCoords[VertexIndex];\r\n      return output;\r\n  }\r\n    \r\n    `,\n    fragment: /* wgsl */ `\r\n    \r\n    struct Uniforms {\r\n      resolution: vec3<f32>,\r\n      time: f32\r\n    };  \r\n    @group(0) @binding(0) var screen_sampler : sampler;    \r\n    @group(0) @binding(1) var<uniform> uniforms: Uniforms;  \r\n    @group(0) @binding(2) var buffer1: texture_2d<f32>;   \r\n\r\n    struct VertexOutput {\r\n      @builtin(position) Position: vec4<f32>,\r\n      @location(0) TexCoord: vec2<f32>\r\n    };  \r\n  \r\n    @fragment\r\n    fn main_fragment(@location(0) TexCoord : vec2<f32>,@builtin(position) Position: vec4<f32> ) -> @location(0) vec4<f32> {\r\n      return  textureSample(buffer1, screen_sampler, -TexCoord);  \r\n  \r\n    }`,\n    // vertexEntryPoint:\"main_vertex\",\n    // fragmentEntryPoint:\"main_fragment\"\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/DefaultMainShader.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/Geometry.js":
/*!*************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/Geometry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rectGeometry = exports.Geometry = exports.DefaultIndicies = exports.VERTEXType = void 0;\nvar VERTEXType;\n(function (VERTEXType) {\n    VERTEXType[VERTEXType[\"xyz\"] = 3] = \"xyz\";\n    VERTEXType[VERTEXType[\"xyzw\"] = 4] = \"xyzw\";\n    VERTEXType[VERTEXType[\"xyzrgba\"] = 7] = \"xyzrgba\";\n    VERTEXType[VERTEXType[\"xyzwrgba\"] = 8] = \"xyzwrgba\";\n})(VERTEXType || (exports.VERTEXType = VERTEXType = {}));\nexports.DefaultIndicies = new Uint16Array([0, 1, 2, 3, 4, 5]);\nclass Geometry {\n    /**\n     * Creates a new Geometry object.\n     * @param device - The GPUDevice to use for creating buffers.\n     * @param model - The geometry data, including vertices, indices, and vertex type.\n     */\n    constructor(device, model) {\n        this.device = device;\n        this.model = model;\n        this.vertexBuffer = this.createBuffer(model.vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, model.verticesType);\n        this.indexBuffer = this.createBuffer(model.indicies, GPUBufferUsage.INDEX, 3);\n        this.numOfVerticles = model.vertices.length / model.verticesType;\n    }\n    /**\n     * Creates a GPUBuffer with the given data and usage flags.\n     * @param arr - The data to store in the buffer.\n     * @param usage - The usage flags for the buffer.\n     * @param vertexSize - The size of each vertex in bytes.\n     * @returns The created GPUBuffer.\n     */\n    createBuffer(arr, usage, vertexSize) {\n        const desc = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        const buffer = this.device.createBuffer(desc);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    /**\n     * Creates a vertex buffer layout for the geometry.\n     * @param shaderLocation - The location of the vertex attribute in the shader.\n     * @returns The GPUVertexBufferLayout object.\n     */\n    vertexBufferLayout(shaderLocation) {\n        return {\n            attributes: [{\n                    shaderLocation: shaderLocation,\n                    offset: 0,\n                    format: 'float32x2' // This might need to be adjusted based on your shader\n                }],\n            arrayStride: 4 * this.model.verticesType,\n            stepMode: 'vertex'\n        };\n    }\n}\nexports.Geometry = Geometry;\n// Default rectangle geometry\nexports.rectGeometry = {\n    verticesType: VERTEXType.xyz,\n    vertices: new Float32Array([\n        -1, 1, 0,\n        -1, -1, 0,\n        1, -1, 0,\n        1, 1, 0,\n        -1, 1, 0,\n        1, -1, 0,\n    ]),\n    indicies: new Uint16Array([0, 1, 2, 3, 4, 5]),\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/Geometry.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/Material.js":
/*!*************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/Material.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Material = exports.defaultWglslVertex = void 0;\n/**\n * Default vertex shader code for rendering a rectangle.\n */\nexports.defaultWglslVertex = ` \r\n  struct VertexInput {\r\n    @location(0) pos: vec2<f32>,\r\n    @builtin(vertex_index) index : u32\r\n  };\r\n\r\n  struct VertexOutput {\r\n    @builtin(position) pos: vec4<f32>,\r\n    @location(0) uv: vec2<f32>,\r\n    @location(1) fragCoord: vec2<f32>\r\n  };\r\n\r\n  @vertex\r\n  fn main_vertex(input: VertexInput) -> VertexOutput {\r\n    var output: VertexOutput;\r\n    var pos: vec2<f32> = input.pos * 2.0 - 1.0;\r\n    output.pos = vec4<f32>(pos, 0.0, 1.0);\r\n    output.uv = pos;\r\n    output.fragCoord = vec2<f32>((pos.x + 1.0) / 2.0, (1.0 - pos.y) / 2.0); \r\n    return output;\r\n  }\r\n`;\n/**\n * Represents a material with vertex and fragment shaders.\n */\nclass Material {\n    /**\n     * Creates a new Material.\n     * @param device - The GPUDevice to use for creating shader modules.\n     * @param shader - The IMaterialShader object containing the shader code.\n     */\n    constructor(device, shader) {\n        this.device = device;\n        this.shader = shader;\n        this.vertexShaderModule = this.device.createShaderModule({\n            code: shader.vertex\n        });\n        this.fragmentShaderModule = this.device.createShaderModule({\n            code: shader.fragment\n        });\n    }\n}\nexports.Material = Material;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/Material.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/RenderPassBuilder.js":
/*!**********************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/RenderPassBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderPassBuilder = exports.RenderPass = exports.RENDERPASS = void 0;\nvar RENDERPASS;\n(function (RENDERPASS) {\n    RENDERPASS[RENDERPASS[\"COMPUTESHADER\"] = 0] = \"COMPUTESHADER\";\n    RENDERPASS[RENDERPASS[\"FRAGMENTSHADER\"] = 1] = \"FRAGMENTSHADER\";\n})(RENDERPASS || (exports.RENDERPASS = RENDERPASS = {}));\nclass RenderPass {\n    constructor(type, label, pipleline, uniforms, bindGroup, buffer, bufferView) {\n        this.type = type;\n        this.label = label;\n        this.pipleline = pipleline;\n        this.uniforms = uniforms;\n        this.bindGroup = bindGroup;\n        this.buffer = buffer;\n        this.bufferView = bufferView;\n    }\n}\nexports.RenderPass = RenderPass;\n/**\n * A builder class for creating render passes in WebGPU.\n */\nclass RenderPassBuilder {\n    /**\n  * Creates a new RenderPassBuilder.\n  * @param device - The GPUDevice to use for creating resources.\n  */\n    constructor(device) {\n        this.device = device;\n    }\n    /**\n   * Creates a bind group layout and entries for a render pipeline.\n   * @param uniformBuffer - The uniform buffer for the pipeline.\n   * @param sampler - An optional GPUSampler to use. If not provided, a default sampler is created.\n   * @returns An array of GPUBindGroupEntry objects.\n   */\n    getRenderPiplelineBindingGroupLayout(uniformBuffer, sampler) {\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const defaultSampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: sampler || defaultSampler\n        });\n        return bindingGroupEntrys;\n    }\n    /**\n  * Creates a render pipeline.\n  * @param material - The material to use for the pipeline.\n  * @param geometry - The geometry to use for the pipeline.\n  * @param textures - An array of textures to use in the pipeline.\n  * @param priorRenderPasses - An array of prior render passes to include as textures.\n  * @returns The created GPURenderPipeline.\n  */\n    createRenderPipeline(material, geometry, textures, priorRenderPasses) {\n        const bindGroupLayoutEntries = new Array();\n        // add uniforms\n        bindGroupLayoutEntries.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        // add sampler\n        bindGroupLayoutEntries.push({\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            sampler: {\n                type: \"filtering\"\n            }\n        });\n        let offset = bindGroupLayoutEntries.length;\n        // add prior render passes\n        priorRenderPasses.forEach((p, index) => {\n            bindGroupLayoutEntries.push({\n                binding: offset + index,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: {}\n            });\n        });\n        offset = bindGroupLayoutEntries.length;\n        if (textures.length > 0) {\n            for (let i = 0; i < textures.length; i++) { //  1-n texture bindings\n                if (textures[i].type === 0) {\n                    bindGroupLayoutEntries.push({\n                        binding: 2 + i,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        texture: {\n                            sampleType: \"float\"\n                        }\n                    });\n                }\n                else {\n                    bindGroupLayoutEntries.push({\n                        binding: 2 + i,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        externalTexture: {}\n                    });\n                }\n            }\n        }\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: bindGroupLayoutEntries\n        });\n        const pipeline = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: \"main_vertex\",\n                buffers: [geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: \"main_fragment\",\n                targets: [\n                    {\n                        format: 'bgra8unorm'\n                    }\n                ]\n            }\n        });\n        return pipeline;\n    }\n    /**\n     * Creates a compute pipeline.\n     * @param computeShader - The compute shader module.\n     * @param textures - An array of textures to use in the pipeline.\n     * @returns The created GPUComputePipeline.\n     */\n    createComputePipeline(computeShader, textures) {\n        const bindGroupLayoutEntries = new Array();\n        bindGroupLayoutEntries.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n                access: \"write-only\",\n                format: \"bgra8unorm\",\n                viewDimension: \"2d\"\n            },\n        }, {\n            binding: 1, visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        if (textures.length > 0) {\n            for (let i = 0; i < textures.length; i++) { //  1-n texture bindings\n                if (textures[i].type === 0) {\n                    bindGroupLayoutEntries.push({\n                        binding: 3 + i,\n                        visibility: window.GPUShaderStage.COMPUTE,\n                        texture: {\n                            sampleType: \"float\"\n                        }\n                    });\n                }\n                else {\n                    bindGroupLayoutEntries.push({\n                        binding: 3 + i,\n                        visibility: window.GPUShaderStage.COMPUTE,\n                        externalTexture: {}\n                    });\n                }\n            }\n        }\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: bindGroupLayoutEntries\n        });\n        const pipeline = this.device.createComputePipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            compute: {\n                module: computeShader,\n                entryPoint: 'main',\n            },\n        });\n        return pipeline;\n    }\n}\nexports.RenderPassBuilder = RenderPassBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/RenderPassBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/TextureLoader.js":
/*!******************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/TextureLoader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WGSLTextureLoader = exports.WGSLTextureType = void 0;\nvar WGSLTextureType;\n(function (WGSLTextureType) {\n    WGSLTextureType[WGSLTextureType[\"IMAGE\"] = 0] = \"IMAGE\";\n    WGSLTextureType[WGSLTextureType[\"VIDEO\"] = 1] = \"VIDEO\";\n    WGSLTextureType[WGSLTextureType[\"CANVAS\"] = 2] = \"CANVAS\";\n    WGSLTextureType[WGSLTextureType[\"MEDIASTREAM\"] = 3] = \"MEDIASTREAM\";\n})(WGSLTextureType || (exports.WGSLTextureType = WGSLTextureType = {}));\n/**\n * A helper class for loading and creating textures for WebGPU.\n */\nclass WGSLTextureLoader {\n    /**\n     * Loads an array of textures and returns an array of ITextureData.\n     * @param device - The GPUDevice to use for creating textures.\n     * @param textures - An array of ITexture objects.\n     * @returns A Promise that resolves to an array of ITextureData.\n     */\n    static async loadAll(device, ...textures) {\n        return Promise.all(textures.map(async (texture) => {\n            if (texture.type === 0) {\n                return {\n                    type: WGSLTextureType.IMAGE, data: await this.createImageTexture(device, texture), key: texture.key\n                };\n            }\n            else {\n                return { type: WGSLTextureType.VIDEO, data: await this.createVideoTexture(device, texture), key: texture.key };\n            }\n        }));\n    }\n    /**\n     * Creates a GPUTexture from an image.\n     * @param device - The GPUDevice to use for creating the texture.\n     * @param texture - The ITexture object containing the image source.\n     * @returns A Promise that resolves to the created GPUTexture.\n     */\n    static async createImageTexture(device, texture) {\n        const image = new Image();\n        image.src = texture.source;\n        await image.decode();\n        const imageBitmap = await createImageBitmap(image);\n        const textureSize = { width: image.width, height: image.height };\n        const gpuTexture = device.createTexture({\n            label: texture.key,\n            size: textureSize,\n            dimension: '2d',\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n        });\n        device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: gpuTexture, mipLevel: 0 }, textureSize);\n        return gpuTexture;\n    }\n    /**\n     * Creates a HTMLVideoElement for video textures.\n     * @param device - The GPUDevice.\n     * @param texture - The ITexture object containing the video source.\n     * @returns A Promise that resolves to the HTMLVideoElement.\n     */\n    static async createVideoTexture(device, texture) {\n        const video = document.createElement(\"video\");\n        video.loop = true;\n        video.autoplay = true;\n        video.muted = true;\n        if (texture.source instanceof MediaStream) {\n            video.srcObject = texture.source;\n        }\n        else {\n            video.src = texture.source;\n        }\n        await video.play();\n        return video;\n    }\n}\nexports.WGSLTextureLoader = WGSLTextureLoader;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/TextureLoader.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/Uniforms.js":
/*!*************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/Uniforms.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uniforms = void 0;\n/**\n * Manages uniform data for shaders in WebGPU.\n */\nclass Uniforms {\n    /**\n     * Initializes a Float32Array with default values for uniforms.\n     * @param w - The width of the canvas.\n     * @param h - The height of the canvas.\n     * @returns A new Float32Array with initialized values.\n     */\n    static initialize(w, h) {\n        return new Float32Array([w, h, 0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    /**\n     * Creates a new Uniforms instance.\n     * @param device - The GPUDevice to use for creating the uniform buffer.\n     * @param canvas - The HTMLCanvasElement to get dimensions from.\n     */\n    constructor(device, canvas) {\n        this.device = device;\n        this.uniformBuffer = this.device.createBuffer({\n            size: 60,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        this.uniformBufferArray = Uniforms.initialize(canvas.width, canvas.height); // Use the initialize method\n    }\n    /**\n     * Sets uniform values in the uniform buffer array.\n     * @param values - An array of values to set.\n     * @param offset - The offset in the array where the values should be written.\n     */\n    setUniforms(values, offset) {\n        this.uniformBufferArray.set(values, offset);\n    }\n    /**\n     * Updates the uniform buffer on the GPU with the data from the uniform buffer array.\n     */\n    updateUniformBuffer() {\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformBufferArray.buffer, this.uniformBufferArray.byteOffset, this.uniformBufferArray.byteLength);\n    }\n}\nexports.Uniforms = Uniforms;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/Uniforms.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderers/WebGPU/WgslShaderRenderer.js":
/*!***********************************************************************!*\
  !*** ./build/src/Engine/ShaderRenderers/WebGPU/WgslShaderRenderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WGSLShaderRenderer = exports.initWebGPU = void 0;\nconst Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./build/src/Engine/ShaderRenderers/WebGPU/Geometry.js\");\nconst Material_1 = __webpack_require__(/*! ./Material */ \"./build/src/Engine/ShaderRenderers/WebGPU/Material.js\");\nconst RenderPassBuilder_1 = __webpack_require__(/*! ./RenderPassBuilder */ \"./build/src/Engine/ShaderRenderers/WebGPU/RenderPassBuilder.js\");\nconst Uniforms_1 = __webpack_require__(/*! ./Uniforms */ \"./build/src/Engine/ShaderRenderers/WebGPU/Uniforms.js\");\nconst initWebGPU = async (canvas, options) => {\n    var _a;\n    const adapter = await ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter(options));\n    const hasBGRA8unormStorage = adapter.features.has('bgra8unorm-storage');\n    const device = await (adapter === null || adapter === void 0 ? void 0 : adapter.requestDevice({\n        requiredFeatures: hasBGRA8unormStorage\n            ? ['bgra8unorm-storage']\n            : [],\n    }));\n    if (!device)\n        throw \"need a browser that supports WebGPU\";\n    const context = canvas.getContext(\"webgpu\");\n    context === null || context === void 0 ? void 0 : context.configure({\n        device,\n        format: hasBGRA8unormStorage\n            ? navigator.gpu.getPreferredCanvasFormat()\n            : 'rgba8unorm',\n        usage: GPUTextureUsage.TEXTURE_BINDING |\n            GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return { device, context };\n};\nexports.initWebGPU = initWebGPU;\n/**\n * The Renderer class is responsible for managing the WebGPU rendering context,\n * creating and executing render passes, and handling resources like buffers and textures.\n */\nclass WGSLShaderRenderer {\n    constructor(canvas, device, context, geometry) {\n        this.canvas = canvas;\n        this.device = device;\n        this.context = context;\n        this.frameCount = 0;\n        this.frame = 0;\n        this.renderPassBacklog = new Map();\n        this.textures = new Array();\n        this.renderPassBuilder = new RenderPassBuilder_1.RenderPassBuilder(device);\n        this.geometry = new Geometry_1.Geometry(device, geometry || Geometry_1.rectGeometry);\n        this.uniforms = new Uniforms_1.Uniforms(this.device, this.canvas);\n    }\n    /**\n  * Gets the WebGPU device.\n  * @returns The GPUDevice.\n  * @throws Error if the device is not initialized.\n  */\n    getDevice() {\n        if (!this.device)\n            throw \"Cannot get the GPUDevice\";\n        return this.device;\n    }\n    /**\n   * Creates a render pipeline for a given material.\n   * @param uniformBuffer - The uniform buffer for the pipeline.\n   * @param material - The material to use for the pipeline.\n   * @returns The created GPURenderPipeline.\n   */\n    creatRenderPipeline(uniformBuffer, material) {\n        const bindingGroupEntrys = [];\n        const sampler = this.getDevice().createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: sampler\n        }, {\n            binding: 1,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const layout = new Array();\n        layout.push({\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            sampler: {}\n        }, {\n            binding: 1,\n            visibility: GPUShaderStage.FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        const pipleline_group_layout = this.getDevice().createBindGroupLayout({\n            entries: layout\n        });\n        const pipeline_layout = this.getDevice().createPipelineLayout({\n            bindGroupLayouts: [pipleline_group_layout]\n        });\n        const pipelineDescriptor = {\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [this.geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{\n                        format: 'bgra8unorm'\n                    }]\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            layout: pipeline_layout\n        };\n        return this.getDevice().createRenderPipeline(pipelineDescriptor);\n    }\n    /**\n   * Creates a main render pipeline for a given material.\n   * This pipeline combines the output of other render passes.\n   * @param uniformBuffer - The uniform buffer for the pipeline.\n   * @param material - The material to use for the pipeline.\n   * @returns The created GPURenderPipeline.\n   */\n    createMainRenderPipeline(uniformBuffer, material) {\n        const bindingGroupEntries = [];\n        // Create a default sampler\n        const sampler = this.getDevice().createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        // Bind the sampler and uniform buffer\n        bindingGroupEntries.push({ binding: 0, resource: sampler }, { binding: 1, resource: { buffer: uniformBuffer } });\n        const layout = new Array();\n        // Define the layout entries for the sampler and uniform buffer\n        layout.push({\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            sampler: {}\n        }, {\n            binding: 1,\n            visibility: GPUShaderStage.FRAGMENT,\n            buffer: { type: \"uniform\" }\n        });\n        // Include the output textures from other render passes in the bind group\n        const renderPasses = Array.from(this.renderPassBacklog.values());\n        renderPasses.forEach((pass, index) => {\n            bindingGroupEntries.push({\n                binding: 2 + index,\n                resource: pass.bufferView\n            });\n            layout.push({\n                binding: 2 + index,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: {}\n            });\n        });\n        // Create the bind group layout and pipeline layout\n        const screenBindGroupLayout = this.getDevice().createBindGroupLayout({ entries: layout });\n        this.screenBindGroup = this.getDevice().createBindGroup({\n            layout: screenBindGroupLayout,\n            entries: bindingGroupEntries\n        });\n        const screenPipelineLayout = this.device.createPipelineLayout({ bindGroupLayouts: [screenBindGroupLayout] });\n        // Create the render pipeline\n        return this.device.createRenderPipeline({\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [this.geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{ format: 'bgra8unorm' }]\n            },\n            primitive: { topology: 'triangle-list' },\n            layout: screenPipelineLayout\n        });\n    }\n    /**\n     * Creates a render target texture.\n     * @param width - The width of the render target.\n     * @param height - The height of the render target.\n     * @returns An object containing the texture and texture view for the render target.\n     */\n    createRenderTarget(width, height) {\n        const buffer = this.getDevice().createTexture({\n            size: {\n                width: width,\n                height: height,\n            },\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        return { buffer, bufferView: buffer.createView() };\n    }\n    /**\n     * Creates a buffer on the GPU.\n     * @param arr - The data to store in the buffer.\n     * @param usage - The usage flags for the buffer.\n     * @param vertexSize - The size of each vertex in bytes.\n     * @returns The created GPUBuffer.\n     */\n    createBuffer(arr, usage, vertexSize) {\n        let bufferDescriptor = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        let buffer = this.getDevice().createBuffer(bufferDescriptor);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    /**\n   * Adds a main render pass to the backlog.\n   * @param shader - The material to use for the render pass.\n   */\n    addMainRenderPass(shader) {\n        const material = new Material_1.Material(this.device, shader);\n        this.renderPipleline = this.createMainRenderPipeline(this.uniforms.uniformBuffer, material);\n    }\n    /**\n     * Adds a render pass to the backlog.\n     * @param label - The label for the render pass.\n     * @param material - The material to use for the render pass.\n     * @param geometry - The geometry to use for the render pass.\n     * @param textures - An optional array of textures to use in the render pass.\n     * @returns The created RenderPass object.\n     */\n    addRenderPass(label, material, geometry, textures = []) {\n        this.textures.push(...textures); // Add textures to the renderer's textures array\n        const priorRenderPasses = Array.from(this.renderPassBacklog.values());\n        const renderPipeline = this.renderPassBuilder.createRenderPipeline(material, geometry, this.textures, priorRenderPasses);\n        const renderTarget = this.createRenderTarget(this.canvas.width, this.canvas.height);\n        // Create bind group entries for the uniform buffer, sampler, and textures\n        const bindingGroupEntries = [\n            { binding: 0, resource: { buffer: this.uniforms.uniformBuffer } },\n            { binding: 1, resource: this.getDevice().createSampler() }\n        ];\n        let bindingIndex = bindingGroupEntries.length;\n        // Add textures from previous render passes to the bind group\n        priorRenderPasses.forEach((pass, i) => {\n            bindingGroupEntries.push({\n                binding: bindingIndex++,\n                resource: pass.bufferView\n            });\n        });\n        // Add textures to the bind group\n        this.textures.forEach((texture, i) => {\n            const entry = texture.type === 0\n                ? { binding: bindingIndex++, resource: texture.data.createView() }\n                : { binding: bindingIndex++, resource: this.getDevice().importExternalTexture({ source: texture.data }) };\n            bindingGroupEntries.push(entry);\n        });\n        // Create the bind group\n        const bindGroup = this.getDevice().createBindGroup({\n            layout: renderPipeline.getBindGroupLayout(0),\n            entries: bindingGroupEntries,\n            label: `${label} renderpass`\n        });\n        // Create and return the render pass\n        const renderPass = new RenderPassBuilder_1.RenderPass(RenderPassBuilder_1.RENDERPASS.FRAGMENTSHADER, label, renderPipeline, this.uniforms, bindGroup, renderTarget.buffer, renderTarget.bufferView);\n        this.renderPassBacklog.set(label, renderPass);\n        return renderPass;\n    }\n    /**\n     * Adds a compute pass to the backlog.\n     * @param label - The label for the compute pass.\n     * @param computeShaderCode - The WGSL code for the compute shader.\n     * @param textures - An optional array of textures to use in the compute pass.\n     * @returns The created RenderPass object.\n     */\n    async addComputeRenderPass(label, computeShaderCode, textures = []) {\n        this.textures.push(...textures); // Add textures to the renderer's textures array\n        const computeShaderModule = this.getDevice().createShaderModule({ code: computeShaderCode });\n        const computePipeline = this.renderPassBuilder.createComputePipeline(computeShaderModule, this.textures);\n        const renderTarget = this.createRenderTarget(this.canvas.width, this.canvas.height);\n        // Create bind group entries for the render target, uniform buffer, sampler, and textures\n        const bindingGroupEntries = [\n            { binding: 0, resource: renderTarget.bufferView },\n            { binding: 1, resource: { buffer: this.uniforms.uniformBuffer } },\n            { binding: 2, resource: this.getDevice().createSampler() }\n        ];\n        let bindingIndex = bindingGroupEntries.length;\n        // Add textures to the bind group\n        this.textures.forEach((texture, i) => {\n            const entry = texture.type === 0\n                ? { binding: bindingIndex++, resource: texture.data.createView() }\n                : { binding: bindingIndex++, resource: this.getDevice().importExternalTexture({ source: texture.data }) };\n            bindingGroupEntries.push(entry);\n        });\n        // Create the bind group\n        const bindGroup = this.getDevice().createBindGroup({\n            layout: computePipeline.getBindGroupLayout(0),\n            entries: bindingGroupEntries,\n            label: `${label} computepass`\n        });\n        // Create and return the render pass\n        const renderPass = new RenderPassBuilder_1.RenderPass(RenderPassBuilder_1.RENDERPASS.COMPUTESHADER, label, computePipeline, this.uniforms, bindGroup, renderTarget.buffer, renderTarget.bufferView);\n        this.renderPassBacklog.set(label, renderPass);\n        return renderPass;\n    }\n    /**\n      * Updates the renderer and executes all render passes in the backlog.\n      * @param time - The current time in seconds.\n      */\n    update(time) {\n        const encoder = this.getDevice().createCommandEncoder();\n        const arrRenderPasses = Array.from(this.renderPassBacklog.values());\n        // get the compute shaders from the back log\n        arrRenderPasses.filter((pre) => {\n            return pre.type == RenderPassBuilder_1.RENDERPASS.COMPUTESHADER;\n        }).forEach(pass => {\n            const computePass = encoder.beginComputePass();\n            computePass.setPipeline(pass.pipleline);\n            computePass.setBindGroup(0, pass.bindGroup);\n            computePass.dispatchWorkgroups(Math.floor((this.canvas.width + 7) / 8), Math.floor((this.canvas.height + 7) / 8), 1);\n            computePass.end();\n        });\n        arrRenderPasses.filter(pre => {\n            return pre.type == RenderPassBuilder_1.RENDERPASS.FRAGMENTSHADER;\n        }).forEach(pass => {\n            const renderPassDescriptor = {\n                colorAttachments: [{\n                        loadOp: 'clear',\n                        storeOp: 'store',\n                        view: pass.bufferView,\n                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                    }]\n            };\n            const renderPass = encoder.beginRenderPass(renderPassDescriptor);\n            renderPass.setPipeline(pass.pipleline);\n            renderPass.setBindGroup(0, pass.bindGroup);\n            renderPass.setVertexBuffer(0, this.geometry.vertexBuffer);\n            renderPass.setIndexBuffer(this.geometry.indexBuffer, 'uint16');\n            renderPass.drawIndexed(this.geometry.numOfVerticles, 1);\n            renderPass.end();\n        });\n        const mainRenderer = encoder.beginRenderPass({\n            colorAttachments: [{\n                    view: this.context.getCurrentTexture().createView(),\n                    clearValue: { r: 0.0, g: 0, b: 0.0, a: 1 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\"\n                }]\n        });\n        this.uniforms.setUniforms([this.frame], 8);\n        this.uniforms.setUniforms([time], 3);\n        this.uniforms.updateUniformBuffer();\n        mainRenderer.setPipeline(this.renderPipleline);\n        mainRenderer.setVertexBuffer(0, this.geometry.vertexBuffer);\n        mainRenderer.setBindGroup(0, this.screenBindGroup);\n        mainRenderer.draw(6, 1, 0, 0);\n        mainRenderer.end();\n        this.getDevice().queue.submit([encoder.finish()]);\n    }\n    /**\n   * Starts the rendering loop.\n   * @param t - The initial time.\n   * @param maxFps - The maximum frames per second.\n   * @param onFrame - An optional callback function to be called on each frame.\n   */\n    start(t, maxFps = 200, onFrame) {\n        let startTime = null;\n        let frame = -1;\n        const renderLoop = (ts) => {\n            if (!startTime)\n                startTime = ts;\n            let segment = Math.floor((ts - startTime) / (1000 / maxFps));\n            if (segment > frame) {\n                frame = segment;\n                this.frame = segment;\n                this.frameCount = frame;\n                if (!this.isPaused) {\n                    this.update(ts / 1000);\n                    if (onFrame)\n                        onFrame(frame);\n                }\n            }\n            requestAnimationFrame(renderLoop);\n        };\n        renderLoop(t);\n    }\n    pause() {\n        this.isPaused = !this.isPaused;\n    }\n    clear() {\n        this.renderPassBacklog.clear();\n    }\n}\nexports.WGSLShaderRenderer = WGSLShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderers/WebGPU/WgslShaderRenderer.js?");

/***/ }),

/***/ "./build/src/index.js":
/*!****************************!*\
  !*** ./build/src/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorldEntity = exports.TextureGeneratorBase = exports.TextureGenerator = exports.CanvasTextureGen = exports.MathHelper = exports.Point3D = exports.Point2D = exports.InputHelper = exports.CompositeEntity = exports.SonantAudioLoader = exports.DefaultAudioLoader = exports.SequenceHelper = exports.SceneBuilder = exports.createInvertPostProcessor = exports.createGrayscalePostProcessor = exports.createBlurPostProcessor = exports.createFadeOutTransition = exports.createFadeInTransition = exports.EntityRenderer = exports.EntityBuilder = exports.DebugHelper = exports.AssetsHelper = exports.Uniforms = exports.WGSLTextureType = exports.WGSLTextureLoader = exports.RenderPassBuilder = exports.Material = exports.defaultWglslVertex = exports.VERTEXType = exports.rectGeometry = exports.Geometry = exports.DefaultIndicies = exports.defaultMainShader = exports.WGSLShaderRenderer = exports.initWebGPU = exports.RenderTarget = exports.GLSLShaderRenderer = exports.Sequence = exports.Scene = exports.GLSLShaderEntity = exports.Canvas2DEntity = exports.EngineLogger = exports.Conductor = exports.WGSLShaderEntity = void 0;\nvar WGSLShaderEntity_1 = __webpack_require__(/*! ./Engine/Entity/WGSLShaderEntity */ \"./build/src/Engine/Entity/WGSLShaderEntity.js\");\nObject.defineProperty(exports, \"WGSLShaderEntity\", ({ enumerable: true, get: function () { return WGSLShaderEntity_1.WGSLShaderEntity; } }));\nvar Conductor_1 = __webpack_require__(/*! ./Engine/Conductor */ \"./build/src/Engine/Conductor.js\");\nObject.defineProperty(exports, \"Conductor\", ({ enumerable: true, get: function () { return Conductor_1.Conductor; } }));\nvar EngineLogger_1 = __webpack_require__(/*! ./Engine/EngineLogger */ \"./build/src/Engine/EngineLogger.js\");\nObject.defineProperty(exports, \"EngineLogger\", ({ enumerable: true, get: function () { return EngineLogger_1.EngineLogger; } }));\nvar Canvas2DEntity_1 = __webpack_require__(/*! ./Engine/Entity/Canvas2DEntity */ \"./build/src/Engine/Entity/Canvas2DEntity.js\");\nObject.defineProperty(exports, \"Canvas2DEntity\", ({ enumerable: true, get: function () { return Canvas2DEntity_1.Canvas2DEntity; } }));\nvar GLSLShaderEntity_1 = __webpack_require__(/*! ./Engine/Entity/GLSLShaderEntity */ \"./build/src/Engine/Entity/GLSLShaderEntity.js\");\nObject.defineProperty(exports, \"GLSLShaderEntity\", ({ enumerable: true, get: function () { return GLSLShaderEntity_1.GLSLShaderEntity; } }));\nvar Scene_1 = __webpack_require__(/*! ./Engine/Scene */ \"./build/src/Engine/Scene.js\");\nObject.defineProperty(exports, \"Scene\", ({ enumerable: true, get: function () { return Scene_1.Scene; } }));\nvar Sequence_1 = __webpack_require__(/*! ./Engine/Sequence */ \"./build/src/Engine/Sequence.js\");\nObject.defineProperty(exports, \"Sequence\", ({ enumerable: true, get: function () { return Sequence_1.Sequence; } }));\nvar GlslShaderRenderer_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGL/GlslShaderRenderer */ \"./build/src/Engine/ShaderRenderers/WebGL/GlslShaderRenderer.js\");\nObject.defineProperty(exports, \"GLSLShaderRenderer\", ({ enumerable: true, get: function () { return GlslShaderRenderer_1.GLSLShaderRenderer; } }));\nObject.defineProperty(exports, \"RenderTarget\", ({ enumerable: true, get: function () { return GlslShaderRenderer_1.RenderTarget; } }));\nvar WgslShaderRenderer_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/WgslShaderRenderer */ \"./build/src/Engine/ShaderRenderers/WebGPU/WgslShaderRenderer.js\");\nObject.defineProperty(exports, \"initWebGPU\", ({ enumerable: true, get: function () { return WgslShaderRenderer_1.initWebGPU; } }));\nObject.defineProperty(exports, \"WGSLShaderRenderer\", ({ enumerable: true, get: function () { return WgslShaderRenderer_1.WGSLShaderRenderer; } }));\nvar DefaultMainShader_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/DefaultMainShader */ \"./build/src/Engine/ShaderRenderers/WebGPU/DefaultMainShader.js\");\nObject.defineProperty(exports, \"defaultMainShader\", ({ enumerable: true, get: function () { return DefaultMainShader_1.defaultMainShader; } }));\nvar Geometry_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/Geometry */ \"./build/src/Engine/ShaderRenderers/WebGPU/Geometry.js\");\nObject.defineProperty(exports, \"DefaultIndicies\", ({ enumerable: true, get: function () { return Geometry_1.DefaultIndicies; } }));\nObject.defineProperty(exports, \"Geometry\", ({ enumerable: true, get: function () { return Geometry_1.Geometry; } }));\nObject.defineProperty(exports, \"rectGeometry\", ({ enumerable: true, get: function () { return Geometry_1.rectGeometry; } }));\nObject.defineProperty(exports, \"VERTEXType\", ({ enumerable: true, get: function () { return Geometry_1.VERTEXType; } }));\nvar Material_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/Material */ \"./build/src/Engine/ShaderRenderers/WebGPU/Material.js\");\nObject.defineProperty(exports, \"defaultWglslVertex\", ({ enumerable: true, get: function () { return Material_1.defaultWglslVertex; } }));\nObject.defineProperty(exports, \"Material\", ({ enumerable: true, get: function () { return Material_1.Material; } }));\nvar RenderPassBuilder_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/RenderPassBuilder */ \"./build/src/Engine/ShaderRenderers/WebGPU/RenderPassBuilder.js\");\nObject.defineProperty(exports, \"RenderPassBuilder\", ({ enumerable: true, get: function () { return RenderPassBuilder_1.RenderPassBuilder; } }));\nvar TextureLoader_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/TextureLoader */ \"./build/src/Engine/ShaderRenderers/WebGPU/TextureLoader.js\");\nObject.defineProperty(exports, \"WGSLTextureLoader\", ({ enumerable: true, get: function () { return TextureLoader_1.WGSLTextureLoader; } }));\nObject.defineProperty(exports, \"WGSLTextureType\", ({ enumerable: true, get: function () { return TextureLoader_1.WGSLTextureType; } }));\nvar Uniforms_1 = __webpack_require__(/*! ./Engine/ShaderRenderers/WebGPU/Uniforms */ \"./build/src/Engine/ShaderRenderers/WebGPU/Uniforms.js\");\nObject.defineProperty(exports, \"Uniforms\", ({ enumerable: true, get: function () { return Uniforms_1.Uniforms; } }));\nvar AssetsHelper_1 = __webpack_require__(/*! ./Engine/Helpers/AssetsHelper */ \"./build/src/Engine/Helpers/AssetsHelper.js\");\nObject.defineProperty(exports, \"AssetsHelper\", ({ enumerable: true, get: function () { return AssetsHelper_1.AssetsHelper; } }));\nvar DebugHelper_1 = __webpack_require__(/*! ./Engine/Helpers/DebugHelper */ \"./build/src/Engine/Helpers/DebugHelper.js\");\nObject.defineProperty(exports, \"DebugHelper\", ({ enumerable: true, get: function () { return DebugHelper_1.DebugHelper; } }));\nvar EntityBuilder_1 = __webpack_require__(/*! ./Engine/Helpers/EntityBuilder */ \"./build/src/Engine/Helpers/EntityBuilder.js\");\nObject.defineProperty(exports, \"EntityBuilder\", ({ enumerable: true, get: function () { return EntityBuilder_1.EntityBuilder; } }));\nObject.defineProperty(exports, \"EntityRenderer\", ({ enumerable: true, get: function () { return EntityBuilder_1.EntityRenderer; } }));\nvar EntityTransitions_1 = __webpack_require__(/*! ./Engine/Helpers/EntityTransitions */ \"./build/src/Engine/Helpers/EntityTransitions.js\");\nObject.defineProperty(exports, \"createFadeInTransition\", ({ enumerable: true, get: function () { return EntityTransitions_1.createFadeInTransition; } }));\nObject.defineProperty(exports, \"createFadeOutTransition\", ({ enumerable: true, get: function () { return EntityTransitions_1.createFadeOutTransition; } }));\nvar PostProcessors_1 = __webpack_require__(/*! ./Engine/Helpers/PostProcessors */ \"./build/src/Engine/Helpers/PostProcessors.js\");\nObject.defineProperty(exports, \"createBlurPostProcessor\", ({ enumerable: true, get: function () { return PostProcessors_1.createBlurPostProcessor; } }));\nObject.defineProperty(exports, \"createGrayscalePostProcessor\", ({ enumerable: true, get: function () { return PostProcessors_1.createGrayscalePostProcessor; } }));\nObject.defineProperty(exports, \"createInvertPostProcessor\", ({ enumerable: true, get: function () { return PostProcessors_1.createInvertPostProcessor; } }));\nvar SceneBuilder_1 = __webpack_require__(/*! ./Engine/Helpers/SceneBuilder */ \"./build/src/Engine/Helpers/SceneBuilder.js\");\nObject.defineProperty(exports, \"SceneBuilder\", ({ enumerable: true, get: function () { return SceneBuilder_1.SceneBuilder; } }));\nvar SequenceHelper_1 = __webpack_require__(/*! ./Engine/Helpers/SequenceHelper */ \"./build/src/Engine/Helpers/SequenceHelper.js\");\nObject.defineProperty(exports, \"SequenceHelper\", ({ enumerable: true, get: function () { return SequenceHelper_1.SequenceHelper; } }));\nvar AudioLoader_1 = __webpack_require__(/*! ./Engine/Audio/AudioLoader */ \"./build/src/Engine/Audio/AudioLoader.js\");\nObject.defineProperty(exports, \"DefaultAudioLoader\", ({ enumerable: true, get: function () { return AudioLoader_1.DefaultAudioLoader; } }));\nObject.defineProperty(exports, \"SonantAudioLoader\", ({ enumerable: true, get: function () { return AudioLoader_1.SonantAudioLoader; } }));\nvar CompositeEntity_1 = __webpack_require__(/*! ./Engine/Entity/CompositeEntity */ \"./build/src/Engine/Entity/CompositeEntity.js\");\nObject.defineProperty(exports, \"CompositeEntity\", ({ enumerable: true, get: function () { return CompositeEntity_1.CompositeEntity; } }));\nvar InputHelper_1 = __webpack_require__(/*! ./Engine/Helpers/InputHelper */ \"./build/src/Engine/Helpers/InputHelper.js\");\nObject.defineProperty(exports, \"InputHelper\", ({ enumerable: true, get: function () { return InputHelper_1.InputHelper; } }));\nvar Point2D_1 = __webpack_require__(/*! ./Engine/Helpers/Math/Point2D */ \"./build/src/Engine/Helpers/Math/Point2D.js\");\nObject.defineProperty(exports, \"Point2D\", ({ enumerable: true, get: function () { return Point2D_1.Point2D; } }));\nvar Point3D_1 = __webpack_require__(/*! ./Engine/Helpers/Math/Point3D */ \"./build/src/Engine/Helpers/Math/Point3D.js\");\nObject.defineProperty(exports, \"Point3D\", ({ enumerable: true, get: function () { return Point3D_1.Point3D; } }));\nvar MathHelper_1 = __webpack_require__(/*! ./Engine/Helpers/Math/MathHelper */ \"./build/src/Engine/Helpers/Math/MathHelper.js\");\nObject.defineProperty(exports, \"MathHelper\", ({ enumerable: true, get: function () { return MathHelper_1.MathHelper; } }));\nvar TextureHelper_1 = __webpack_require__(/*! ./Engine/Helpers/TextureHelper */ \"./build/src/Engine/Helpers/TextureHelper.js\");\nObject.defineProperty(exports, \"CanvasTextureGen\", ({ enumerable: true, get: function () { return TextureHelper_1.CanvasTextureGen; } }));\nObject.defineProperty(exports, \"TextureGenerator\", ({ enumerable: true, get: function () { return TextureHelper_1.TextureGenerator; } }));\nObject.defineProperty(exports, \"TextureGeneratorBase\", ({ enumerable: true, get: function () { return TextureHelper_1.TextureGeneratorBase; } }));\nvar WorldEntity_1 = __webpack_require__(/*! ./Engine/Entity/WorldEntity */ \"./build/src/Engine/Entity/WorldEntity.js\");\nObject.defineProperty(exports, \"WorldEntity\", ({ enumerable: true, get: function () { return WorldEntity_1.WorldEntity; } }));\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/index.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/worldBackgroundEffect.js":
/*!************************************************************!*\
  !*** ./build/wwwroot/src/effects/worldBackgroundEffect.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.worldBackgroundEffect = void 0;\nconst src_1 = __webpack_require__(/*! ../../../src */ \"./build/src/index.js\");\nconst worldBackgroundEffect = (ts, ctx, propertybag) => {\n    const { rectangles } = propertybag;\n    const { width, height } = ctx.canvas;\n    if (rectangles.length === 0) {\n        const gap = 100;\n        const minWidth = 50;\n        const maxWidth = 200;\n        const minHeight = 30;\n        const maxHeight = 80;\n        let currentX = 0;\n        while (currentX < width) {\n            const rectWidth = src_1.MathHelper.randomInt(minWidth, maxWidth);\n            const rectHeight = src_1.MathHelper.randomInt(minHeight, maxHeight);\n            const x = currentX + Math.random() * gap;\n            const y = Math.random() * (height - rectHeight);\n            const color = `hsl(${Math.random() * 360}, 100%, 50%)`;\n            rectangles.push({ x, y, width: rectWidth, height: rectHeight, color });\n            currentX += rectWidth + gap;\n        }\n    }\n    rectangles.forEach(rect => {\n        ctx.fillStyle = rect.color;\n        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n    });\n};\nexports.worldBackgroundEffect = worldBackgroundEffect;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/worldBackgroundEffect.js?");

/***/ }),

/***/ "./build/wwwroot/src/runWorld.js":
/*!***************************************!*\
  !*** ./build/wwwroot/src/runWorld.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunWorld = void 0;\nconst src_1 = __webpack_require__(/*! ../../src */ \"./build/src/index.js\");\nconst WorldEntity_1 = __webpack_require__(/*! ../../src/Engine/Entity/WorldEntity */ \"./build/src/Engine/Entity/WorldEntity.js\");\nconst CollisionHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/CollisionHelper */ \"./build/src/Engine/Helpers/CollisionHelper.js\");\nconst worldBackgroundEffect_1 = __webpack_require__(/*! ./effects/worldBackgroundEffect */ \"./build/wwwroot/src/effects/worldBackgroundEffect.js\");\n/**\n * A class to demonstrate the usage of the demolished-rail framework,\n * including GLSL shaders, Canvas2D rendering, transitions, and music synchronization.\n */\nclass RunWorld {\n    /**\n     * Creates a new RunWorld instance.\n     * @param target - The canvas element to render to.\n     */\n    constructor(target, bmp) {\n        this.bmp = bmp;\n        this.screenCanvas = target;\n    }\n    /**\n    * Sets up the Sequence and Scene for the demo.\n    * @returns A Promise that resolves to the created Sequence.\n    */\n    async setupSequence() {\n        const instance = new src_1.Sequence(this.screenCanvas, this.bmp, 4, 4, new src_1.DefaultAudioLoader(\"/wwwroot/assets/music/music.mp3\"));\n        const sequence = await instance.initialize();\n        const sb = new src_1.SceneBuilder(sequence.audioBuffer.duration * 1000);\n        // create a scene starting at 0ms , duration is as long as the audioBuffer \n        sb.durationUntilEndInMs(\"scene0\");\n        (sb.getScenes())[0].addEntities(...this.createWorld(sequence));\n        sequence.addScenes(...sb.getScenes());\n        this.sequence = sequence;\n        return sequence;\n    }\n    createWorld(sequence) {\n        const world = new WorldEntity_1.WorldEntity(\"our-world\", {\n            worldHeight: this.screenCanvas.height,\n            worldWidth: this.screenCanvas.width * 10, // make it 10 x the screen canvas\n            viewportWidth: this.screenCanvas.width,\n            viewportHeight: this.screenCanvas.height,\n            viewportX: 0,\n            blocks: []\n        });\n        // Set up the background entity to use in the World\n        const backgroundProps = {\n            rectangles: []\n        };\n        const worldBg = {\n            key: 'background',\n            update: function (timeStamp, ctx, entity) {\n                (0, worldBackgroundEffect_1.worldBackgroundEffect)(timeStamp, ctx, this.props);\n            },\n            props: backgroundProps\n        };\n        // Set up a second entity for the World\n        const ballBlock = {\n            key: \"ballBlock\",\n            props: {\n                x: 400,\n                y: 225,\n                radius: 20,\n                vx: 5,\n                vy: 3\n            },\n            update(timeStamp, ctx, entity) {\n                const { x, y, radius, vx, vy } = this.props;\n                // Update ball position for bouncing\n                this.props.x += vx;\n                this.props.y += vy;\n                if (this.props.x + radius > ctx.canvas.width || this.props.x - radius < 0) {\n                    this.props.vx = -vx;\n                    this.props.vy += (Math.random() - 0.5) * 2; // Add random vertical velocity\n                }\n                if (this.props.y + radius > ctx.canvas.height || this.props.y - radius < 0) {\n                    this.props.vy = -vy;\n                    this.props.vx += (Math.random() - 0.5) * 2; // Add random horizontal velocity\n                }\n                ctx.beginPath();\n                ctx.arc(x, y, radius, 0, 2 * Math.PI);\n                ctx.fillStyle = \"red\"; // Example color\n                ctx.fill();\n            }\n        };\n        // add a collision detector , of the ball is colliding with a rect \n        world.addCollisionDetector(\"ballBlock\", \"background\", (ball, background) => {\n            // Find the index of the colliding rectangle\n            const collidingIndex = background.rectangles.findIndex(rect => {\n                return CollisionHelper_1.CollisionHelper.rectangularDetection({ x: ball.x, y: ball.y, w: ball.radius * 2, h: ball.radius * 2 }, { x: rect.x, y: rect.y, w: rect.width, h: rect.height });\n            });\n            if (collidingIndex !== -1) {\n                // Store the colliding rectangle's index in the ball's props\n                ball.collidingRectIndex = collidingIndex;\n                return true; // Collision detected\n            }\n            return false; // No collision\n        }, (ball, background) => {\n            // Access the colliding rectangle's index from the ball's props , and remove it\n            const collidingIndex = ball.collidingRectIndex;\n            if (collidingIndex !== undefined) {\n                background.rectangles.splice(collidingIndex, 1);\n            }\n        });\n        // add entities to the world's \"building blocks\"\n        world.addBlocks(worldBg, ballBlock);\n        // just a test how we can sync viewports on frame?\n        sequence.onFrame((scene, time) => {\n            var _a;\n            const ballX = (_a = world.findBlock(\"ballBlock\")) === null || _a === void 0 ? void 0 : _a.props.x;\n            if (ballX !== undefined) {\n                // Center the viewport on the ball's x position\n                const viewportX = ballX - world.props.viewportWidth / 2;\n                world.setViewportX(viewportX);\n            }\n        });\n        return [world];\n    }\n}\nexports.RunWorld = RunWorld;\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    const canvas = document.querySelector(\"canvas#main-canvas\");\n    const runner = new RunWorld(canvas, 110);\n    const sequence = await runner.setupSequence();\n    sequence.onLowFrameRate((fps) => {\n        console.warn(`Low frame rate detected: ${fps.toFixed(2)} FPS`);\n    });\n    const btn = document.querySelector(\"BUTTON\");\n    btn.textContent = \"CLICK TO START!\";\n    btn.addEventListener(\"click\", () => {\n        var _a;\n        (_a = document.querySelector(\"#launch\")) === null || _a === void 0 ? void 0 : _a.remove();\n        sequence.play();\n    });\n});\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/runWorld.js?");

/***/ }),

/***/ "./node_modules/sonantx/dist/sonantx.bundle.js":
/*!*****************************************************!*\
  !*** ./node_modules/sonantx/dist/sonantx.bundle.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_539__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_539__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_539__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_539__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_539__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_539__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_539__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_539__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_539__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_539__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_539__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_539__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_539__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_539__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_539__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_539__(__nested_webpack_require_539__.s = \"./sonantx.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./sonantx.js\":\n/*!********************!*\\\n  !*** ./sonantx.js ***!\n  \\********************/\n/*! exports provided: generateSound, generateSong */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"generateSound\\\", function() { return generateSound; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"generateSong\\\", function() { return generateSong; });\\n// Oscillators\\nfunction osc_sin(value) {\\n  return Math.sin(value * Math.PI * 2);\\n}\\n\\nfunction osc_square(value) {\\n  if (osc_sin(value) < 0) {\\n    return -1;\\n  }\\n\\n  return 1;\\n}\\n\\nfunction osc_saw(value) {\\n  return value % 1 - 0.5;\\n}\\n\\nfunction osc_tri(value) {\\n  const v2 = value % 1 * 4;\\n\\n  if (v2 < 2) {\\n    return v2 - 1;\\n  }\\n\\n  return 3 - v2;\\n} // Array of oscillator functions\\n\\n\\nconst oscillators = [osc_sin, osc_square, osc_saw, osc_tri];\\n\\nfunction getnotefreq44100(n) {\\n  const val = 0.00390625 * Math.pow(1.059463094, n - 128);\\n  return val;\\n}\\n\\nfunction getnotefreq(audioCtx, n) {\\n  const x = getnotefreq44100(n);\\n  const val = x / audioCtx.sampleRate * 44100;\\n  return val;\\n}\\n\\nfunction effectiveRowLen(audioCtx, bpm) {\\n  return Math.round(60 * audioCtx.sampleRate / 4 / bpm);\\n}\\n\\nclass SoundWriter {\\n  constructor(audioCtx, instr, n, bpm) {\\n    this.audioCtx = audioCtx;\\n    this.instr = instr;\\n    this.n = n;\\n    this.bpm = bpm;\\n    this.c1 = 0;\\n    this.c2 = 0;\\n    this.low = 0;\\n    this.band = 0;\\n    this.j = 0;\\n  }\\n\\n  write(lchan, rchan, from) {\\n    const instr = this.instr;\\n    const n = this.n;\\n    let c = from;\\n    const osc_lfo = oscillators[instr.lfo_waveform];\\n    const osc1 = oscillators[instr.osc1_waveform];\\n    const osc2 = oscillators[instr.osc2_waveform];\\n    const panFreq = Math.pow(2, instr.fx_pan_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\\n    const lfoFreq = Math.pow(2, instr.lfo_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\\n    const attackTime = instr.env_attack / 44100;\\n    const releaseTime = instr.env_release / 44100;\\n    const sustainTime = instr.env_sustain / 44100;\\n    const env_attack = attackTime * this.audioCtx.sampleRate;\\n    const env_release = releaseTime * this.audioCtx.sampleRate;\\n    const env_sustain = sustainTime * this.audioCtx.sampleRate; // Precalculate frequencues\\n\\n    const o1t = getnotefreq(this.audioCtx, n + (instr.osc1_oct - 8) * 12 + instr.osc1_det) * (1 + 0.0008 * instr.osc1_detune);\\n    const o2t = getnotefreq(this.audioCtx, n + (instr.osc2_oct - 8) * 12 + instr.osc2_det) * (1 + 0.0008 * instr.osc2_detune); // State variable init\\n\\n    const q = instr.fx_resonance / 255;\\n\\n    while (this.j < env_attack + env_sustain + env_release && c < lchan.length) {\\n      // LFO\\n      const lfor = osc_lfo(this.j * lfoFreq) * instr.lfo_amt / 512 + 0.5; // Envelope\\n\\n      let e = 1;\\n\\n      if (this.j < env_attack) {\\n        e = this.j / env_attack;\\n      } else if (this.j >= env_attack + env_sustain) {\\n        e -= (this.j - env_attack - env_sustain) / env_release;\\n      } // Oscillator 1\\n\\n\\n      let t = o1t;\\n\\n      if (instr.lfo_osc1_freq) {\\n        t += lfor;\\n      }\\n\\n      if (instr.osc1_xenv) {\\n        t *= e * e;\\n      }\\n\\n      this.c1 += t;\\n      let rsample = osc1(this.c1) * instr.osc1_vol; // Oscillator 2\\n\\n      t = o2t;\\n\\n      if (instr.osc2_xenv) {\\n        t *= e * e;\\n      }\\n\\n      this.c2 += t;\\n      rsample += osc2(this.c2) * instr.osc2_vol; // Noise oscillator\\n\\n      if (instr.noise_fader) {\\n        rsample += (2 * Math.random() - 1) * instr.noise_fader * e;\\n      }\\n\\n      rsample *= e / 255; // State variable filter\\n\\n      let f = instr.fx_freq;\\n\\n      if (instr.lfo_fx_freq) {\\n        f *= lfor;\\n      }\\n\\n      f = 1.5 * Math.sin(f * Math.PI / this.audioCtx.sampleRate);\\n      this.low += f * this.band;\\n      const high = q * (rsample - this.band) - this.low;\\n      this.band += f * high;\\n\\n      switch (instr.fx_filter) {\\n        case 1:\\n          // Hipass\\n          rsample = high;\\n          break;\\n\\n        case 2:\\n          // Lopass\\n          rsample = this.low;\\n          break;\\n\\n        case 3:\\n          // Bandpass\\n          rsample = this.band;\\n          break;\\n\\n        case 4:\\n          // Notch\\n          rsample = this.low + high;\\n          break;\\n\\n        default:\\n      } // Panning & master volume\\n\\n\\n      t = osc_sin(this.j * panFreq) * instr.fx_pan_amt / 512 + 0.5;\\n      rsample *= 39 * instr.env_master;\\n      let x = 32768 + rsample * (1 - t);\\n      let x1 = x & 255;\\n      let x2 = x >> 8 & 255;\\n      let y = 4 * (x1 + (x2 << 8) - 32768);\\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\\n      lchan[c] = lchan[c] + y / 32768;\\n      x = 32768 + rsample * t;\\n      x1 = x & 255;\\n      x2 = x >> 8 & 255;\\n      y = 4 * (x1 + (x2 << 8) - 32768);\\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\\n      rchan[c] = rchan[c] + y / 32768;\\n      this.j++;\\n      c++;\\n    } // returns true if the sound finished\\n\\n\\n    if (c < lchan.length) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n}\\n\\nclass TrackGenerator {\\n  constructor(audioCtx, instr, bpm, endPattern) {\\n    bpm = bpm || 118;\\n    endPattern = endPattern || instr.p.length - 1;\\n    this.audioCtx = audioCtx;\\n    this.instr = instr;\\n    this.bpm = bpm;\\n    this.endPattern = endPattern;\\n    const source = this.audioCtx.createOscillator();\\n    const nullGain = this.audioCtx.createGain();\\n    nullGain.gain.value = 0;\\n    source.connect(nullGain);\\n    const scriptNode = this.audioCtx.createScriptProcessor(512, 2, 2);\\n    nullGain.connect(scriptNode);\\n    let currentSample = 0;\\n    let nextNote = 0;\\n    let sounds = [];\\n\\n    scriptNode.onaudioprocess = audioProcessingEvent => {\\n      const inputData = audioProcessingEvent.inputBuffer;\\n      const outputData = audioProcessingEvent.outputBuffer;\\n      const lchan = outputData.getChannelData(0);\\n      const rchan = outputData.getChannelData(1);\\n      lchan.set(inputData.getChannelData(0));\\n      rchan.set(inputData.getChannelData(1));\\n      sounds.slice().forEach(el => {\\n        const finished = el.write(lchan, rchan, 0);\\n\\n        if (finished) {\\n          sounds = sounds.filter(el2 => {\\n            return el2 !== el;\\n          });\\n        }\\n      });\\n      let nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\\n\\n      while (nextNoteSample >= currentSample && nextNoteSample < currentSample + inputData.length) {\\n        const pattern = instr.p[Math.floor(nextNote / 32) % (this.endPattern + 1)] || 0;\\n        const note = pattern === 0 ? 0 : (instr.c[pattern - 1] || {\\n          n: []\\n        }).n[nextNote % 32] || 0;\\n\\n        if (note !== 0) {\\n          const sw = new SoundWriter(this.audioCtx, instr, note, this.bpm);\\n          sw.write(lchan, rchan, nextNoteSample - currentSample);\\n          sounds.push(sw);\\n        }\\n\\n        nextNote += 1;\\n        nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\\n      }\\n\\n      currentSample += inputData.length;\\n    };\\n\\n    const delayTime = instr.fx_delay_time * (1 / (this.bpm / 60) / 8);\\n    const delayAmount = instr.fx_delay_amt / 255;\\n    const delayGain = this.audioCtx.createGain();\\n    delayGain.gain.value = delayAmount;\\n    scriptNode.connect(delayGain);\\n    const delay = this.audioCtx.createDelay();\\n    delay.delayTime.value = delayTime;\\n    delayGain.connect(delay);\\n    delay.connect(delayGain);\\n    const mixer = this.audioCtx.createGain();\\n    mixer.gain.value = 1;\\n    scriptNode.connect(mixer);\\n    delay.connect(mixer);\\n    this.chain = [source, nullGain, scriptNode, delayGain, delay, mixer];\\n  }\\n\\n  start(when) {\\n    this.chain[0].start(when);\\n  }\\n\\n  stop(when) {\\n    this.chain[0].stop(when);\\n    this.chain[this.chain.length - 1].disconnect();\\n  }\\n\\n  connect(target) {\\n    this.chain[this.chain.length - 1].connect(target);\\n  }\\n\\n}\\n\\nclass MusicGenerator {\\n  constructor(audioCtx, song) {\\n    this.audioCtx = audioCtx;\\n    this.song = song;\\n    const mixer = this.audioCtx.createGain();\\n    mixer.gain.value = 1;\\n    this.tracks = [];\\n    this.song.songData.forEach(el => {\\n      const track = new TrackGenerator(this.audioCtx, el, this.bpm, this.song.endPattern);\\n      track.connect(mixer);\\n      this.tracks.push(track);\\n    });\\n    this.chain = [this.tracks, mixer];\\n  }\\n\\n  get bpm() {\\n    // rowLen is a number of samples when using 44100hz\\n    return Math.round(60 * 44100 / 4 / this.song.rowLen);\\n  }\\n\\n  start(when) {\\n    when = when || this.audioCtx.currentTime;\\n    this.tracks.forEach(t => t.start(when));\\n  }\\n\\n  stop(when) {\\n    when = when || this.audioCtx.currentTime;\\n    this.tracks.forEach(t => t.stop(when));\\n    this.chain[this.chain.length - 1].disconnect();\\n  }\\n\\n  connect(target) {\\n    this.chain[this.chain.length - 1].connect(target);\\n  }\\n\\n}\\n/**\\n * Generates a single note from an instrument.\\n *\\n * @param {*} instr The instrument descriptor\\n * @param {*} n The note as a midi note\\n * @param {*} sampleRate The sample rate\\n * @param {*} bpm The bpm of the song\\n * @returns {AudioBuffer} The generated audio buffer\\n */\\n\\n\\nasync function generateSound(instr, n, sampleRate, bpm = 120) {\\n  const attackTime = instr.env_attack / 44100;\\n  const releaseTime = instr.env_release / 44100;\\n  const sustainTime = instr.env_sustain / 44100;\\n  const soundLenSeconds = attackTime + releaseTime + sustainTime + 8 * (1 / (bpm / 60));\\n  const nInstr = Object.assign({}, instr);\\n  nInstr.p = [1, 0, 0, 0];\\n  nInstr.c = [{\\n    n: new Array(32).map(() => 0)\\n  }];\\n  nInstr.c[0].n[0] = n + 75;\\n  const audioCtx = new OfflineAudioContext(2, soundLenSeconds * sampleRate, sampleRate);\\n  const soundGen = new TrackGenerator(audioCtx, nInstr, bpm, 0);\\n  soundGen.connect(audioCtx.destination);\\n  soundGen.start();\\n  const buf = await audioCtx.startRendering();\\n  return buf;\\n}\\n/**\\n * Generates a complete song from a song description.\\n *\\n * @param {*} song The song description\\n * @param {*} options `sampleRate`: the sample rate\\n * @returns {AudioBuffer} The generated audio buffer\\n */\\n\\nasync function generateSong(song, sampleRate) {\\n  const songLenSeconds = song.songLen;\\n  const audioCtx = new OfflineAudioContext(2, songLenSeconds * sampleRate, sampleRate);\\n  const soundGen = new MusicGenerator(audioCtx, song);\\n  soundGen.connect(audioCtx.destination);\\n  soundGen.start();\\n  const buf = await audioCtx.startRendering();\\n  return buf;\\n}\\n\\n//# sourceURL=webpack://sonantx/./sonantx.js?\");\n\n/***/ })\n\n/******/ });\n});\n\n//# sourceURL=webpack://demolished-rail/./node_modules/sonantx/dist/sonantx.bundle.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/runWorld.js");
/******/ 	
/******/ })()
;