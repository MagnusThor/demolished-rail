/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Helpers/assetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/assetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssetsHelper = void 0;\nclass AssetsHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n    static async loadAudio(audioFile, audioContext) {\n        const response = await fetch(audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        return audioBuffer;\n    }\n}\nexports.AssetsHelper = AssetsHelper;\nAssetsHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/assetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/sceneBuilder.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/sceneBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneBuilder = void 0;\nconst scene_1 = __webpack_require__(/*! ../scene */ \"./build/src/Engine/scene.js\");\nclass SceneBuilder {\n    /**\n     * Creates a new SceneBuilder to help construct scenes with automatic timing.\n     * @param totalDuration - The total duration of the animation sequence in milliseconds.\n     */\n    constructor(totalDuration) {\n        this.scenes = [];\n        this.currentTime = 0;\n        this.totalDuration = totalDuration;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and duration.\n     * @param name - The name of the scene.\n     * @param duration - The duration of the scene in milliseconds.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    addScene(name, duration) {\n        const startTime = this.currentTime;\n        this.currentTime += duration;\n        // If the current time exceeds the total duration, adjust the last scene's duration\n        if (this.currentTime > this.totalDuration) {\n            const lastScene = this.scenes[this.scenes.length - 1];\n            if (lastScene) {\n                lastScene.durationInMs = this.totalDuration - lastScene.startTimeinMs;\n            }\n            duration = this.totalDuration - startTime; // Adjust the current scene's duration as well\n        }\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this; // For chaining\n    }\n    /**\n     * Gets the array of scenes with their timing configured.\n     * @returns The array of Scene objects.\n     */\n    getScenes() {\n        return this.scenes;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and a duration that extends to the end of the total duration.\n     * @param name - The name of the scene.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    durationUntilEndInMs(name) {\n        const startTime = this.currentTime;\n        const duration = this.totalDuration - startTime;\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this;\n    }\n}\nexports.SceneBuilder = SceneBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/sceneBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderer/shaderRenderer.js":
/*!***********************************************************!*\
  !*** ./build/src/Engine/ShaderRenderer/shaderRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\nclass ShaderRenderer {\n    /**\n     * Create a Shader\n     *\n     * @param {WebGLProgram} program\n     * @param {number} type\n     * @param {string} source\n     * @memberof DR\n     */\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) { // this.gl.COMPILE_STATUS\n            // gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l: string) =>\n            //         console.error(\"[shader] \" + l))\n            throw new Error(\"Error while compiling vertex/fragment\" + source);\n        }\n        ;\n    }\n    /**\n     * Create and a WebGLProgram\n     *\n     * @param {string} name\n     * @returns {WebGLProgram}\n     * @memberof DR\n     */\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n     *  Create a new WEBGLTexture\n     *\n     * @param {*} data  image or UInt8Array\n     * @returns WebGLTexture\n     * @memberof DR\n     */\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n     * Create a texture cube map\n     *\n     * @param {Array<any>} sources\n     * @param {number} d\n     * @returns {WebGLTexture}\n     * @memberof DR\n     */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n     * add assets ( textures )\n     *\n     * @param {*} assets\n     * @param {()=>void} cb\n     * @returns {this}\n     * @memberof DR\n     */\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n     * add a new buffer / shader program\n     *\n     * @param {string} name\n     * @param {string} vertex\n     * @param {string} fragment\n     * @param {Array<string>} [textures]\n     * @param {*} [customUniforms]\n     * @returns {this}\n     * @memberof DR\n     */\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n     * Set program state ( enable / or disable)\n     *\n     * @param {string} key\n     * @param {boolean} state\n     * @memberof DR\n     */\n    setProgramState(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n     * Render\n     *\n     * @param {number} time\n     * @memberof DR\n     */\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n     * Create render target\n     *\n     * @param {number} width\n     * @param {number} height\n     * @param {Array<string>} textures\n     * @returns {*}\n     * @memberof DR\n     */\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Render loop\n     *\n     * @param {number} t\n     * @param {number} fps\n     * @returns {this}\n     * @memberof DR\n     */\n    run(t, fps) {\n        let pt = performance.now();\n        let interval = 1000 / fps;\n        let dt = 0;\n        const a = (t) => {\n            requestAnimationFrame(a);\n            dt = t - pt;\n            if (dt > interval) {\n                pt = t - (dt % interval);\n                this.update(pt / 1000);\n            }\n        };\n        a(t | 0);\n        return this;\n    }\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     *  Generate a texture and return a canvas element\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {*} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @returns {HTMLCanvasElement}\n     * @memberof DR\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new ShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.ShaderRenderer = ShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderer/shaderRenderer.js?");

/***/ }),

/***/ "./build/src/Engine/entity.js":
/*!************************************!*\
  !*** ./build/src/Engine/entity.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Entity = void 0;\nconst sequence_1 = __webpack_require__(/*! ./sequence */ \"./build/src/Engine/sequence.js\");\nclass Entity {\n    /**\n     * Creates a new Entity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity.\n     * @param action - The action function that defines the entity's behavior.\n     */\n    constructor(name, props, action, startTimeinMs, durationInMs, w, h) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.w = w;\n        this.h = h;\n        this.postProcessors = [];\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w !== undefined && h !== undefined) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        ;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    /**\n    * Adds an event listener for when a beat occurs.\n    * @param listener - The function to call when a beat occurs.\n    * @returns The Entity instance for chaining.\n    */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Copies the entity's canvas to the target canvas and applies post-processors.\n     * @param targetCanvas - The target canvas to copy to.\n     * @param sequence - The Sequence instance.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n                this.postProcessors.forEach(processor => processor(targetCtx, sequence));\n            }\n        }\n    }\n    /**\n    * Updates the entity's state, clears the canvas, and calls the action function.\n    * @param timeStamp - The current timestamp in the animation.\n    */\n    update(timeStamp) {\n        var _a;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.ctx, this.props);\n            }\n            // const sequence = this.getSequence();\n            // if (sequence) {\n            //   this.triggerEntityListeners(sequence, timeStamp);\n            // }\n        }\n    }\n    /**\n   * Retrieves the Sequence instance associated with the entity.\n   * @returns The Sequence instance if available, otherwise null.\n   */\n    getSequence() {\n        if (this.action && this.action.length >= 4) { // Check if the action function accepts the sequence parameter\n            const sequence = this.action.arguments[3]; // Access the fourth argument (sequence)\n            if (sequence instanceof sequence_1.Sequence) {\n                return sequence;\n            }\n        }\n        return null;\n    }\n}\nexports.Entity = Entity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/entity.js?");

/***/ }),

/***/ "./build/src/Engine/scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst entity_1 = __webpack_require__(/*! ./entity */ \"./build/src/Engine/entity.js\");\nclass Scene {\n    /**\n     * Creates a new Scene.\n     * @param name - The name or identifier for the scene.\n     * @param startTimeinMs - The start time of the scene in milliseconds.\n     * @param durationInMs - The duration of the scene in milliseconds.\n     */\n    constructor(name, startTimeinMs, durationInMs, width, height) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.width = width;\n        this.height = height;\n        this.entities = [];\n    }\n    /**\n     * Adds an entity to the scene.\n     * @param entity - The entity to add.\n     */\n    addEntity(entity) {\n        // If the entity's canvas dimensions are not set, use the scene's dimensions\n        if (!entity.w && !entity.h) {\n            entity.canvas.width = this.width || 800;\n            entity.canvas.height = this.height || 450;\n        }\n        this.entities.push(entity);\n    }\n    /**\n     * Adds multiple entities to the scene.\n     * @param entities - An array of entities to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntities(...entities) {\n        entities.forEach(entity => this.addEntity(entity));\n        return this;\n    }\n    /**\n     * Gets an entity from the scene by its key.\n     * @param key - The key of the entity to retrieve.\n     * @returns The entity if found, otherwise undefined.\n     */\n    getEntity(key) {\n        return this.entities.find(entity => entity.name === key);\n    }\n    /**\n     * Plays the scene by animating its entities.\n     * @param elapsedTime - The elapsed time in the animation sequence.\n     * @returns A promise that resolves when the scene has finished playing.\n     */\n    play(elapsedTime) {\n        return new Promise((resolve) => {\n            const startTime = performance.now();\n            const animate = () => {\n                const currentTime = performance.now();\n                const sceneElapsedTime = currentTime - startTime + elapsedTime;\n                const adjustedSceneElapsedTime = sceneElapsedTime - this.startTimeinMs;\n                if (adjustedSceneElapsedTime >= 0) {\n                    this.entities.forEach((entity) => {\n                        entity.update(adjustedSceneElapsedTime);\n                    });\n                }\n                if (sceneElapsedTime < this.durationInMs + this.startTimeinMs) {\n                    // The requestAnimationFrame call was removed here. \n                    // The animation loop is now handled in the Sequence class.\n                }\n                else {\n                    resolve(true);\n                }\n            };\n            animate(); // Call animate once to start the initial rendering\n        });\n    }\n    addPostProcessorToEntities(processor) {\n        this.entities.forEach(entity => {\n            if (entity instanceof entity_1.Entity) { // Check if the entity is an instance of the Entity class\n                entity.addPostProcessor(processor);\n            }\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/scene.js?");

/***/ }),

/***/ "./build/src/Engine/sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ./Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nclass Sequence {\n    /**\n     * Adds a post-processing function to the sequence.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Gets the remaining time in the current scene.\n     * @param timeStamp - The current timestamp in the animation.\n     * @returns The remaining time in milliseconds.\n     */\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime);\n    }\n    /**\n     * Creates a new Sequence.\n     * @param target - The canvas element to render the animation on.\n     * @param bpm - The beats per minute for the animation.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param scenes - An array of scenes to include in the sequence.\n     * @param audioFile - An optional URL to an audio file to synchronize the animation with.\n     */\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, scenes, audioFile) {\n        this.target = target;\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.previousBeat = 0; // Store the previous beat value\n        this.previousTick = 0; // Store the previous tick value\n        this.previousBar = 0; // Store the previous bar value\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.scenes = scenes || [];\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        if (audioFile) {\n            this.audioContext = new AudioContext();\n            this.analyser = this.audioContext.createAnalyser();\n            assetsHelper_1.AssetsHelper.loadAudio(audioFile, this.audioContext)\n                .then(audioBuffer => {\n                this.audioBuffer = audioBuffer;\n                this.onReady();\n            })\n                .catch(error => console.error(\"Error loading audio:\", error));\n        }\n        else {\n            this.onReady();\n        }\n        this.recalculateDuration();\n    }\n    /**\n     * Loads the audio file and initializes the audio context and analyser.\n     * @param audioFile - The URL of the audio file to load.\n     */\n    loadAudio(audioFile) {\n        fetch(audioFile)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n            this.onReady();\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n    }\n    /**\n     * Called when the audio file is loaded or when no audio is used.\n     */\n    onReady() { }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a beat occurs.\n     * @param listener - The function to call when a beat occurs.\n     */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    /**\n     * Adds a scene to the sequence.\n     * @param scene - The scene to add.\n     */\n    addScene(scene) {\n        if (!scene.width && scene.height) {\n            scene.width = this.target.width;\n            scene.height = this.target.height;\n        }\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Adds multiple scenes to the sequence.\n     * @param scenes - The scenes to add.\n     * @returns The Sequence instance for chaining.\n     */\n    addScenes(...scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n    * Adds multiple scenes to the sequence.\n    * @param scenes - The scenes to add.\n    * @returns The Sequence instance for chaining.\n    */\n    addSceneArray(scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n     * Removes a scene from the sequence.\n     * @param scene - The scene to remove.\n     */\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Recalculates the total duration of the sequence.\n     */\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    /**\n     * Starts the animation sequence.\n     */\n    play() {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBeat = 0; // Initialize currentBeat to 0\n        this.startTime = performance.now();\n        if (this.audioBuffer) {\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        const animate = (ts) => {\n            const adjustedTimeStamp = ts - this.startTime;\n            this.playCurrentScene(adjustedTimeStamp);\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    /**\n     * Pauses\n   the animation sequence.\n     */\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Stops the animation sequence.\n     */\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Gets the current scene being played.\n     * @returns The current Scene or undefined if no scene is active.\n     */\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    /**\n  * Animates the current scene and handles scene transitions,\n  * audio analysis, and beat/tick events.\n  * @param timeStamp - The adjusted timestamp for the current frame.\n  */\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        this.currentTime = timeStamp; // Update currentTime\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs && timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no current scene is found, check for upcoming scenes\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, end animation\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n            // Set scene dimensions if not already set\n            if (!this.currentScene.width) {\n                this.currentScene.width = this.target.width;\n            }\n            if (!this.currentScene.height) {\n                this.currentScene.height = this.target.height;\n            }\n            this.currentScene.play(elapsedTime).then(() => {\n                // Scene transition completed\n            });\n        }\n        // FFT analysis (if analyser is available)\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n        }\n        // Clear the target canvas and update/draw entities\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.currentScene.entities.forEach(entity => {\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target, this);\n            }\n            // Trigger entity events only when the values change\n            if (this.currentBeat !== this.previousBeat) {\n                entity.beatListeners.forEach(listener => listener(timeStamp, this.beatCounter, entity.props));\n                this.previousBeat = this.currentBeat;\n            }\n            if (this.currentTick !== this.previousTick) {\n                entity.tickListeners.forEach(listener => listener(timeStamp, this.tickCounter, entity.props));\n                this.previousTick = this.currentTick;\n            }\n            if (this.currentBar !== this.previousBar) {\n                entity.barListeners.forEach(listener => listener(timeStamp, this.currentBar, entity.props));\n                this.previousBar = this.currentBar;\n            }\n        });\n        // Apply post-processing effects\n        if (this.targetCtx) {\n            this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n        }\n        this.handleBeatAndTickEvents(timeStamp); // Handle beat and tick events\n    }\n    /**\n     * Handles beat and tick events based on the current timestamp.\n     * @param timeStamp - The adjusted timestamp for the current frame.\n     */\n    handleBeatAndTickEvents(timeStamp) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1;\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/sequence.js?");

/***/ }),

/***/ "./build/src/Engine/shaderEntity.js":
/*!******************************************!*\
  !*** ./build/src/Engine/shaderEntity.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEntity = void 0;\nconst shaderRenderer_1 = __webpack_require__(/*! ./ShaderRenderer/shaderRenderer */ \"./build/src/Engine/ShaderRenderer/shaderRenderer.js\");\nclass ShaderEntity {\n    /**\n     * Creates a new ShaderEntity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including shader code and render buffers.\n     * @param action - An optional action function to be called before rendering the shaders.\n     */\n    constructor(name, props, action, w, h, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.w = w;\n        this.h = h;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w && h) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainVertexShader) {\n            this.shaderRenderer = new shaderRenderer_1.ShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainVertexShader, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            props.renderBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else {\n            throw new Error(\"Cannot create ShaderEntity: Missing main shader code.\");\n        }\n    }\n    /**\n * Adds an event listener for when a beat occurs.\n * @param listener - The function to call when a beat occurs.\n * @returns The Entity instance for chaining.\n */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n * Adds a post-processing function to the entity.\n * @param processor - The post-processing function to add.\n */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            this.action(timeStamp, this.shaderRenderer, this.props);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props);\n                this.shaderRenderer.update(timeStamp / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n}\nexports.ShaderEntity = ShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/shaderEntity.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/blackholeShader.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/blackholeShader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.blackholeShader = void 0;\nexports.blackholeShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform float zoom;\r\nout vec4 fragColor;\r\n\r\n#define f(a) exp( -10.* pow( length( U -.52*cos(a+vec2(0,33)) ) , 2. ) )\r\n\r\nvoid mainImage( out vec4 O, vec2 u )\r\n{\r\n    float zoomFactor = zoom;\r\n\r\n    vec2  R = resolution.xy,\r\n          U = ( u+u - R ) / R.y ;\r\n    \r\n    O =   ( .5-.5*cos(min(6.*length(U),6.3)) ) \r\n        * (    .7* vec4(1,.25,0,0)\r\n            + ( f(.65)+f(1.6)+f(2.8) ) * vec4(.8,.8,.5,0) );\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/blackholeShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/earthShader.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/earthShader.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.earthShader = void 0;\nexports.earthShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform vec3 cameraPos;\r\nout vec4 fragColor;\r\n\r\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\r\n\r\nfloat hash12(vec2 p) {\r\n\tp = fract(p * vec2(5.3983, 5.4427));\r\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\r\n\treturn fract(p.x * p.y * 95.4337);\r\n}\r\n\r\nvec2 hash21(float p) {\r\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\r\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\r\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\r\n}\r\n\r\nfloat noise(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \r\n                   hash12(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12(i + vec2(0.0, 1.0)), \r\n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat hash12_3(vec2 p) {\r\n\tfloat f = hash12(p);\r\n    return f * f * f;\r\n}\r\n\r\nfloat noise_3(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \r\n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12_3(i + vec2(0.0, 1.0)), \r\n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat fbm(vec2 p) {\r\n    float f = 0.0;\r\n    f += 0.5 * noise(p); p = m * p;\r\n    f += 0.25 * noise(p); p = m * p;\r\n    f += 0.125 * noise(p); p = m * p;\r\n    f += 0.0625 * noise(p); p = m * p;\r\n    f += 0.03125 * noise(p); p = m * p;\r\n    f += 0.015625 * noise(p);\r\n    return f / 0.984375;\r\n}\r\n\r\nvec3 getDir(vec2 screenPos) {\r\n    screenPos -= 0.5;\r\n\tscreenPos.x *= resolution.x / resolution.y;\r\n    \r\n    return normalize(vec3(0.0, -1.0, -3.0)\r\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\r\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\r\n}\r\n\r\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\r\n    bool valid = false;\r\n    \r\n\tfloat b = dot(camera, dir);\r\n\tfloat c = dot(camera, camera) - 1.0;\r\n\tfloat h = b * b - c;\r\n\tif (h > 0.0) {\r\n        valid = true;\r\n        \r\n        vec3 p = camera + (-b - sqrt(h)) * dir;\r\n        pos = p.xz + time * vec2(0.005, 0.02);\r\n\t}\r\n\r\n\treturn valid;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 screen = fragCoord.xy / resolution.xy;\r\n    \r\n    vec3 camera = cameraPos;//vec3(0.0, 1.2, 0.7);\r\n    vec3 dir = getDir(screen);\r\n\r\n    vec3 currentCamera = cameraPos;\r\n    \r\n    vec3 earth = vec3(0.0, 0.0, 0.0);\r\n    vec2 position;\r\n    if (getPosition(camera, dir, position)) {\r\n        float geography = fbm(6.0 * position);\r\n\r\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\r\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\r\n        vec2 p = 40.0 * position;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast);\r\n        population = smoothstep(0.0, 0.02, population);\r\n\r\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\r\n        vec3 water = vec3(0.0, 0.05, 0.1);\r\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\r\n\r\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\r\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\r\n\r\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\r\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \r\n\r\n        float lightning = 0.0;\r\n        vec2 strike;\r\n        if (getPosition(camera, getDir(hash21(time)), strike)) {\r\n            vec2 diff = position - strike;\r\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\r\n        }\r\n        lightning *= smoothstep(0.65, 0.75, weather);\r\n        earth += lightning * vec3(1.0, 1.0, 1.0);\r\n    }\r\n    \r\n    vec3 altitude = camera - dir * dot(camera, dir);\r\n    float horizon = sqrt(dot(altitude, altitude));\r\n    \r\n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\r\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\r\n\r\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\r\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\r\n}\r\n\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/earthShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/eventHorizon.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/eventHorizon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.eventHorizonShader = void 0;\nexports.eventHorizonShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform sampler2D iChannel0;\r\nuniform float zoom;\r\nout vec4 fragColor;\r\n\r\n\r\n// comment this string to see fluffy clouds\r\n#define DENSE_DUST\r\n#define DITHERING\r\n#define BACKGROUND\r\n\r\n//-------------------\r\n#define pi 3.14159265\r\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\r\n\r\nmat2 Spin(float angle)\r\n{\r\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\r\n}\r\n\r\n// iq's noise\r\nfloat pn( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy+vec2(2.0,4.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 2.8)/256.0, 2.5 ).yx;\r\n\treturn -1.0+0.7*mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat fpn(vec3 p)\r\n{\r\n   return pn(p*.06125)*.5 + pn(p*.125)*.15 + pn(p*.15)*.225;// + pn(p*.5)*.625;\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n\treturn fract(sin(dot(co*0.123,vec2(2.9898,1.233))) * 63758.5453);\r\n}\r\n\r\nfloat Ring(vec3 p)\r\n{\r\n  vec2 q = vec2(length(p.xy)-5.3,p.z);\r\n  return length(q)-0.51;\r\n}\r\n\r\nfloat length2( vec2 p )\r\n{\r\n\treturn sqrt( p.x*p.x + p.y*p.y );\r\n}\r\n\r\nfloat length8( vec2 p )\r\n{\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\n\r\n\r\nfloat Disk( vec3 p, vec3 t )\r\n{\r\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.15);\r\n    return max(length8(q)-t.y, abs(p.z) - t.z);\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.45 + 0.14*(b-a)/k, 1.250, 0.250 );\r\n\treturn mix( b, a, h ) - k*h*(2.0-h);\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float t=0.23*time;\r\n\tfloat d1 = Disk(p,vec3(2.75,0.88,0.45)) + fpn(vec3(Spin(t*3.25+p.z*1.20)*p.xy*24.,p.z*25.-t)*5.0) * 0.845;\r\n    float d2 = Ring(p);\r\n    return smin(d1,d2,1.52);\r\n\r\n}\r\n\r\n// assign color to the media\r\nvec3 computeColor( float density, float radius )\r\n{\r\n\t// color based on density alone, gives impression of occlusion within\r\n\t// the media\r\n\tvec3 result = mix( 0.6*vec3(0.26,0.5,0.4), vec3(0.8,0.25,0.1), density );\r\n\t\r\n\t// color added for disk\r\n\tvec3 colCenter = 2.*vec3(0.22,0.6,0.5);\r\n\tvec3 colEdge = 3.*vec3(0.08,0.23,0.5);\r\n\tresult *= mix( colCenter, colEdge, min( (radius+.2)/1.0, 0.25 ) );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\r\n{\r\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\r\n\tfloat a = dot(dir.xy, dir.xy);\r\n\tfloat b = dot(org.xy, dir.xy);\r\n\tfloat c = dot(org.xy, org.xy) - 11.;\r\n\r\n\tfloat delta = b * b - a * c;\r\n\tif( delta < 0.15 )\r\n\t\treturn false;\r\n\r\n\t// 2 roots\r\n\tfloat deltasqrt = sqrt(delta);\r\n\tfloat arcp = 1.1 / a;\r\n\tnear = (-b - deltasqrt) * arcp;\r\n\tfar = (-b + deltasqrt) * arcp;\r\n\t\r\n\t// order roots\r\n\tfloat temp = min(far, near);\r\n\tfar = max(far, near);\r\n\tnear = temp;\r\n\r\n\tfloat znear = org.z + near * dir.z;\r\n\tfloat zfar = org.z + far * dir.z;\r\n\r\n\t// top, bottom\r\n\tvec2 zcap = vec2(9.15, -2.85);\r\n\tvec2 cap = (zcap - org.z) / dir.z;\r\n\r\n\tif ( znear < zcap.y )\r\n\t\tnear = cap.y;\r\n\telse if ( znear > zcap.x )\r\n\t\tnear = cap.x;\r\n\r\n\tif ( zfar < zcap.y )\r\n\t\tfar = cap.y;\r\n\telse if ( zfar > zcap.x )\r\n\t\tfar = cap.x;\r\n\t\r\n\treturn far > 2.5 && far > near;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{  \r\n    const float KEY_1 = 49.5/256.0;\r\n\tconst float KEY_2 = 50.5/256.0;\r\n\tconst float KEY_3 = 51.5/256.0;\r\n    float key = 0.7;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_2,0.15)).x;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\r\n\r\n\t// ro: ray origin\r\n\t// rd: direction of the ray\r\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*resolution.xy)/resolution.y, 2.5));\r\n\tvec3 ro = vec3(1.1, 1.2, -6.+key*0.2);\r\n\r\n   \r\n    R(rd.yz, -pi*3.65);\r\n    R(rd.xz, pi*3.2);\r\n    R(ro.yz, -pi*3.65);\r\n   \tR(ro.xz, pi*3.2);    \r\n \r\n    \r\n    #ifdef DITHERING\r\n\tvec2 dpos = ( fragCoord.xy / resolution.xy );\r\n\tvec2 seed = dpos + fract(time);\r\n   \t// randomizing the length \r\n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \r\n\t#endif \r\n    \r\n\t// ld, td: local, total density \r\n\t// w: weighting factor\r\n\tfloat ld=0.48, td=0.23, w=1.04;\r\n\r\n\t// t: length of the ray\r\n\t// d: distance function\r\n\tfloat d=21.8, t=21.2;\r\n   \r\n\tvec4 sum = vec4(0.1);\r\n   \r\n    float min_dist=2.52, max_dist=222.5;\r\n\r\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\r\n    {\r\n       \r\n\tt = min_dist*step(t,min_dist);\r\n   \r\n\t// raymarch loop\r\n\tfor (int i=0; i<36; i++) \r\n\t{\r\n\t \r\n\t\tvec3 pos = ro + t*rd;\r\n\r\n\t\tfloat fld = 0.40;\r\n       \r\n\t\t// Loop break conditions.\r\n        if(td>(0.9-1./7.) || d<0.008*t || t>13. || sum.a > 0.99 || t>max_dist) break;\r\n\t  \r\n\t\t// evaluate distance function\r\n\t\td = map(pos); \r\n       \r\n\t\t// direction to center\r\n\t\tvec3 stardir = normalize(vec3(3.4)-pos);\r\n      \r\n\t\t// change this string to control density \r\n\t\td = max(d,0.04);\r\n      \r\n\t\tif (d<0.1) \r\n\t\t{\r\n\t\t\t// compute local density \r\n\t\t\tld = 0.2 - d;\r\n\t\t\t\r\n            #ifdef DENSE_DUST          \r\n\t\t\tfld = clamp((ld - map(pos+4.2*stardir))/1.4, 0.22, 1.3 );\r\n\t\t\tld += fld;\r\n            #endif\r\n \t\t\t\r\n            // compute weighting factor \r\n\t\t\tw = (1.4 - td) * ld;\r\n     \r\n\t\t\t// accumulate density\r\n\t\t\ttd += w + 2./3.;\r\n\t\t\r\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.5));\r\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\r\n\t\t\r\n\t\t\t// uniform scale density\r\n\t\t\tcol.a *= 1.02;\r\n\t\t\t// colour by alpha\r\n\t\t\tcol.rgb *= col.a/11.08;\r\n\t\t\t// alpha blend in contribution\r\n\t\t\tsum = sum + col*(1.08 - sum.a);  \r\n\t\t}\r\n      \r\n\t\ttd += 1./110.;\r\n       \r\n        // point light calculations\r\n        vec3 ldst = vec3(1.32)-pos;\r\n        float lDist = max(length(ldst), 0.021);\r\n\r\n        // star in center\r\n        vec3 lightColor=vec3(0.81,0.31,0.15);\r\n        sum.rgb+=lightColor/(lDist*lDist*lDist*7.);//*10.); //add a bloom around the light\r\n\r\n        // using the light distance to perform some falloff\r\n        //float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\r\n        // accumulating the color\r\n        //sum += w*atten*fld;\r\n       \r\n        // enforce minimum stepsize\r\n        d = max(d, 0.24); \r\n      \r\n        #ifdef DITHERING\r\n        // add in noise to reduce banding and create fuzz\r\n        d=abs(d)*(1.+0.58*rand(seed*vec2(i)));\r\n        #endif \r\n\t  \r\n        t +=  max(d * 0.13, 0.19);\r\n      \r\n\t}\r\n    \r\n    //scattering test\r\n\t//sum *= 1. / exp( ld * 0.2 ) * 1.05;\r\n        \r\n   \tsum = clamp( sum, 0.0, 1.0 );\r\n   \r\n    sum.xyz = sum.xyz*sum.xyz*(3.0-1.0*sum.xyz);\r\n    \r\n\t}\r\n\r\n    #ifdef BACKGROUND\r\n    // stars background\r\n    if (td<1.8)\r\n    {\r\n        vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\r\n        vec3 starbg = vec3(0.0);\r\n        starbg = mix(starbg, vec3(0.1,0.3,0.2), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.4),rd)+0.75,0.4,1.0));\r\n        starbg = clamp(starbg, 0.0, 1.0);\r\n        sum.xyz += starbg; \r\n    }\r\n\t#endif\r\n    \r\n   fragColor = vec4(sum.xyz,1.0);\r\n}\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/eventHorizon.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/lonlyPlanetShader.js":
/*!***********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/lonlyPlanetShader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lonlyPlanetShader = void 0;\nexports.lonlyPlanetShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nout vec4 fragColor;\r\n\r\nvec3 vec_tovec3(float a);\r\nvec3 noise_vec3_yzx(vec3 self);\r\nvec3 noise_vec2_xyx(vec2 self);\r\nvec2 sincos(float x);\r\nfloat noise_hash1_2(vec2 v);\r\nfloat noise_hash1_3(vec3 v);\r\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f);\r\nfloat noise_noise_white_1(vec2 p);\r\nfloat noise_noise_value_1(vec3 p);\r\nfloat map(vec3 p);\r\nfloat ray_march(vec3 ro, vec3 rd);\r\nvec3 get_normal(vec3 p);\r\nfloat fbm3(vec3 p);\r\nvec3 planet_palette(float x);\r\nvec3 planet_color(vec3 p);\r\nvec3 shade(vec3 rd, vec3 p);\r\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\r\nfloat expstep(float x, float k);\r\nvec3 get_background(vec3 rd);\r\nvec3 color_tonemap_aces(vec3 col);\r\nvec3 color_saturate(vec3 col, float sat);\r\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma);\r\nvec3 color_gamma_correction(vec3 col);\r\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount);\r\nvec3 dither(vec3 col, vec2 coord, float amount);\r\nvec3 sun_glare(vec3 rd);\r\n/* ------------------------------ DEFINITIONS ------------------------------- */\r\nvec3 vec_tovec3(float a) {\r\n  return vec3(a, a, a);\r\n}\r\nvec3 noise_vec3_yzx(vec3 self) {\r\n  return vec3(self.y, self.z, self.x);\r\n}\r\nvec3 noise_vec2_xyx(vec2 self) {\r\n  return vec3(self.x, self.y, self.x);\r\n}\r\nvec2 sincos(float x) {\r\n  return vec2(sin(x), cos(x));\r\n}\r\nfloat noise_hash1_2(vec2 v) {\r\n  vec3 v3 = noise_vec2_xyx(v);\r\n  v3 = fract((v3 * 0.1031));\r\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\r\n  return fract(((v3.x + v3.y) * v3.z));\r\n}\r\nfloat noise_hash1_3(vec3 v) {\r\n  vec3 v3 = v;\r\n  v3 = fract((v3 * 0.1031));\r\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\r\n  return fract(((v3.x + v3.y) * v3.z));\r\n}\r\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {\r\n  vec3 u = ((f * f) * (3.0 - (2.0 * f)));\r\n  vec3 u1 = (1.0 - u);\r\n  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));\r\n}\r\nfloat noise_noise_white_1(vec2 p) {\r\n  return noise_hash1_2(p);\r\n}\r\nfloat noise_noise_value_1(vec3 p) {\r\n  vec3 i = floor(p);\r\n  vec3 f = fract(p);\r\n  vec3 j = (i + 1.0);\r\n  float a1 = noise_hash1_3(i);\r\n  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));\r\n  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));\r\n  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));\r\n  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));\r\n  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));\r\n  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));\r\n  float d2 = noise_hash1_3(j);\r\n  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);\r\n}\r\nfloat sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {\r\n  vec3 oc = (ro - p);\r\n  float b = dot(oc, rd);\r\n  float c = (dot(oc, oc) - (r * r));\r\n  float h = ((b * b) - c);\r\n  if(h < 0.0) {\r\n    return -1.0f;\r\n  } else {\r\n    return ((-b) - sqrt(h));\r\n  }\r\n}\r\nfloat map(vec3 p) {\r\n  return (length(p) - 0.6);\r\n}\r\nfloat ray_march(vec3 ro, vec3 rd) {\r\n  float t = 0.0;\r\n  for(int i = 0; i < 128; i++) {\r\n    vec3 p = (ro + (t * rd));\r\n    float d = map(p);\r\n    if(d <= 0.0001) {\r\n      return t;\r\n    }\r\n    t = (t + d);\r\n    if(t > 10.0) {\r\n      return -1.0;\r\n    }\r\n  }\r\n  return -1.0;\r\n}\r\nfloat fbm3(vec3 p) {\r\n  float a = 1.0;\r\n  float t = 0.0;\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  return t;\r\n}\r\nvec3 planet_palette(float x) {\r\n  vec3 col = vec3(0.1, 0.6, 0.9);\r\n  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));\r\n  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));\r\n  return col;\r\n}\r\nvec3 planet_color(vec3 p) {\r\n  p = (p * 2.0);\r\n  float t = time;\r\n  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));\r\n  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));\r\n  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);\r\n  vec3 col = planet_palette(r.y);\r\n  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));\r\n  col = clamp(col, 0.0, 1.0);\r\n  return col;\r\n}\r\nvec3 shade(vec3 rd, vec3 p) {\r\n  vec3 normal = normalize(p);\r\n  float ambient_dif = 0.03;\r\n  vec3 dif = vec_tovec3(ambient_dif);\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);\r\n  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);\r\n  dif = (dif + (sun_col * sun_dif));\r\n  vec3 mate = (planet_color(p) * 0.4);\r\n  vec3 col = (mate * dif);\r\n  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);\r\n  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));\r\n  col = (col * (1.0 - fres));\r\n  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));\r\n  return col;\r\n}\r\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\r\n  vec2 sc = sincos(tilt);\r\n  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));\r\n  vec3 w = normalize((lookat - lookfrom));\r\n  vec3 u = cross(w, vup);\r\n  vec3 v = cross(u, w);\r\n  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));\r\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\r\n}\r\nfloat expstep(float x, float k) {\r\n  return exp(((k * x) - k));\r\n}\r\nvec3 get_background(vec3 rd) {\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  float sun_dif = dot(rd, sun_dir);\r\n  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));\r\n  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));\r\n  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));\r\n  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));\r\n  return col;\r\n}\r\nvec3 color_tonemap_aces(vec3 col) {\r\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\r\n}\r\nvec3 color_saturate(vec3 col, float sat) {\r\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\r\n  return (grey + (sat * (col - grey)));\r\n}\r\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {\r\n  col = pow(col, vec_tovec3(invgamma));\r\n  return (((gain - lift) * col) + lift);\r\n}\r\nvec3 color_gamma_correction(vec3 col) {\r\n  return pow(col, vec_tovec3(0.454545455));\r\n}\r\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount) {\r\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\r\n}\r\nvec3 dither(vec3 col, vec2 coord, float amount) {\r\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\r\n}\r\nvec3 sun_glare(vec3 rd) {\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  vec3 glare_col = vec3(1.0, 0.6, 0.2);\r\n  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));\r\n}\r\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\r\n  vec2 res = vec2(resolution.x, resolution.y);\r\n\r\n  vec2 mouse =vec2(0.5,0.5);\r\n\r\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / resolution.y);\r\n  float theta = ((1.88495559 + (time * 0.2)) + (6.28318531 * mouse.x));\r\n  vec3 lookat = vec3(0.0, 0.0, 0.0);\r\n  vec2 sc = (sincos(theta) * 2.0);\r\n  vec3 ro = vec3(sc.x, 0.5, sc.y);\r\n  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);\r\n  float t = sphere_intersect(ro, rd, vec3(0.0, 0.0, 0.0), 0.6);\r\n  vec3 p = (ro + (rd * t));\r\n  vec3 col = get_background(rd);\r\n  float depth = 0.0;\r\n  if(t >= 0.0) {\r\n    col = shade(rd, p);\r\n  \tdepth = smoothstep(2.0, 2.0-0.6, t);\r\n  }\r\n  col = (col + (0.2 * sun_glare(rd)));\r\n  col = color_tonemap_aces(col);\r\n  col = color_tone_1(col, 1.7, 0.002, 1.2);\r\n  col = color_saturate(col, 0.9);\r\n  col = color_gamma_correction(col);\r\n  col = vignette(col, (frag_coord / res), 0.25, 0.7);\r\n  col = dither(col, frag_coord, 0.01);\r\n  frag_col = vec4(col.x, col.y, col.z, depth);\r\n}\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/lonlyPlanetShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainFragment.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainFragment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainFragment = void 0;\nexports.mainFragment = `\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform float sI;\r\n\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform sampler2D iChannel4;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime time\r\n#define res resolution \r\n\r\n\r\n//-------------------------------------------------------------------------------------------\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{\r\n\r\n\tvec4 color = vec4(vec3(0.),1.);\r\n\tvec2 uv = gl_FragCoord.xy / res.xy;\r\n\r\n\tcolor = texture(iChannel0,uv);\r\n\t\r\n\tfragColor = color; //multi1*multi2*blend2;\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainFragment.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainVertex.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainVertex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainVertex = void 0;\nexports.mainVertex = `\r\nlayout(location = 0) in vec2 pos; \r\nout vec4 fragColor;\r\nvoid main(){\r\n    gl_Position = vec4(pos.xy,0.0,1.0);\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainVertex.js?");

/***/ }),

/***/ "./build/wwwroot/src/Fol06.js":
/*!************************************!*\
  !*** ./build/wwwroot/src/Fol06.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst entity_1 = __webpack_require__(/*! ../../src/Engine/entity */ \"./build/src/Engine/entity.js\");\nconst shaderEntity_1 = __webpack_require__(/*! ../../src/Engine/shaderEntity */ \"./build/src/Engine/shaderEntity.js\");\nconst mainFragment_1 = __webpack_require__(/*! ../assets/shaders/mainFragment */ \"./build/wwwroot/assets/shaders/mainFragment.js\");\nconst mainVertex_1 = __webpack_require__(/*! ../assets/shaders/mainVertex */ \"./build/wwwroot/assets/shaders/mainVertex.js\");\nconst sceneBuilder_1 = __webpack_require__(/*! ../../src/Engine/Helpers/sceneBuilder */ \"./build/src/Engine/Helpers/sceneBuilder.js\");\nconst SetupDemo_1 = __webpack_require__(/*! ./SetupDemo */ \"./build/wwwroot/src/SetupDemo.js\");\nconst earthShader_1 = __webpack_require__(/*! ../assets/shaders/earthShader */ \"./build/wwwroot/assets/shaders/earthShader.js\");\nconst fadeInOutTextEffect_1 = __webpack_require__(/*! ./effects/FoL/fadeInOutTextEffect */ \"./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js\");\nconst blackholeShader_1 = __webpack_require__(/*! ../assets/shaders/blackholeShader */ \"./build/wwwroot/assets/shaders/blackholeShader.js\");\nconst eventHorizon_1 = __webpack_require__(/*! ../assets/shaders/eventHorizon */ \"./build/wwwroot/assets/shaders/eventHorizon.js\");\nconst lonlyPlanetShader_1 = __webpack_require__(/*! ../assets/shaders/lonlyPlanetShader */ \"./build/wwwroot/assets/shaders/lonlyPlanetShader.js\");\nconst demo = new SetupDemo_1.SetupDemo();\n/**\n * The darkness at the end of time\n * a Fruit of the Loom demo\n * Released 2024\n * @class Fol06\n */\nclass Fol06 {\n    constructor(sequence, width, height) {\n        this.sequence = sequence;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Create entitiesfor the intro scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    introScene() {\n        const mapEntities = new Array();\n        const textEffectEntity = new entity_1.Entity(\"intro-text\", {\n            y: this.height / 2,\n            texts: [\"The darkness at the end of time\".toLowerCase(), \"a fruit of the loom production\", \"inspired by a series of books\", \"written by professor Ulf Danielsson\"],\n            font: \"Montserrat\",\n            size: 40,\n            fadeInDuration: 2,\n            fadeOutDuration: 2,\n            textDuration: 5\n        }, (ts, ctx, props) => (0, fadeInOutTextEffect_1.textFadeInOut)(ts, ctx, props, this.sequence));\n        mapEntities.push(textEffectEntity);\n        return mapEntities;\n    }\n    /**\n     * Create entities for Earth Scene\n     *\n     * @return {*}  {Map<string,IEntity>}\n     * @memberof Fol06\n     */\n    earthScene() {\n        const mapEntities = new Array();\n        const cameraPositions = [\n            [0.0, 1.2, 0.7],\n            [0.5, 1.0, 0.9],\n            [1.0, 0.8, 1.1],\n        ];\n        let cameraPos = cameraPositions[0];\n        const shader = new shaderEntity_1.ShaderEntity(\"earthShader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: earthShader_1.earthShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"cameraPos\": (uniformLoction, gl) => {\n                            if (uniformLoction) { // uniform cameraPos vec3 \n                                gl.uniform3fv(uniformLoction, cameraPos);\n                            }\n                            ;\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        shader.onBar((ts, count) => {\n            const positionIndex = (count) % cameraPositions.length;\n            cameraPos = cameraPositions[positionIndex];\n        });\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the blackhole scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    blackhole() {\n        const mapEntities = new Array();\n        let zoom = 0.1;\n        const shader = new shaderEntity_1.ShaderEntity(\"earthShader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: blackholeShader_1.blackholeShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"zoom\": (uniformLoction, gl) => {\n                            if (uniformLoction) { // uniform cameraPos vec3 \n                                gl.uniform1f(uniformLoction, zoom);\n                            }\n                            ;\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        shader.onBar((ts, count) => {\n            zoom *= 0.2;\n        });\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the event-horizon scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    eventHorizon() {\n        const mapEntities = new Array();\n        let zoom = 0.1;\n        const shader = new shaderEntity_1.ShaderEntity(\"eventHorizon\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: eventHorizon_1.eventHorizonShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the lonly planet and sun scene scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    lonlyPlanet() {\n        const mapEntities = new Array();\n        let zoom = 0.1;\n        const shader = new shaderEntity_1.ShaderEntity(\"lonley-planet-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: lonlyPlanetShader_1.lonlyPlanetShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n}\nvar SCENE;\n(function (SCENE) {\n    SCENE[SCENE[\"INTRO\"] = 0] = \"INTRO\";\n    SCENE[SCENE[\"EARTH\"] = 1] = \"EARTH\";\n    SCENE[SCENE[\"LONLYPLANET\"] = 2] = \"LONLYPLANET\";\n    SCENE[SCENE[\"BLACKHOLE\"] = 3] = \"BLACKHOLE\";\n    SCENE[SCENE[\"EVENTHORIZON\"] = 4] = \"EVENTHORIZON\";\n})(SCENE || (SCENE = {}));\ndemo.addAssets(\"assets/images/silhouette.png\").then((demo) => {\n    // Create the Scenes\n    // Music length = 139200 ms;\n    const fol06 = new Fol06(demo.sequence, 800, 450);\n    const sceneBuilder = new sceneBuilder_1.SceneBuilder(139200);\n    sceneBuilder\n        .addScene(\"intro\", 20000)\n        .addScene(\"earth\", 20000)\n        .addScene(\"lonly-planet-and-the-sun\", 20000)\n        .addScene(\"blackhole\", 4000).\n        durationUntilEndInMs(\"eventhorizon\");\n    const scenes = sceneBuilder.getScenes();\n    scenes[SCENE.INTRO].addEntities(...fol06.introScene());\n    scenes[SCENE.EARTH].addEntities(...fol06.earthScene());\n    scenes[SCENE.LONLYPLANET].addEntities(...fol06.lonlyPlanet());\n    scenes[SCENE.BLACKHOLE].addEntities(...fol06.blackhole());\n    scenes[SCENE.EVENTHORIZON].addEntities(...fol06.eventHorizon());\n    demo.sequence.addSceneArray(scenes);\n});\ndemo.sequence.onReady = () => {\n    const toggleFullscreen = (elem) => {\n        if (!document.fullscreenElement) {\n            elem.requestFullscreen().catch((err) => {\n                alert(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);\n            });\n        }\n        else {\n            document.exitFullscreen();\n        }\n    };\n    const btn = document.querySelector(\"BUTTON\");\n    btn.textContent = \"CLICK TO START!\";\n    btn.addEventListener(\"click\", () => {\n        var _a;\n        (_a = document.querySelector(\"#launch\")) === null || _a === void 0 ? void 0 : _a.remove();\n        demo.sequence.play();\n        toggleFullscreen(document.querySelector(\"canvas\"));\n    });\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/Fol06.js?");

/***/ }),

/***/ "./build/wwwroot/src/SetupDemo.js":
/*!****************************************!*\
  !*** ./build/wwwroot/src/SetupDemo.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetupDemo = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nconst sequence_1 = __webpack_require__(/*! ../../src/Engine/sequence */ \"./build/src/Engine/sequence.js\");\nclass SetupDemo {\n    constructor() {\n        this.scenes = [];\n        this.settings = {\n            width: 800,\n            height: 450,\n            audioProperties: {\n                bpm: 110,\n                ticks: 8,\n                beat: 0,\n                tick: 0,\n                bar: 0,\n                avgFreq: 0\n            },\n            font: \"Big Shoulders Stencil Text\"\n        };\n        this.sequence = new sequence_1.Sequence(document.querySelector(\"canvas\"), 100, 4, 4, [], \"/wwwroot/assets/music/music.mp3\");\n    }\n    async addAssets(...urls) {\n        await assetsHelper_1.AssetsHelper.loadImages(urls);\n        return this;\n    }\n    addScene(scene) {\n        this.sequence.addScene(scene);\n    }\n    addEntity(key, entity) {\n        const scene = this.scenes.find(pre => {\n            return pre.name === key;\n        });\n        if (scene) {\n            scene.addEntity(entity);\n        }\n        else\n            throw Error(\"No such scene\");\n    }\n}\nexports.SetupDemo = SetupDemo;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/SetupDemo.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js":
/*!**************************************************************!*\
  !*** ./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textFadeInOut = void 0;\nconst textFadeInOut = (ts, ctx, propertybag, sequence) => {\n    const { y, texts, font, size, fadeInDuration, fadeOutDuration, textDuration } = propertybag;\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    ctx.textAlign = \"center\";\n    const sceneStartTime = sequence.currentScene.startTimeinMs / 1000;\n    const elapsed = ts / 1000 - sceneStartTime; // Time elapsed since the start of the scene\n    // Calculate the index of the current text element\n    const textIndex = Math.floor(elapsed / textDuration) % texts.length;\n    const text = texts[textIndex];\n    // Calculate the elapsed time for the current text element\n    const textElapsed = elapsed % textDuration;\n    let alpha = 1;\n    if (textElapsed < fadeInDuration) {\n        alpha = textElapsed / fadeInDuration; // Fade in\n    }\n    else if (textElapsed > textDuration - fadeOutDuration) {\n        alpha = (textDuration - textElapsed) / fadeOutDuration; // Fade out\n    }\n    ctx.globalAlpha = alpha;\n    ctx.fillText(text, ctx.canvas.width / 2, y); // Draw centered text\n    ctx.globalAlpha = 1;\n};\nexports.textFadeInOut = textFadeInOut;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/Fol06.js");
/******/ 	
/******/ })()
;