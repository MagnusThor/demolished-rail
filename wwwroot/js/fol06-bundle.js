/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Helpers/assetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/assetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssetsHelper = void 0;\nclass AssetsHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n    static async loadAudio(audioFile, audioContext) {\n        const response = await fetch(audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        return audioBuffer;\n    }\n}\nexports.AssetsHelper = AssetsHelper;\nAssetsHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/assetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/sceneBuilder.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/sceneBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneBuilder = void 0;\nconst scene_1 = __webpack_require__(/*! ../scene */ \"./build/src/Engine/scene.js\");\nclass SceneBuilder {\n    /**\n     * Creates a new SceneBuilder to help construct scenes with automatic timing.\n     * @param totalDuration - The total duration of the animation sequence in milliseconds.\n     */\n    constructor(totalDuration) {\n        this.scenes = [];\n        this.currentTime = 0;\n        this.totalDuration = totalDuration;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and duration.\n     * @param name - The name of the scene.\n     * @param duration - The duration of the scene in milliseconds.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    addScene(name, duration) {\n        const startTime = this.currentTime;\n        this.currentTime += duration;\n        // If the current time exceeds the total duration, adjust the last scene's duration\n        if (this.currentTime > this.totalDuration) {\n            const lastScene = this.scenes[this.scenes.length - 1];\n            if (lastScene) {\n                lastScene.durationInMs = this.totalDuration - lastScene.startTimeinMs;\n            }\n            duration = this.totalDuration - startTime; // Adjust the current scene's duration as well\n        }\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this; // For chaining\n    }\n    /**\n     * Gets the array of scenes with their timing configured.\n     * @returns The array of Scene objects.\n     */\n    getScenes() {\n        return this.scenes;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and a duration that extends to the end of the total duration.\n     * @param name - The name of the scene.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    durationUntilEndInMs(name) {\n        const startTime = this.currentTime;\n        const duration = this.totalDuration - startTime;\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this;\n    }\n}\nexports.SceneBuilder = SceneBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/sceneBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderer/shaderRenderer.js":
/*!***********************************************************!*\
  !*** ./build/src/Engine/ShaderRenderer/shaderRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\nclass ShaderRenderer {\n    /**\n     * Create a Shader\n     *\n     * @param {WebGLProgram} program\n     * @param {number} type\n     * @param {string} source\n     * @memberof DR\n     */\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) { // this.gl.COMPILE_STATUS\n            // gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l: string) =>\n            //         console.error(\"[shader] \" + l))\n            throw new Error(\"Error while compiling vertex/fragment\" + source);\n        }\n        ;\n    }\n    /**\n     * Create and a WebGLProgram\n     *\n     * @param {string} name\n     * @returns {WebGLProgram}\n     * @memberof DR\n     */\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n     *  Create a new WEBGLTexture\n     *\n     * @param {*} data  image or UInt8Array\n     * @returns WebGLTexture\n     * @memberof DR\n     */\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n     * Create a texture cube map\n     *\n     * @param {Array<any>} sources\n     * @param {number} d\n     * @returns {WebGLTexture}\n     * @memberof DR\n     */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n     * add assets ( textures )\n     *\n     * @param {*} assets\n     * @param {()=>void} cb\n     * @returns {this}\n     * @memberof DR\n     */\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n     * add a new buffer / shader program\n     *\n     * @param {string} name\n     * @param {string} vertex\n     * @param {string} fragment\n     * @param {Array<string>} [textures]\n     * @param {*} [customUniforms]\n     * @returns {this}\n     * @memberof DR\n     */\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n     * Set program state ( enable / or disable)\n     *\n     * @param {string} key\n     * @param {boolean} state\n     * @memberof DR\n     */\n    setProgramState(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n     * Render\n     *\n     * @param {number} time\n     * @memberof DR\n     */\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n     * Create render target\n     *\n     * @param {number} width\n     * @param {number} height\n     * @param {Array<string>} textures\n     * @returns {*}\n     * @memberof DR\n     */\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Render loop\n     *\n     * @param {number} t\n     * @param {number} fps\n     * @returns {this}\n     * @memberof DR\n     */\n    run(t, fps) {\n        let pt = performance.now();\n        let interval = 1000 / fps;\n        let dt = 0;\n        const a = (t) => {\n            requestAnimationFrame(a);\n            dt = t - pt;\n            if (dt > interval) {\n                pt = t - (dt % interval);\n                this.update(pt / 1000);\n            }\n        };\n        a(t | 0);\n        return this;\n    }\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     *  Generate a texture and return a canvas element\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {*} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @returns {HTMLCanvasElement}\n     * @memberof DR\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new ShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.ShaderRenderer = ShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderer/shaderRenderer.js?");

/***/ }),

/***/ "./build/src/Engine/entity.js":
/*!************************************!*\
  !*** ./build/src/Engine/entity.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Entity = void 0;\nconst sequence_1 = __webpack_require__(/*! ./sequence */ \"./build/src/Engine/sequence.js\");\nclass Entity {\n    /**\n     * Creates a new Entity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity.\n     * @param action - The action function that defines the entity's behavior.\n     */\n    constructor(name, props, action, startTimeinMs, durationInMs, w, h) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.w = w;\n        this.h = h;\n        this.postProcessors = [];\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w !== undefined && h !== undefined) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        ;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    /**\n    * Adds an event listener for when a beat occurs.\n    * @param listener - The function to call when a beat occurs.\n    * @returns The Entity instance for chaining.\n    */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Copies the entity's canvas to the target canvas and applies post-processors.\n     * @param targetCanvas - The target canvas to copy to.\n     * @param sequence - The Sequence instance.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n                this.postProcessors.forEach(processor => processor(targetCtx, sequence));\n            }\n        }\n    }\n    /**\n    * Updates the entity's state, clears the canvas, and calls the action function.\n    * @param timeStamp - The current timestamp in the animation.\n    */\n    update(timeStamp) {\n        var _a;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.ctx, this.props);\n            }\n            // const sequence = this.getSequence();\n            // if (sequence) {\n            //   this.triggerEntityListeners(sequence, timeStamp);\n            // }\n        }\n    }\n    /**\n   * Retrieves the Sequence instance associated with the entity.\n   * @returns The Sequence instance if available, otherwise null.\n   */\n    getSequence() {\n        if (this.action && this.action.length >= 4) { // Check if the action function accepts the sequence parameter\n            const sequence = this.action.arguments[3]; // Access the fourth argument (sequence)\n            if (sequence instanceof sequence_1.Sequence) {\n                return sequence;\n            }\n        }\n        return null;\n    }\n}\nexports.Entity = Entity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/entity.js?");

/***/ }),

/***/ "./build/src/Engine/scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst entity_1 = __webpack_require__(/*! ./entity */ \"./build/src/Engine/entity.js\");\nclass Scene {\n    /**\n     * Creates a new Scene.\n     * @param name - The name or identifier for the scene.\n     * @param startTimeinMs - The start time of the scene in milliseconds.\n     * @param durationInMs - The duration of the scene in milliseconds.\n     */\n    constructor(name, startTimeinMs, durationInMs, width, height) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.width = width;\n        this.height = height;\n        this.entities = [];\n    }\n    /**\n     * Adds an entity to the scene.\n     * @param entity - The entity to add.\n     */\n    addEntity(entity) {\n        // If the entity's canvas dimensions are not set, use the scene's dimensions\n        if (!entity.w && !entity.h) {\n            entity.canvas.width = this.width || 800;\n            entity.canvas.height = this.height || 450;\n        }\n        this.entities.push(entity);\n    }\n    /**\n     * Adds multiple entities to the scene.\n     * @param entities - An array of entities to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntities(...entities) {\n        entities.forEach(entity => this.addEntity(entity));\n        return this;\n    }\n    /**\n     * Gets an entity from the scene by its key.\n     * @param key - The key of the entity to retrieve.\n     * @returns The entity if found, otherwise undefined.\n     */\n    getEntity(key) {\n        return this.entities.find(entity => entity.name === key);\n    }\n    /**\n     * Plays the scene by animating its entities.\n     * @param elapsedTime - The elapsed time in the animation sequence.\n     * @returns A promise that resolves when the scene has finished playing.\n     */\n    play(elapsedTime) {\n        return new Promise((resolve) => {\n            const startTime = performance.now();\n            const animate = () => {\n                const currentTime = performance.now();\n                const sceneElapsedTime = currentTime - startTime + elapsedTime;\n                const adjustedSceneElapsedTime = sceneElapsedTime - this.startTimeinMs;\n                if (adjustedSceneElapsedTime >= 0) {\n                    this.entities.forEach((entity) => {\n                        entity.update(adjustedSceneElapsedTime);\n                    });\n                }\n                if (sceneElapsedTime < this.durationInMs + this.startTimeinMs) {\n                    // The requestAnimationFrame call was removed here. \n                    // The animation loop is now handled in the Sequence class.\n                }\n                else {\n                    resolve(true);\n                }\n            };\n            animate(); // Call animate once to start the initial rendering\n        });\n    }\n    addPostProcessorToEntities(processor) {\n        this.entities.forEach(entity => {\n            if (entity instanceof entity_1.Entity) { // Check if the entity is an instance of the Entity class\n                entity.addPostProcessor(processor);\n            }\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/scene.js?");

/***/ }),

/***/ "./build/src/Engine/sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ./Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nclass Sequence {\n    /**\n     * Adds a post-processing function to the sequence.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Gets the remaining time in the current scene.\n     * @param timeStamp - The current timestamp in the animation.\n     * @returns The remaining time in milliseconds.\n     */\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime);\n    }\n    /**\n     * Creates a new Sequence.\n     * @param target - The canvas element to render the animation on.\n     * @param bpm - The beats per minute for the animation.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param scenes - An array of scenes to include in the sequence.\n     * @param audioFile - An optional URL to an audio file to synchronize the animation with.\n     */\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, scenes, audioFile) {\n        this.target = target;\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.previousBeat = 0; // Store the previous beat value\n        this.previousTick = 0; // Store the previous tick value\n        this.previousBar = 0; // Store the previous bar value\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.scenes = scenes || [];\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        if (audioFile) {\n            this.audioContext = new AudioContext();\n            this.analyser = this.audioContext.createAnalyser();\n            assetsHelper_1.AssetsHelper.loadAudio(audioFile, this.audioContext)\n                .then(audioBuffer => {\n                this.audioBuffer = audioBuffer;\n                this.onReady();\n            })\n                .catch(error => console.error(\"Error loading audio:\", error));\n        }\n        else {\n            this.onReady();\n        }\n        this.recalculateDuration();\n    }\n    /**\n     * Loads the audio file and initializes the audio context and analyser.\n     * @param audioFile - The URL of the audio file to load.\n     */\n    loadAudio(audioFile) {\n        fetch(audioFile)\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n            this.onReady();\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n    }\n    /**\n     * Called when the audio file is loaded or when no audio is used.\n     */\n    onReady() { }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a beat occurs.\n     * @param listener - The function to call when a beat occurs.\n     */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    /**\n     * Adds a scene to the sequence.\n     * @param scene - The scene to add.\n     */\n    addScene(scene) {\n        if (!scene.width && scene.height) {\n            scene.width = this.target.width;\n            scene.height = this.target.height;\n        }\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Adds multiple scenes to the sequence.\n     * @param scenes - The scenes to add.\n     * @returns The Sequence instance for chaining.\n     */\n    addScenes(...scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n    * Adds multiple scenes to the sequence.\n    * @param scenes - The scenes to add.\n    * @returns The Sequence instance for chaining.\n    */\n    addSceneArray(scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n     * Removes a scene from the sequence.\n     * @param scene - The scene to remove.\n     */\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Recalculates the total duration of the sequence.\n     */\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    /**\n     * Starts the animation sequence.\n     */\n    play() {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBeat = 0; // Initialize currentBeat to 0\n        this.startTime = performance.now();\n        if (this.audioBuffer) {\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        const animate = (ts) => {\n            const adjustedTimeStamp = ts - this.startTime;\n            this.playCurrentScene(adjustedTimeStamp);\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    /**\n     * Pauses\n   the animation sequence.\n     */\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Stops the animation sequence.\n     */\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Gets the current scene being played.\n     * @returns The current Scene or undefined if no scene is active.\n     */\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    /**\n  * Animates the current scene and handles scene transitions,\n  * audio analysis, and beat/tick events.\n  * @param timeStamp - The adjusted timestamp for the current frame.\n  */\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        this.currentTime = timeStamp; // Update currentTime\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs && timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no current scene is found, check for upcoming scenes\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, end animation\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n            // Set scene dimensions if not already set\n            if (!this.currentScene.width) {\n                this.currentScene.width = this.target.width;\n            }\n            if (!this.currentScene.height) {\n                this.currentScene.height = this.target.height;\n            }\n            this.currentScene.play(elapsedTime).then(() => {\n                // Scene transition completed\n            });\n        }\n        // FFT analysis (if analyser is available)\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n        }\n        // Clear the target canvas and update/draw entities\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.currentScene.entities.forEach(entity => {\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target, this);\n            }\n            // Trigger entity events only when the values change\n            if (this.currentBeat !== this.previousBeat) {\n                entity.beatListeners.forEach(listener => listener(timeStamp, this.beatCounter, entity.props));\n                this.previousBeat = this.currentBeat;\n            }\n            if (this.currentTick !== this.previousTick) {\n                entity.tickListeners.forEach(listener => listener(timeStamp, this.tickCounter, entity.props));\n                this.previousTick = this.currentTick;\n            }\n            if (this.currentBar !== this.previousBar) {\n                entity.barListeners.forEach(listener => listener(timeStamp, this.currentBar, entity.props));\n                this.previousBar = this.currentBar;\n            }\n        });\n        // Apply post-processing effects\n        if (this.targetCtx) {\n            this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n        }\n        this.handleBeatAndTickEvents(timeStamp); // Handle beat and tick events\n    }\n    /**\n     * Handles beat and tick events based on the current timestamp.\n     * @param timeStamp - The adjusted timestamp for the current frame.\n     */\n    handleBeatAndTickEvents(timeStamp) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1;\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/sequence.js?");

/***/ }),

/***/ "./build/src/Engine/shaderEntity.js":
/*!******************************************!*\
  !*** ./build/src/Engine/shaderEntity.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEntity = void 0;\nconst shaderRenderer_1 = __webpack_require__(/*! ./ShaderRenderer/shaderRenderer */ \"./build/src/Engine/ShaderRenderer/shaderRenderer.js\");\nclass ShaderEntity {\n    /**\n     * Creates a new ShaderEntity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including shader code and render buffers.\n     * @param action - An optional action function to be called before rendering the shaders.\n     */\n    constructor(name, props, action, w, h, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.w = w;\n        this.h = h;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w && h) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainVertexShader) {\n            this.shaderRenderer = new shaderRenderer_1.ShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainVertexShader, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            props.renderBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else {\n            throw new Error(\"Cannot create ShaderEntity: Missing main shader code.\");\n        }\n    }\n    /**\n * Adds an event listener for when a beat occurs.\n * @param listener - The function to call when a beat occurs.\n * @returns The Entity instance for chaining.\n */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n * Adds a post-processing function to the entity.\n * @param processor - The post-processing function to add.\n */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate the elapsed time for the entity\n            const elapsed = timeStamp - (this.startTimeinMs || 0);\n            this.action(timeStamp, this.shaderRenderer, this.props);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props);\n                this.shaderRenderer.update(timeStamp / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n}\nexports.ShaderEntity = ShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/shaderEntity.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/earthShader.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/earthShader.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.earthShader = void 0;\nexports.earthShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform vec3 cameraPos;\r\nout vec4 fragColor;\r\n\r\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\r\n\r\nfloat hash12(vec2 p) {\r\n\tp = fract(p * vec2(5.3983, 5.4427));\r\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\r\n\treturn fract(p.x * p.y * 95.4337);\r\n}\r\n\r\nvec2 hash21(float p) {\r\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\r\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\r\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\r\n}\r\n\r\nfloat noise(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \r\n                   hash12(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12(i + vec2(0.0, 1.0)), \r\n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat hash12_3(vec2 p) {\r\n\tfloat f = hash12(p);\r\n    return f * f * f;\r\n}\r\n\r\nfloat noise_3(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \r\n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12_3(i + vec2(0.0, 1.0)), \r\n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat fbm(vec2 p) {\r\n    float f = 0.0;\r\n    f += 0.5 * noise(p); p = m * p;\r\n    f += 0.25 * noise(p); p = m * p;\r\n    f += 0.125 * noise(p); p = m * p;\r\n    f += 0.0625 * noise(p); p = m * p;\r\n    f += 0.03125 * noise(p); p = m * p;\r\n    f += 0.015625 * noise(p);\r\n    return f / 0.984375;\r\n}\r\n\r\nvec3 getDir(vec2 screenPos) {\r\n    screenPos -= 0.5;\r\n\tscreenPos.x *= resolution.x / resolution.y;\r\n    \r\n    return normalize(vec3(0.0, -1.0, -3.0)\r\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\r\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\r\n}\r\n\r\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\r\n    bool valid = false;\r\n    \r\n\tfloat b = dot(camera, dir);\r\n\tfloat c = dot(camera, camera) - 1.0;\r\n\tfloat h = b * b - c;\r\n\tif (h > 0.0) {\r\n        valid = true;\r\n        \r\n        vec3 p = camera + (-b - sqrt(h)) * dir;\r\n        pos = p.xz + time * vec2(0.005, 0.02);\r\n\t}\r\n\r\n\treturn valid;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 screen = fragCoord.xy / resolution.xy;\r\n    \r\n    vec3 camera = cameraPos;//vec3(0.0, 1.2, 0.7);\r\n    vec3 dir = getDir(screen);\r\n\r\n    vec3 currentCamera = cameraPos;\r\n    \r\n    vec3 earth = vec3(0.0, 0.0, 0.0);\r\n    vec2 position;\r\n    if (getPosition(camera, dir, position)) {\r\n        float geography = fbm(6.0 * position);\r\n\r\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\r\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\r\n        vec2 p = 40.0 * position;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast);\r\n        population = smoothstep(0.0, 0.02, population);\r\n\r\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\r\n        vec3 water = vec3(0.0, 0.05, 0.1);\r\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\r\n\r\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\r\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\r\n\r\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\r\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \r\n\r\n        float lightning = 0.0;\r\n        vec2 strike;\r\n        if (getPosition(camera, getDir(hash21(time)), strike)) {\r\n            vec2 diff = position - strike;\r\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\r\n        }\r\n        lightning *= smoothstep(0.65, 0.75, weather);\r\n        earth += lightning * vec3(1.0, 1.0, 1.0);\r\n    }\r\n    \r\n    vec3 altitude = camera - dir * dot(camera, dir);\r\n    float horizon = sqrt(dot(altitude, altitude));\r\n    \r\n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\r\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\r\n\r\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\r\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\r\n}\r\n\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/earthShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainFragment.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainFragment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainFragment = void 0;\nexports.mainFragment = `\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform float sI;\r\n\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform sampler2D iChannel4;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime time\r\n#define res resolution \r\n\r\n\r\n//-------------------------------------------------------------------------------------------\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{\r\n\r\n\tvec4 color = vec4(vec3(0.),1.);\r\n\tvec2 uv = gl_FragCoord.xy / res.xy;\r\n\r\n\tcolor = texture(iChannel0,uv);\r\n\t\r\n\tfragColor = color; //multi1*multi2*blend2;\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainFragment.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainVertex.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainVertex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainVertex = void 0;\nexports.mainVertex = `\r\nlayout(location = 0) in vec2 pos; \r\nout vec4 fragColor;\r\nvoid main(){\r\n    gl_Position = vec4(pos.xy,0.0,1.0);\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainVertex.js?");

/***/ }),

/***/ "./build/wwwroot/src/Fol06.js":
/*!************************************!*\
  !*** ./build/wwwroot/src/Fol06.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst shaderEntity_1 = __webpack_require__(/*! ../../src/Engine/shaderEntity */ \"./build/src/Engine/shaderEntity.js\");\nconst mainFragment_1 = __webpack_require__(/*! ../assets/shaders/mainFragment */ \"./build/wwwroot/assets/shaders/mainFragment.js\");\nconst mainVertex_1 = __webpack_require__(/*! ../assets/shaders/mainVertex */ \"./build/wwwroot/assets/shaders/mainVertex.js\");\nconst sceneBuilder_1 = __webpack_require__(/*! ../../src/Engine/Helpers/sceneBuilder */ \"./build/src/Engine/Helpers/sceneBuilder.js\");\nconst SetupDemo_1 = __webpack_require__(/*! ./SetupDemo */ \"./build/wwwroot/src/SetupDemo.js\");\nconst earthShader_1 = __webpack_require__(/*! ../assets/shaders/earthShader */ \"./build/wwwroot/assets/shaders/earthShader.js\");\nconst demo = new SetupDemo_1.SetupDemo();\n/**\n * The darkness at the end of time\n * a Fruit of the Loom demo\n * Released 2024\n * @class Fol06\n */\nclass Fol06 {\n    constructor(sequence, width, height) {\n        this.sequence = sequence;\n        this.width = width;\n        this.height = height;\n    }\n    introScene() {\n        const mapEntities = new Array();\n        return mapEntities;\n    }\n    /**\n     * Create entities for Earth Scene\n     *\n     * @return {*}  {Map<string,IEntity>}\n     * @memberof Fol06\n     */\n    earthScene() {\n        const cameraPositions = [\n            [0.0, 1.2, 0.7],\n            [0.5, 1.0, 0.9],\n            [1.0, 0.8, 1.1],\n        ];\n        let cameraPos = cameraPositions[0];\n        const shader = new shaderEntity_1.ShaderEntity(\"earthShader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: earthShader_1.earthShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"cameraPos\": (uniformLoction, gl) => {\n                            if (uniformLoction) { // uniform cameraPos vec3 \n                                gl.uniform3fv(uniformLoction, cameraPos);\n                            }\n                            ;\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        shader.onBar((ts, count) => {\n            const positionIndex = (count) % cameraPositions.length;\n            cameraPos = cameraPositions[positionIndex];\n        });\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n}\nvar SCENE;\n(function (SCENE) {\n    SCENE[SCENE[\"INTRO\"] = 0] = \"INTRO\";\n    SCENE[SCENE[\"EARTH\"] = 1] = \"EARTH\";\n})(SCENE || (SCENE = {}));\ndemo.addAssets(\"assets/images/silhouette.png\").then((demo) => {\n    // Create the Scenes\n    // Music length = 139200 ms;\n    const fol06 = new Fol06(demo.sequence, 800, 450);\n    const sceneBuilder = new sceneBuilder_1.SceneBuilder(139200);\n    sceneBuilder\n        .addScene(\"intro\", 10000).\n        durationUntilEndInMs(\"earth\");\n    const scenes = sceneBuilder.getScenes();\n    scenes[SCENE.EARTH].addEntities(...fol06.earthScene());\n    demo.sequence.addSceneArray(scenes);\n});\ndemo.sequence.onReady = () => {\n    const btn = document.querySelector(\"BUTTON\");\n    btn.textContent = \"CLICK TO START!\";\n    btn.addEventListener(\"click\", () => {\n        var _a;\n        (_a = document.querySelector(\"#launch\")) === null || _a === void 0 ? void 0 : _a.remove();\n        demo.sequence.play();\n    });\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/Fol06.js?");

/***/ }),

/***/ "./build/wwwroot/src/SetupDemo.js":
/*!****************************************!*\
  !*** ./build/wwwroot/src/SetupDemo.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetupDemo = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nconst sequence_1 = __webpack_require__(/*! ../../src/Engine/sequence */ \"./build/src/Engine/sequence.js\");\nclass SetupDemo {\n    constructor() {\n        this.scenes = [];\n        this.settings = {\n            width: 800,\n            height: 450,\n            audioProperties: {\n                bpm: 110,\n                ticks: 8,\n                beat: 0,\n                tick: 0,\n                bar: 0,\n                avgFreq: 0\n            },\n            font: \"Big Shoulders Stencil Text\"\n        };\n        this.sequence = new sequence_1.Sequence(document.querySelector(\"canvas\"), 100, 4, 4, [], \"/wwwroot/assets/music/music.mp3\");\n    }\n    async addAssets(...urls) {\n        await assetsHelper_1.AssetsHelper.loadImages(urls);\n        return this;\n    }\n    addScene(scene) {\n        this.sequence.addScene(scene);\n    }\n    addEntity(key, entity) {\n        const scene = this.scenes.find(pre => {\n            return pre.name === key;\n        });\n        if (scene) {\n            scene.addEntity(entity);\n        }\n        else\n            throw Error(\"No such scene\");\n    }\n}\nexports.SetupDemo = SetupDemo;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/SetupDemo.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/Fol06.js");
/******/ 	
/******/ })()
;