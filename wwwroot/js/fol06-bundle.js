/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/Engine/Audio/audioLoader.js":
/*!***********************************************!*\
  !*** ./build/src/Engine/Audio/audioLoader.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SonantAudioLoader = exports.DefaultAudioLoader = void 0;\nconst sonant = __importStar(__webpack_require__(/*! sonantx */ \"./node_modules/sonantx/dist/sonantx.bundle.js\"));\nconst EngineLogger_1 = __webpack_require__(/*! ../EngineLogger */ \"./build/src/Engine/EngineLogger.js\");\n// RegularAudioLoader.ts\nclass DefaultAudioLoader {\n    constructor(audioFile) {\n        this.audioFile = audioFile;\n    }\n    async loadAudio(audioContext) {\n        const response = await fetch(this.audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        EngineLogger_1.EngineLogger.log(`audioBuffer duration after decoding is ${audioBuffer.duration} seconds`);\n        return audioBuffer;\n    }\n}\nexports.DefaultAudioLoader = DefaultAudioLoader;\nclass SonantAudioLoader {\n    constructor(songData) {\n        this.songData = songData;\n    } // Replace 'any' with the actual type of your song data\n    async loadAudio(audioContext) {\n        console.log(`Generating audioBuffer - it may take a while`);\n        const audioBuffer = await sonant.generateSong(this.songData, audioContext.sampleRate);\n        EngineLogger_1.EngineLogger.log(`audioBuffer duration after decoding is ${audioBuffer.duration} seconds`);\n        return audioBuffer;\n    }\n}\nexports.SonantAudioLoader = SonantAudioLoader;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Audio/audioLoader.js?");

/***/ }),

/***/ "./build/src/Engine/EngineLogger.js":
/*!******************************************!*\
  !*** ./build/src/Engine/EngineLogger.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EngineLogger = void 0;\nclass EngineLogger {\n    /**\n     * Enables or disables logging.\n     * @param enabled - Whether logging should be enabled or disabled.\n     */\n    static setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Logs messages to the console if logging is enabled.\n     * @param args - The messages to log.\n     */\n    static log(...args) {\n        if (this.enabled) {\n            console.log(...args);\n        }\n    }\n}\nexports.EngineLogger = EngineLogger;\nEngineLogger.enabled = true; // Add a flag to control logging\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/EngineLogger.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/assetsHelper.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/assetsHelper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssetsHelper = void 0;\nclass AssetsHelper {\n    static async loadImage(url) {\n        const filename = url.split(\"/\").pop();\n        if (this.textureCache.has(filename)) {\n            return this.textureCache.get(filename).src;\n        }\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = url;\n            img.onload = () => {\n                this.textureCache.set(filename, { src: img });\n                resolve(img);\n            };\n            img.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n    static async loadImages(urls) {\n        const imagePromises = urls.map(url => this.loadImage(url));\n        return Promise.all(imagePromises);\n    }\n    static async loadAudio(audioFile, audioContext) {\n        const response = await fetch(audioFile);\n        const arrayBuffer = await response.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        return audioBuffer;\n    }\n}\nexports.AssetsHelper = AssetsHelper;\nAssetsHelper.textureCache = new Map();\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/assetsHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/debugHelper.js":
/*!*************************************************!*\
  !*** ./build/src/Engine/Helpers/debugHelper.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DebugHelper = void 0;\nclass DebugHelper {\n    /**\n     * Creates a new DebugHelper to display debug information on the screen.\n     * @param sequence - The Sequence instance to get timing and beat information from.\n     * @param startScene - The optional scene number to start the debug display from.\n     */\n    constructor(sequence, startScene = 0) {\n        this.sequence = sequence;\n        this.startScene = startScene;\n        this.divElement = document.createElement(\"div\");\n        this.divElement.style.position = \"fixed\";\n        this.divElement.style.top = \"10px\";\n        this.divElement.style.left = \"10px\";\n        this.divElement.style.backgroundColor = \"rgba(0, 0, 0, 0.8)\";\n        this.divElement.style.color = \"white\";\n        this.divElement.style.padding = \"5px\";\n        this.divElement.style.fontFamily = \"monospace\";\n        this.divElement.style.zIndex = \"1000\";\n        document.body.appendChild(this.divElement);\n        this.startTime = performance.now(); // Initialize startTime\n    }\n    /**\n     * Updates the debug display with the current time, scene, beat, and bar information.\n     */\n    update() {\n        var _a;\n        const elapsedTimeMs = performance.now() - this.startTime; // Calculate elapsed time\n        const elapsedTimeSec = (elapsedTimeMs / 1000).toFixed(2);\n        const currentSceneName = ((_a = this.sequence.currentScene) === null || _a === void 0 ? void 0 : _a.name) || \"None\";\n        const currentBeat = this.sequence.currentBeat;\n        const currentBar = this.sequence.currentBar;\n        const beatCounter = this.sequence.beatCounter;\n        if (this.sequence.currentSceneIndex >= this.startScene) {\n            this.divElement.textContent = `\r\n        Elapsed Time: ${elapsedTimeMs.toFixed(0)}ms (${elapsedTimeSec}s)\r\n        Scene: ${currentSceneName}\r\n        Beat: ${currentBeat} (${beatCounter})\r\n        Bar: ${currentBar}\r\n      `;\n        }\n        else {\n            this.divElement.textContent = \"\";\n        }\n    }\n    addControls() {\n        const container = document.createElement(\"div\");\n        container.style.position = \"fixed\";\n        container.style.bottom = \"10px\";\n        container.style.left = \"10px\";\n        container.style.zIndex\n            = \"1000\";\n        document.body.appendChild(container);\n        // Create the slider\n        const slider = document.createElement(\"input\");\n        slider.type = \"range\";\n        slider.min = \"0\";\n        slider.max = this.sequence.durationMs.toString();\n        slider.value = \"0\";\n        slider.style.width = \"400px\";\n        container.appendChild(slider);\n        // Create the play/pause button\n        const playPauseButton = document.createElement(\"button\");\n        playPauseButton.textContent = \"Pause\";\n        container.appendChild(playPauseButton);\n        // Event listeners for slider and button\n        slider.addEventListener(\"input\", () => {\n            const time = parseInt(slider.value, 10);\n            this.sequence.pause(); // Pause the regular animation loop\n            this.sequence.renderAtTime(time); // Render the scene at the specified time\n        });\n        playPauseButton.addEventListener(\"click\", () => {\n            if (this.sequence.isPlaying) {\n                this.sequence.pause();\n                playPauseButton.textContent = \"Play\";\n            }\n            else {\n                this.sequence.play();\n                playPauseButton.textContent = \"Pause\";\n            }\n        });\n    }\n}\nexports.DebugHelper = DebugHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/debugHelper.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/sceneBuilder.js":
/*!**************************************************!*\
  !*** ./build/src/Engine/Helpers/sceneBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneBuilder = void 0;\nconst scene_1 = __webpack_require__(/*! ../scene */ \"./build/src/Engine/scene.js\");\nclass SceneBuilder {\n    /**\n     * Creates a new SceneBuilder to help construct scenes with automatic timing.\n     * @param totalDuration - The total duration of the animation sequence in milliseconds.\n     */\n    constructor(totalDuration) {\n        this.scenes = [];\n        this.currentTime = 0;\n        this.totalDuration = totalDuration;\n    }\n    /**\n     * Adds a scene to the builder with a specified name and duration.\n     * @param name - The name of the scene.\n     * @param duration - The duration of the scene in milliseconds.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    addScene(name, duration) {\n        const startTime = this.currentTime;\n        this.currentTime += duration;\n        // If the current time exceeds the total duration, adjust the last scene's duration\n        if (this.currentTime > this.totalDuration) {\n            const lastScene = this.scenes[this.scenes.length - 1];\n            if (lastScene) {\n                lastScene.durationInMs = this.totalDuration - lastScene.startTimeinMs;\n            }\n            duration = this.totalDuration - startTime; // Adjust the current scene's duration as well\n        }\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this; // For chaining\n    }\n    /**\n     * Gets the array of scenes with their timing configured.\n     * @returns The array of Scene objects.\n     */\n    getScenes() {\n        return this.scenes;\n    }\n    /**\n     * Gets the total duration of all scenes added to the builder.\n     * @returns The total duration in milliseconds.\n     */\n    get totalScenesDuration() {\n        return this.scenes.reduce((total, scene) => total + scene.durationInMs, 0);\n    }\n    /**\n     * Adds a scene to the builder with a specified name and a duration that extends to the end of the total duration.\n     * @param name - The name of the scene.\n     * @returns The SceneBuilder instance for chaining.\n     */\n    durationUntilEndInMs(name) {\n        const startTime = this.currentTime;\n        const duration = this.totalDuration - startTime;\n        const scene = new scene_1.Scene(name, startTime, duration);\n        this.scenes.push(scene);\n        return this;\n    }\n}\nexports.SceneBuilder = SceneBuilder;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/sceneBuilder.js?");

/***/ }),

/***/ "./build/src/Engine/Helpers/sequenceHelper.js":
/*!****************************************************!*\
  !*** ./build/src/Engine/Helpers/sequenceHelper.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SequenceHelper = void 0;\nclass SequenceHelper {\n    /**\n     * Calculates the duration in milliseconds for a given number of beats.\n     * @param bpm - The beats per minute.\n     * @param numBeats - The number of beats.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForBeats(bpm, numBeats) {\n        const millisecondsPerBeat = 60000 / bpm;\n        return numBeats * millisecondsPerBeat;\n    }\n    /**\n     * Calculates the duration in milliseconds for a given number of bars.\n     * @param bpm - The beats per minute.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param numBars - The number of bars.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForBars(bpm, beatsPerBar, numBars) {\n        const millisecondsPerBar = (60000 / bpm) * beatsPerBar;\n        return numBars * millisecondsPerBar;\n    }\n    /**\n     * Calculates the duration in milliseconds for a given number of ticks.\n     * @param bpm - The beats per minute.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param numTicks - The number of ticks.\n     * @returns The duration in milliseconds.\n     */\n    static getDurationForTicks(bpm, ticksPerBeat, numTicks) {\n        const millisecondsPerTick = 60000 / (bpm * ticksPerBeat);\n        return numTicks * millisecondsPerTick;\n    }\n}\nexports.SequenceHelper = SequenceHelper;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/Helpers/sequenceHelper.js?");

/***/ }),

/***/ "./build/src/Engine/ShaderRenderer/shaderRenderer.js":
/*!***********************************************************!*\
  !*** ./build/src/Engine/ShaderRenderer/shaderRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderRenderer = exports.RenderTarget = void 0;\nclass RenderTarget {\n    constructor(gl, textures, customUniforms) {\n        this.textures = new Array();\n        this.locations = new Map();\n        this.framebuffer = gl.createFramebuffer();\n        this.renderbuffer = gl.createRenderbuffer();\n        this.texture = gl.createTexture();\n        this.textures = textures;\n        this.uniforms = customUniforms;\n    }\n}\nexports.RenderTarget = RenderTarget;\nclass ShaderRenderer {\n    /**\n     * Create a Shader\n     *\n     * @param {WebGLProgram} program\n     * @param {number} type\n     * @param {string} source\n     * @memberof DR\n     */\n    createShader(program, type, source) {\n        let gl = this.gl;\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        gl.attachShader(program, shader);\n        if (!gl.getShaderParameter(shader, 35713)) { // this.gl.COMPILE_STATUS\n            // gl.getShaderInfoLog(shader).trim().split(\"\\n\").forEach((l: string) =>\n            //         console.error(\"[shader] \" + l))\n            throw new Error(\"Error while compiling vertex/fragment\" + source);\n        }\n        ;\n    }\n    /**\n     * Create and a WebGLProgram\n     *\n     * @param {string} name\n     * @returns {WebGLProgram}\n     * @memberof DR\n     */\n    addProgram(name) {\n        let p = this.gl.createProgram();\n        this.programs.set(name, { program: p, state: true });\n        return p;\n    }\n    /**\n     *  Create a new WEBGLTexture\n     *\n     * @param {*} data  image or UInt8Array\n     * @returns WebGLTexture\n     * @memberof DR\n     */\n    createTexture(data, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(3553, texture);\n        if (data instanceof Image) {\n            gl.texImage2D(3553, 0, 6408, 6408, 5121, data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        gl.generateMipmap(3553);\n        return texture;\n    }\n    /**\n     * Create a texture cube map\n     *\n     * @param {Array<any>} sources\n     * @param {number} d\n     * @returns {WebGLTexture}\n     * @memberof DR\n     */\n    createTextureCube(sources, d) {\n        let gl = this.gl;\n        let texture = gl.createTexture();\n        gl.activeTexture(33985 + d);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        const fetchAll = (src, key) => {\n            return new Promise(async (resolve, reject) => {\n                const response = await fetch(src);\n                const blob = await response.blob();\n                let image = new Image();\n                image.dataset.key = key;\n                image.onerror = reject;\n                image.onload = () => {\n                    resolve(image);\n                };\n                image.src = src;\n            });\n        };\n        Promise.all(sources.map(i => {\n            return fetchAll(i.d, i.t);\n        })).then(data => {\n            data.forEach(image => {\n                const target = image.dataset.key;\n                const level = 0;\n                const internalFormat = gl.RGBA;\n                const width = 512;\n                const height = 512;\n                const format = gl.RGBA;\n                const type = gl.UNSIGNED_BYTE;\n                gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                gl.texImage2D(target, level, internalFormat, format, type, image);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            });\n        });\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        return texture;\n    }\n    /**\n     * add assets ( textures )\n     *\n     * @param {*} assets\n     * @param {()=>void} cb\n     * @returns {this}\n     * @memberof DR\n     */\n    addAssets(assets, cb) {\n        const cache = (k, v, f) => {\n            this.textureCache.set(k, { src: v, fn: f });\n        };\n        const p = (key, texture, unit) => {\n            return new Promise((resolve) => {\n                if (!texture.src) {\n                    cache(key, this.createTexture(new Uint8Array(1024), unit), texture.fn);\n                    resolve(key);\n                }\n                else {\n                    if (!Array.isArray(texture.src)) {\n                        const i = new Image();\n                        i.onload = (e) => {\n                            cache(key, this.createTexture(i, unit), null);\n                            resolve(key);\n                        };\n                        i.src = texture.src;\n                    }\n                    else {\n                        cache(key, this.createTextureCube(texture.src, unit), texture.fn);\n                        resolve(key);\n                    }\n                }\n            });\n        };\n        Promise.all(Object.keys(assets).map((key, index) => {\n            return p(key, assets[key], index);\n        })).then((result) => {\n            cb(result);\n        }).catch((err) => {\n            console.error(err);\n        });\n        return this;\n    }\n    /**\n     * add a new buffer / shader program\n     *\n     * @param {string} name\n     * @param {string} vertex\n     * @param {string} fragment\n     * @param {Array<string>} [textures]\n     * @param {*} [customUniforms]\n     * @returns {this}\n     * @memberof DR\n     */\n    addBuffer(name, vertex, fragment, textures, customUniforms) {\n        let gl = this.gl;\n        let tA = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        let tB = this.createTarget(this.canvas.width, this.canvas.height, textures ? textures : [], customUniforms ? customUniforms : {});\n        this.targets.set(name, tA);\n        this.targets.set(`_${name}`, tB);\n        let program = this.addProgram(name);\n        this.createShader(program, 35633, this.header + vertex);\n        this.createShader(program, 35632, this.header + fragment);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw `Could not compile ${name} program. \\n\\n${info}`;\n        }\n        gl.useProgram(program);\n        if (textures) {\n            textures.forEach((tk) => {\n                gl.bindTexture(3553, this.textureCache.get(tk).src);\n            });\n        }\n        this.vertexPosition = gl.getAttribLocation(program, \"pos\");\n        gl.enableVertexAttribArray(this.vertexPosition);\n        for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(program, i);\n            tA.locations.set(u.name, gl.getUniformLocation(program, u.name));\n        }\n        return this;\n    }\n    /**\n     * Set program state ( enable / or disable)\n     *\n     * @param {string} key\n     * @param {boolean} state\n     * @memberof DR\n     */\n    setProgramState(key, state) {\n        this.programs.get(key).state = state;\n    }\n    /**\n     * Render\n     *\n     * @param {number} time\n     * @memberof DR\n     */\n    update(time) {\n        let gl = this.gl;\n        let main = this.mainProgram;\n        let tc = 0;\n        this.programs.forEach((l, key) => {\n            if (!l.state)\n                return; // do not render \n            const current = l.program;\n            let fT = this.targets.get(key);\n            let bT = this.targets.get(`_${key}`);\n            gl.useProgram(current);\n            // resolution, time\n            gl.uniform2f(fT.locations.get(\"resolution\"), this.canvas.width, this.canvas.height);\n            gl.uniform1f(fT.locations.get(\"time\"), time);\n            gl.uniform1f(fT.locations.get(\"deltaTime\"), this.frameCount);\n            gl.uniform1f(fT.locations.get(\"frame\"), this.frameCount);\n            let customUniforms = fT.uniforms;\n            customUniforms && Object.keys(customUniforms).forEach((v) => {\n                customUniforms[v](fT.locations.get(v), gl, current, time);\n            });\n            let bl = gl.getUniformLocation(current, key); // todo: get this from cache?\n            gl.uniform1i(bl, 0);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bT.texture);\n            fT.textures.forEach((tk, index) => {\n                let ct = this.textureCache.get(tk);\n                gl.activeTexture(33985 + index);\n                gl.bindTexture(gl.TEXTURE_2D, ct.src);\n                if (ct.fn)\n                    ct.fn(!current, gl, ct.src);\n                let loc = gl.getUniformLocation(!current, tk); // todo: get this from cache?  \n                gl.uniform1i(loc, index + 1);\n                tc++;\n            });\n            gl.bindBuffer(34962, this.surfaceBuffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindBuffer(34962, this.buffer);\n            gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n            gl.bindFramebuffer(36160, fT.framebuffer);\n            gl.clear(16384 | 256);\n            gl.drawArrays(4, 0, 6);\n            bT = fT;\n            fT = bT;\n        });\n        gl.useProgram(main);\n        gl.uniform2f(this.mainUniforms.get(\"resolution\"), this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.mainUniforms.get(\"time\"), time);\n        // todo:  set up a cache for custom uniforms\n        Object.keys(this.cU).forEach((v) => {\n            this.cU[v](gl.getUniformLocation(main, v), gl, main, time); // todo: use cached locations\n        });\n        gl.bindBuffer(34962, this.buffer);\n        gl.vertexAttribPointer(0, 2, 5126, false, 0, 0);\n        this.targets.forEach((target, key) => {\n            gl.uniform1i(gl.getUniformLocation(main, key), tc); // todo: use cached locations\n            gl.activeTexture(33984 + tc);\n            gl.bindTexture(3553, target.texture);\n            tc++;\n        });\n        gl.bindFramebuffer(36160, null);\n        gl.clear(16384 | 256);\n        gl.drawArrays(4, 0, 6);\n        this.frameCount++;\n        this.deltaTime = -(this.deltaTime - time);\n    }\n    /**\n     * Create render target\n     *\n     * @param {number} width\n     * @param {number} height\n     * @param {Array<string>} textures\n     * @returns {*}\n     * @memberof DR\n     */\n    createTarget(width, height, textures, customUniforms) {\n        let gl = this.gl;\n        let target = new RenderTarget(gl, textures, customUniforms);\n        gl.bindTexture(3553, target.texture);\n        gl.texImage2D(3553, 0, 6408, width, height, 0, 6408, 5121, null);\n        gl.texParameteri(3553, 10242, 33071);\n        gl.texParameteri(3553, 10243, 33071);\n        gl.texParameteri(3553, 10240, 9728);\n        gl.texParameteri(3553, 10241, 9728);\n        gl.bindFramebuffer(36160, target.framebuffer);\n        gl.framebufferTexture2D(36160, 36064, 3553, target.texture, 0);\n        gl.bindRenderbuffer(36161, target.renderbuffer);\n        gl.renderbufferStorage(36161, 33189, width, height);\n        gl.framebufferRenderbuffer(36160, 36096, 36161, target.renderbuffer);\n        gl.bindTexture(3553, null);\n        gl.bindRenderbuffer(36161, null);\n        gl.bindFramebuffer(36160, null);\n        return target;\n    }\n    /**\n     * Render loop\n     *\n     * @param {number} t\n     * @param {number} fps\n     * @returns {this}\n     * @memberof DR\n     */\n    run(t, fps) {\n        let pt = performance.now();\n        let interval = 1000 / fps;\n        let dt = 0;\n        const a = (t) => {\n            requestAnimationFrame(a);\n            dt = t - pt;\n            if (dt > interval) {\n                pt = t - (dt % interval);\n                this.update(pt / 1000);\n            }\n        };\n        a(t | 0);\n        return this;\n    }\n    constructor(canvas, v, f, cU = {}) {\n        this.canvas = canvas;\n        this.cU = cU;\n        this.vertexPosition = 0;\n        this.frameCount = 0;\n        this.deltaTime = 0;\n        this.header = `#version 300 es\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n#endif\r\n`;\n        this.targets = new Map();\n        this.mainUniforms = new Map();\n        this.programs = new Map();\n        this.textureCache = new Map();\n        let gl = canvas.getContext(\"webgl2\", { preserveDrawingBuffer: true });\n        this.gl = gl;\n        let mp = gl.createProgram();\n        this.mainProgram = mp;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        this.buffer = gl.createBuffer();\n        this.surfaceBuffer = gl.createBuffer();\n        this.createShader(mp, 35633, this.header + v);\n        this.createShader(mp, 35632, this.header + f);\n        gl.linkProgram(mp);\n        gl.validateProgram(mp);\n        if (!gl.getProgramParameter(mp, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(mp);\n            throw 'Could not compile main program. \\n\\n' + info;\n        }\n        gl.useProgram(mp);\n        for (let i = 0; i < gl.getProgramParameter(mp, gl.ACTIVE_UNIFORMS); ++i) {\n            const u = gl.getActiveUniform(mp, i);\n            const loc = gl.getUniformLocation(mp, u.name);\n            this.mainUniforms.set(u.name, loc);\n        }\n        this.screenVertexPosition = gl.getAttribLocation(mp, \"pos\");\n        gl.enableVertexAttribArray(this.screenVertexPosition);\n        gl.bindBuffer(34962, this.buffer);\n        gl.bufferData(34962, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), 35044);\n    }\n    /**\n     *  Generate a texture and return a canvas element\n     *\n     * @static\n     * @param {string} mainVertex\n     * @param {string} mainFrag\n     * @param {string} textureVertex\n     * @param {*} textureFrag\n     * @param {number} w\n     * @param {number} h\n     * @returns {HTMLCanvasElement}\n     * @memberof DR\n     */\n    static generateTexture(mainVertex, mainFrag, textureVertex, textureFrag, w, h) {\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = w;\n        canvas.height = h;\n        let dr = new ShaderRenderer(canvas, mainVertex, mainFrag);\n        dr.addBuffer(\"A\", textureVertex, textureFrag);\n        // do a few frames due to back buffer.\n        for (var i = 0; i < 2; i++) {\n            dr.update(i);\n        }\n        return canvas;\n    }\n}\nexports.ShaderRenderer = ShaderRenderer;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/ShaderRenderer/shaderRenderer.js?");

/***/ }),

/***/ "./build/src/Engine/conductor.js":
/*!***************************************!*\
  !*** ./build/src/Engine/conductor.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Conductor = void 0;\nclass Conductor {\n    constructor() {\n        this.events = [];\n        this.currentTime = 0;\n    }\n    /**\n     * Adds an event to the timeline.\n     * @param event - The event to add.\n     */\n    addEvent(event) {\n        this.events.push(event);\n    }\n    /**\n     * Updates the current time of the timeline.\n     * @param time - The current time in milliseconds.\n     */\n    updateTime(time) {\n        this.currentTime = time;\n    }\n    triggerEvents(sequence) {\n        this.events.forEach(event => {\n            var _a;\n            const { time, beatCount, barCount, action, targetEntity, criteria, props } = event;\n            // Check if the event should be triggered\n            const timeCondition = time !== undefined ? this.currentTime >= time : true; // True if time is not specified\n            const beatCondition = beatCount !== undefined ? sequence.beatCounter >= beatCount : true; // True if beatCount is not specified\n            const barCondition = barCount !== undefined ? sequence.currentBar >= barCount : true; // True if barCount is not specified\n            const criteriaResult = criteria ? criteria() : true;\n            // Combine all conditions\n            if ((timeCondition && beatCondition && barCondition) && // All specified conditions must be true\n                criteriaResult // Criteria must also be true (if provided)\n            ) {\n                const entity = (_a = sequence.currentScene) === null || _a === void 0 ? void 0 : _a.entities.find(e => e.name === targetEntity);\n                if (entity) {\n                    action(entity, props, criteriaResult);\n                }\n            }\n        });\n    }\n}\nexports.Conductor = Conductor;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/conductor.js?");

/***/ }),

/***/ "./build/src/Engine/entity.js":
/*!************************************!*\
  !*** ./build/src/Engine/entity.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Entity = void 0;\nconst EngineLogger_1 = __webpack_require__(/*! ./EngineLogger */ \"./build/src/Engine/EngineLogger.js\");\nclass Entity {\n    /**\n     * Creates a new Entity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity.\n     * @param action - The action function that defines the entity's behavior.\n     */\n    constructor(name, props, action, startTimeinMs, durationInMs, w, h) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.w = w;\n        this.h = h;\n        this.postProcessors = [];\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w !== undefined && h !== undefined) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        ;\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    bindToScene(scene) {\n        this.scene = scene;\n    }\n    /**\n    * Adds an event listener for when a beat occurs.\n    * @param listener - The function to call when a beat occurs.\n    * @returns The Entity instance for chaining.\n    */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a post-processing function to the entity.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Copies the entity's canvas to the target canvas and applies post-processors.\n     * @param targetCanvas - The target canvas to copy to.\n     * @param sequence - The Sequence instance.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n                this.postProcessors.forEach(processor => processor(targetCtx, sequence));\n            }\n        }\n    }\n    /**\n    * Updates the entity's state, clears the canvas, and calls the action function.\n    * @param timeStamp - The current timestamp in the animation.\n    */\n    update(timeStamp) {\n        var _a;\n        (_a = this.ctx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.action && this.ctx && this.props) {\n            // Calculate elapsed time relative to the scene's start time    \n            const sceneStartTime = this.getScene().startTimeinMs || 0;\n            const elapsed = timeStamp - sceneStartTime - (this.startTimeinMs || 0);\n            // Log the timing information for debugging\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.ctx, this.props);\n            }\n            else {\n                EngineLogger_1.EngineLogger.log(`entity ${this.name} should not render, postponed by ${this.startTimeinMs} relative to scene starttime which is ${sceneStartTime}`);\n            }\n        }\n    }\n    /**\n   * Retrieves the Sequence instance associated with the entity.\n   * @returns The Sequence instance if available, otherwise null.\n   */\n    getScene() {\n        return this.scene;\n    }\n}\nexports.Entity = Entity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/entity.js?");

/***/ }),

/***/ "./build/src/Engine/scene.js":
/*!***********************************!*\
  !*** ./build/src/Engine/scene.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst entity_1 = __webpack_require__(/*! ./entity */ \"./build/src/Engine/entity.js\");\nclass Scene {\n    /**\n     * Creates a new Scene.\n     * @param name - The name or identifier for the scene.\n     * @param startTimeinMs - The start time of the scene in milliseconds.\n     * @param durationInMs - The duration of the scene in milliseconds.\n     */\n    constructor(name, startTimeinMs, durationInMs, width, height) {\n        this.name = name;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.width = width;\n        this.height = height;\n        this.entities = [];\n        this.transitionOutListeners = [];\n        this.transitionInListeners = [];\n    }\n    /**\n     * Adds an entity to the scene.\n     * @param entity - The entity to add.\n     */\n    addEntity(entity) {\n        // If the entity's canvas dimensions are not set, use the scene's dimensions\n        if (!entity.w && !entity.h) {\n            entity.canvas.width = this.width || 800;\n            entity.canvas.height = this.height || 450;\n        }\n        entity.bindToScene(this);\n        this.entities.push(entity);\n    }\n    /**\n     * Adds multiple entities to the scene.\n     * @param entities - An array of entities to add.\n     * @returns The Scene instance for chaining.\n     */\n    addEntities(...entities) {\n        entities.forEach(entity => this.addEntity(entity));\n        return this;\n    }\n    /**\n     * Gets an entity from the scene by its key.\n     * @param key - The key of the entity to retrieve.\n     * @returns The entity if found, otherwise undefined.\n     */\n    getEntity(key) {\n        return this.entities.find(entity => entity.name === key);\n    }\n    /**\n     * Plays the scene by animating its entities.\n     * @param elapsedTime - The elapsed time in the animation sequence.\n     * @returns A promise that resolves when the scene has finished playing.\n     */\n    // play(elapsedTime: number): Promise<boolean> {\n    //   return new Promise((resolve) => {\n    //     const startTime = performance.now();\n    //     const animate = () => {\n    //       const currentTime = performance.now();\n    //       const sceneElapsedTime = currentTime - startTime + elapsedTime;\n    //       const adjustedSceneElapsedTime = sceneElapsedTime - this.startTimeinMs;\n    //       if (adjustedSceneElapsedTime >= 0) {\n    //         this.entities.forEach((entity) => {\n    //           entity.update(sceneElapsedTime);\n    //         });\n    //       }\n    //       if (sceneElapsedTime < this.durationInMs + this.startTimeinMs) {\n    //         // The requestAnimationFrame call was removed here. \n    //         // The animation loop is now handled in the Sequence class.\n    //       } else {\n    //         resolve(true);\n    //       }\n    //     };\n    //     animate(); // Call animate once to start the initial rendering\n    //   });\n    // }\n    addPostProcessorToEntities(processor) {\n        this.entities.forEach(entity => {\n            if (entity instanceof entity_1.Entity) { // Check if the entity is an instance of the Entity class\n                entity.addPostProcessor(processor);\n            }\n        });\n    }\n    /**\n      * Adds a transition-in effect to the scene.\n      * @param sequence - The Sequence instance associated with the scene.\n      * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n      * @param duration - The duration of the transition in milliseconds.\n      * @param listener - The transition function to apply.\n      */\n    transitionIn(sequence, startTime, duration, listener) {\n        this.transitionInListeners.push(listener);\n        sequence.addSceneTransitionIn(this, startTime, duration, (ctx, scene, progress) => {\n            this.transitionInListeners.forEach(listener => listener(ctx, scene, progress));\n        });\n    }\n    /**\n    * Adds a transition-out effect to the scene.\n    * @param sequence - The Sequence instance associated with the scene.\n    * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n    * @param duration - The duration of the transition in milliseconds.\n    * @param listener - The transition function to apply.\n    */\n    transitionOut(sequence, startTime, duration, listener) {\n        this.transitionOutListeners.push(listener);\n        sequence.addSceneTransitionOut(this, startTime, duration, (ctx, scene, progress) => {\n            this.transitionOutListeners.forEach(listener => listener(ctx, scene, progress));\n        });\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/scene.js?");

/***/ }),

/***/ "./build/src/Engine/sequence.js":
/*!**************************************!*\
  !*** ./build/src/Engine/sequence.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Sequence = void 0;\nclass Sequence {\n    /**\n* Sets the function to be used for resetting the rendering context when switching scenes.\n* @param resetFunction - The function to call to reset the context.\n*/\n    setContextResetFunction(resetFunction) {\n        this.resetContext = resetFunction;\n    }\n    /**\n     * Adds a transition-out listener for a specific scene.\n     * @param scene - The scene to add the listener to.\n     * @param startTime - The time (in milliseconds) relative to the end of the scene when the transition should start.\n     * @param listener - The transition function to apply.\n     */\n    addSceneTransitionOut(scene, startTime, duration, listener) {\n        this.sceneTransitionOutListeners.push({ scene, startTime, duration, listener });\n    }\n    /**\n     * Adds a transition-in listener for a specific scene.\n     * @param scene - The scene to add the listener to.\n     * @param startTime - The time (in milliseconds) within the scene when the transition should start.\n     * @param listener - The transition function to apply.\n     */\n    addSceneTransitionIn(scene, startTime, duration, listener) {\n        this.sceneTransitionInListeners.push({ scene, startTime, duration, listener });\n    }\n    /**\n     * Adds a post-processing function to the sequence.\n     * @param processor - The post-processing function to add.\n     */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Gets the remaining time in the current scene.\n     * @param timeStamp - The current timestamp in the animation.\n     * @returns The remaining time in milliseconds.\n     */\n    getSceneRemainingTime(timeStamp) {\n        if (!this.currentScene) {\n            return 0;\n        }\n        const elapsedTime = timeStamp - this.currentScene.startTimeinMs;\n        return Math.max(0, this.currentScene.durationInMs - elapsedTime);\n    }\n    /**\n     * Creates a new Sequence.\n     * @param target - The canvas element to render the animation on.\n     * @param bpm - The beats per minute for the animation.\n     * @param ticksPerBeat - The number of ticks per beat.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param beatsPerBar - The number of beats per bar.\n     * @param scenes - An array of scenes to include in the sequence.\n     * @param audioFile - An array of scenes to include in the sequence.\n     * @param audioLoader\n    \n     \n     */\n    constructor(target, bpm = 120, ticksPerBeat = 4, beatsPerBar = 4, scenes, audioLoader) {\n        this.target = target;\n        this.durationMs = 0;\n        this.scenes = [];\n        this.currentSceneIndex = 0;\n        this.isPlaying = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.bpm = 0;\n        this.ticksPerBeat = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBar = 0;\n        this.tickCounter = 0;\n        this.beatCounter = 0;\n        this.beatsPerBar = 0;\n        this.currentBeat = 0;\n        this.previousBeat = 0; // Store the previous beat value\n        this.previousTick = 0; // Store the previous tick value\n        this.previousBar = 0; // Store the previous bar value\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.frameListeners = [];\n        this.postProcessors = [];\n        this.sceneTransitionInListeners = [];\n        this.sceneTransitionOutListeners = [];\n        this.resetContext = (ctx) => {\n            ctx.globalAlpha = 1; // Default reset function\n        };\n        this.scenes = scenes || [];\n        this.targetCtx = target.getContext(\"2d\");\n        this.bpm = bpm;\n        this.ticksPerBeat = ticksPerBeat;\n        this.beatsPerBar = beatsPerBar;\n        this.audioContext = new AudioContext();\n        this.analyser = this.audioContext.createAnalyser();\n        audioLoader.loadAudio(this.audioContext)\n            .then(audioBuffer => {\n            this.audioBuffer = audioBuffer;\n            this.onReady();\n        })\n            .catch(error => console.error(\"Error loading audio:\", error));\n        this.recalculateDuration();\n    }\n    /**\n     * Called when the audio file is loaded or when no audio is used.\n     */\n    onReady() { }\n    /**\n     * Adds an event listener for each frame.\n     * @param listener - The function to call on each frame.\n     */\n    onFrame(listener) {\n        this.frameListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a beat occurs.\n     * @param listener - The function to call when a beat occurs.\n     */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n    }\n    /**\n     * Adds a scene to the sequence.\n     * @param scene - The scene to add.\n     */\n    addScene(scene) {\n        if (!scene.width && scene.height) {\n            scene.width = this.target.width;\n            scene.height = this.target.height;\n        }\n        this.scenes.push(scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Adds multiple scenes to the sequence.\n     * @param scenes - The scenes to add.\n     * @returns The Sequence instance for chaining.\n     */\n    addScenes(...scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n    * Adds multiple scenes to the sequence.\n    * @param scenes - The scenes to add.\n    * @returns The Sequence instance for chaining.\n    */\n    addSceneArray(scenes) {\n        this.scenes.push(...scenes);\n        this.recalculateDuration();\n        return this;\n    }\n    /**\n     * Removes a scene from the sequence.\n     * @param scene - The scene to remove.\n     */\n    removeScene(scene) {\n        this.scenes = this.scenes.filter((s) => s !== scene);\n        this.recalculateDuration();\n    }\n    /**\n     * Recalculates the total duration of the sequence.\n     */\n    recalculateDuration() {\n        this.durationMs = 0;\n        if (this.scenes.length > 0) {\n            this.durationMs = Math.max(...this.scenes.map((scene) => {\n                return scene.startTimeinMs + scene.durationInMs;\n            }));\n        }\n    }\n    /**\n     * Render a specific time\n     *\n     * @param {number} time\n     * @memberof Sequence\n     */\n    renderAtTime(time) {\n        var _a;\n        this.currentTime = time; // Update the currentTime\n        // Find the active scene for the given time\n        const currentSceneIndex = this.scenes.findIndex(scene => time >= scene.startTimeinMs && time < scene.startTimeinMs + scene.durationInMs);\n        if (currentSceneIndex !== -1) {\n            this.currentSceneIndex = currentSceneIndex;\n            const elapsedTime = time - this.currentScene.startTimeinMs;\n            // Update and draw entities\n            (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n            this.currentScene.entities.forEach(entity => {\n                entity.update(time);\n                if (this.target) {\n                    entity.copyToCanvas(this.target, this);\n                }\n            });\n            // Apply post-processing\n            if (this.targetCtx) {\n                this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n            }\n            this.triggerEventsForTime(time);\n        }\n    }\n    /**\n * Triggers beat, tick, and bar listeners for a given time.\n * @param time - The time in milliseconds.\n */\n    triggerEventsForTime(time) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        // Calculate beat, tick, and bar values for the given time\n        const beat = Math.floor(time / beatIntervalMs) + 1;\n        const tick = Math.floor((time % beatIntervalMs) / tickIntervalMs);\n        const bar = Math.floor(beat / this.beatsPerBar) + 1;\n        // Trigger listeners if the values have changed\n        if (beat !== this.currentBeat) {\n            this.currentBeat = beat;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, time, this.beatCounter));\n            this.beatCounter++;\n        }\n        if (tick !== this.currentTick) {\n            this.currentTick = tick;\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, time, this.tickCounter));\n            this.tickCounter++;\n        }\n        if (bar !== this.currentBar) {\n            this.currentBar = bar;\n            this.barListeners.forEach(listener => listener(this.currentBar));\n        }\n        // Trigger frame listeners\n        this.frameListeners.forEach(listener => listener(this.currentSceneIndex, time));\n    }\n    /**\n     * Starts the animation sequence.\n     */\n    play() {\n        this.isPlaying = true;\n        this.currentSceneIndex = 0;\n        this.lastBeatTime = 0;\n        this.currentTick = 0;\n        this.currentBeat = 0; // Initialize currentBeat to 0\n        this.startTime = performance.now();\n        if (this.audioBuffer) {\n            this.audioSource = this.audioContext.createBufferSource();\n            this.audioSource.buffer = this.audioBuffer;\n            this.audioSource.connect(this.analyser);\n            this.analyser.connect(this.audioContext.destination);\n            this.fftData = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioSource.start();\n        }\n        const animate = (ts) => {\n            const adjustedTimeStamp = ts - this.startTime;\n            this.playCurrentScene(adjustedTimeStamp);\n            if (this.isPlaying) {\n                this.requestAnimationFrameID = requestAnimationFrame(animate);\n            }\n        };\n        this.requestAnimationFrameID = requestAnimationFrame(animate);\n    }\n    /**\n     * Pauses\n   the animation sequence.\n     */\n    pause() {\n        this.isPlaying = false;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Stops the animation sequence.\n     */\n    stop() {\n        this.isPlaying = false;\n        this.currentSceneIndex = 0;\n        cancelAnimationFrame(this.requestAnimationFrameID);\n    }\n    /**\n     * Gets the current scene being played.\n     * @returns The current Scene or undefined if no scene is active.\n     */\n    get currentScene() {\n        return this.scenes[this.currentSceneIndex];\n    }\n    /**\n  * Animates the current scene and handles scene transitions,\n  * audio analysis, and beat/tick events.\n  * @param timeStamp - The adjusted timestamp for the current frame.\n  */\n    playCurrentScene(timeStamp) {\n        var _a;\n        if (!this.isPlaying) {\n            return;\n        }\n        this.currentTime = timeStamp; // Update currentTime\n        // Determine the current scene based on timeStamp\n        let currentSceneIndex = this.scenes.findIndex(scene => timeStamp >= scene.startTimeinMs && timeStamp < scene.startTimeinMs + scene.durationInMs);\n        // If no current scene is found, check for upcoming scenes\n        if (currentSceneIndex === -1) {\n            currentSceneIndex = this.scenes.findIndex(scene => timeStamp < scene.startTimeinMs);\n            if (currentSceneIndex === -1) { // No upcoming scene, end animation\n                this.isPlaying = false;\n                return;\n            }\n            else { // Wait for the upcoming scene\n                return;\n            }\n        }\n        // If the scene has changed, update currentSceneIndex and play the new scene\n        if (this.currentSceneIndex !== currentSceneIndex) {\n            this.currentSceneIndex = currentSceneIndex;\n            // Reset the rendering context\n            this.resetContext(this.targetCtx);\n            // Set scene dimensions if not already set\n            if (!this.currentScene.width) {\n                this.currentScene.width = this.target.width;\n            }\n            if (!this.currentScene.height) {\n                this.currentScene.height = this.target.height;\n            }\n        }\n        // FFT analysis (if analyser is available)\n        if (this.analyser) {\n            this.analyser.getByteFrequencyData(this.fftData);\n        }\n        // Clear the target canvas and update/draw entities\n        (_a = this.targetCtx) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, this.target.width, this.target.height);\n        this.currentScene.entities.forEach(entity => {\n            var _a, _b;\n            // Update the conductor's time and trigger events\n            (_a = this.conductor) === null || _a === void 0 ? void 0 : _a.updateTime(timeStamp);\n            (_b = this.conductor) === null || _b === void 0 ? void 0 : _b.triggerEvents(this);\n            entity.update(timeStamp);\n            if (this.target) {\n                entity.copyToCanvas(this.target, this);\n            }\n            // Trigger entity events only when the values change\n            if (this.currentBeat !== this.previousBeat) {\n                entity.beatListeners.forEach(listener => listener(timeStamp, this.beatCounter, entity.props));\n                this.previousBeat = this.currentBeat;\n            }\n            if (this.currentTick !== this.previousTick) {\n                entity.tickListeners.forEach(listener => listener(timeStamp, this.tickCounter, entity.props));\n                this.previousTick = this.currentTick;\n            }\n            if (this.currentBar !== this.previousBar) {\n                entity.barListeners.forEach(listener => listener(timeStamp, this.currentBar, entity.props));\n                this.previousBar = this.currentBar;\n            }\n        });\n        // Apply post-processing effects\n        if (this.targetCtx) {\n            this.postProcessors.forEach(processor => processor(this.targetCtx, this));\n        }\n        this.sceneTransitionInListeners.forEach(({ scene, startTime, duration, listener }) => {\n            if (scene === this.currentScene) {\n                const sceneElapsedTime = this.currentTime - scene.startTimeinMs;\n                if (sceneElapsedTime >= startTime && sceneElapsedTime <= startTime + duration) {\n                    const transitionProgress = (sceneElapsedTime - startTime) / duration; // Calculate progress based on duration\n                    listener(this.targetCtx, scene, transitionProgress);\n                }\n            }\n        });\n        this.sceneTransitionOutListeners.forEach(({ scene, startTime, duration, listener }) => {\n            if (scene === this.currentScene) {\n                const sceneElapsedTime = this.currentTime - scene.startTimeinMs;\n                if (sceneElapsedTime >= startTime && sceneElapsedTime <= startTime + duration) {\n                    const transitionProgress = (sceneElapsedTime - startTime) / duration; // Calculate progress based on duration\n                    listener(this.targetCtx, scene, transitionProgress);\n                }\n            }\n        });\n        this.handleBeatAndTickEvents(timeStamp); // Handle beat and tick events\n        // Trigger frame listeners\n        this.frameListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp));\n    }\n    /**\n     * Handles beat and tick events based on the current timestamp.\n     * @param timeStamp - The adjusted timestamp for the current frame.\n     */\n    handleBeatAndTickEvents(timeStamp) {\n        const beatIntervalMs = 60000 / this.bpm;\n        const tickIntervalMs = beatIntervalMs / this.ticksPerBeat;\n        if (timeStamp - this.lastBeatTime >= beatIntervalMs) {\n            this.lastBeatTime = timeStamp;\n            this.beatListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.beatCounter));\n            this.currentTick = 0;\n            this.currentBeat++;\n            this.beatCounter++;\n            if (this.currentBeat > this.beatsPerBar) {\n                this.currentBar++;\n                this.currentBeat = 1;\n                this.barListeners.forEach(listener => listener(this.currentBar));\n            }\n        }\n        if (timeStamp - this.lastBeatTime >= this.currentTick * tickIntervalMs) {\n            this.tickListeners.forEach(listener => listener(this.currentSceneIndex, timeStamp, this.tickCounter));\n            this.currentTick++;\n            this.tickCounter++;\n        }\n    }\n}\nexports.Sequence = Sequence;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/sequence.js?");

/***/ }),

/***/ "./build/src/Engine/shaderEntity.js":
/*!******************************************!*\
  !*** ./build/src/Engine/shaderEntity.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShaderEntity = void 0;\nconst shaderRenderer_1 = __webpack_require__(/*! ./ShaderRenderer/shaderRenderer */ \"./build/src/Engine/ShaderRenderer/shaderRenderer.js\");\nclass ShaderEntity {\n    /**\n     * Creates a new ShaderEntity.\n     * @param name - The key or identifier for the entity.\n     * @param w - The width of the entity's canvas.\n     * @param h - The height of the entity's canvas.\n     * @param props - The properties for the entity, including shader code and render buffers.\n     * @param action - An optional action function to be called before rendering the shaders.\n     */\n    constructor(name, props, action, w, h, startTimeinMs, durationInMs) {\n        this.name = name;\n        this.props = props;\n        this.action = action;\n        this.w = w;\n        this.h = h;\n        this.startTimeinMs = startTimeinMs;\n        this.durationInMs = durationInMs;\n        this.beatListeners = [];\n        this.tickListeners = [];\n        this.barListeners = [];\n        this.postProcessors = [];\n        this.canvas = document.createElement(\"canvas\");\n        if (w && h) {\n            this.canvas.width = w;\n            this.canvas.height = h;\n        }\n        if ((props === null || props === void 0 ? void 0 : props.mainFragmentShader) && props.mainVertexShader) {\n            this.shaderRenderer = new shaderRenderer_1.ShaderRenderer(this.canvas, props === null || props === void 0 ? void 0 : props.mainVertexShader, props === null || props === void 0 ? void 0 : props.mainFragmentShader);\n            props.renderBuffers.forEach(buffer => {\n                this.shaderRenderer.addBuffer(buffer.name, buffer.vertex, buffer.fragment, buffer.textures, buffer.customUniforms);\n            });\n        }\n        else {\n            throw new Error(\"Cannot create ShaderEntity: Missing main shader code.\");\n        }\n    }\n    bindToScene(scene) {\n        this.scene = scene;\n    }\n    /**\n * Adds an event listener for when a beat occurs.\n * @param listener - The function to call when a beat occurs.\n * @returns The Entity instance for chaining.\n */\n    onBeat(listener) {\n        this.beatListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a tick occurs.\n     * @param listener - The function to call when a tick occurs.\n     * @returns The Entity instance for chaining.\n     */\n    onTick(listener) {\n        this.tickListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds an event listener for when a bar is complete.\n     * @param listener - The function to call when a bar is complete.\n     * @returns The Entity instance for chaining.\n     */\n    onBar(listener) {\n        this.barListeners.push(listener);\n        return this;\n    }\n    /**\n * Adds a post-processing function to the entity.\n * @param processor - The post-processing function to add.\n */\n    addPostProcessor(processor) {\n        this.postProcessors.push(processor);\n    }\n    /**\n     * Updates the ShaderEntity by calling the action function (if provided)\n     * and then updating the ShaderRenderer.\n     * @param timeStamp - The current timestamp in the animation.\n     */\n    update(timeStamp) {\n        if (this.action && this.shaderRenderer && this.props) {\n            // Calculate elapsed time relative to the scene's start time\n            const sceneStartTime = this.scene ? this.scene.startTimeinMs : 0;\n            const elapsed = timeStamp - sceneStartTime - (this.startTimeinMs || 0);\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                this.action(timeStamp, this.shaderRenderer, this.props);\n                // Calculate shader time relative to the entity's start time (within the scene)\n                const shaderTime = Math.max(0, elapsed);\n                this.shaderRenderer.update(shaderTime / 1000);\n            }\n        }\n    }\n    /**\n     * Copies the entity's canvas to the target canvas.\n     * @param targetCanvas - The target canvas to copy to.\n     */\n    copyToCanvas(targetCanvas, sequence) {\n        const targetCtx = targetCanvas.getContext(\"2d\");\n        if (targetCtx) {\n            // Calculate the elapsed time for the entity\n            const elapsed = sequence.currentTime - (this.startTimeinMs || 0);\n            // Check if the entity should be rendered based on its lifetime\n            if (elapsed >= 0 && elapsed <= (this.durationInMs || Infinity)) {\n                targetCtx.drawImage(this.canvas, 0, 0);\n            }\n        }\n    }\n}\nexports.ShaderEntity = ShaderEntity;\n\n\n//# sourceURL=webpack://demolished-rail/./build/src/Engine/shaderEntity.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/blackholeShader.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/blackholeShader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.blackholeShader = void 0;\nexports.blackholeShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform float zoom;\r\nout vec4 fragColor;\r\n\r\n#define f(a) exp( -10.* pow( length( U -.52*cos(a+vec2(0,33)) ) , 2. ) )\r\n\r\nvoid mainImage( out vec4 O, vec2 u )\r\n{\r\n    float zoomFactor = zoom;\r\n\r\n    vec2  R = resolution.xy,\r\n          U = ( u+u - R ) / R.y ;\r\n    \r\n    O =   ( .5-.5*cos(min(6.*length(U),6.3)) ) \r\n        * (    .7* vec4(1,.25,0,0)\r\n            + ( f(.65)+f(1.6)+f(2.8) ) * vec4(.8,.8,.5,0) );\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/blackholeShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/cosmicCycleShader.js":
/*!***********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/cosmicCycleShader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cosmicCycleShader = void 0;\nexports.cosmicCycleShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform float NUM_LAYERS;\r\nout vec4 fragColor;\r\n\r\n\r\n\r\nmat2 Rot(float a) {\r\n    float s=sin(a), c=cos(a);\r\n    return mat2(c,-s,s,c);\r\n}\r\n\r\nfloat Star(vec2 uv, float a, float sparkle) {\r\n    vec2 av1 = abs(uv);\r\n \tvec2 av2 = abs(uv*Rot(a));\r\n    vec2 av = min(av1, av2);\r\n    \r\n    vec3 col = vec3(0);\r\n    float d = length(uv);\r\n    float star = av1.x*av1.y;\r\n    star = max(av1.x*av1.y, av2.x*av2.y);\r\n    star = max(0., 1.-star*1e3);\r\n    \r\n    float m = min(5., 1e-2/d);\r\n    \r\n    return m+pow(star, 4.)*sparkle;\r\n}\r\n\r\nfloat Hash21(vec2 p) {\r\n    p = fract(p*vec2(123.34,145.54));\r\n    p += dot(p, p+45.23);\r\n    return fract(p.x*p.y);\r\n}\r\n\r\nvec3 StarLayer(vec2 uv, float t, float sparkle) {\r\n    vec2 gv = fract(uv)-.5;\r\n    vec2 id = floor(uv);\r\n\tvec3 col = vec3(0);\r\n    \r\n    #ifndef BURST\r\n    t = 0.;\r\n    #endif\r\n    \r\n    for(int y=-1; y<=1; y++) {\r\n        for(int x=-1; x<=1; x++) {\r\n            vec2 offs = vec2(x, y);\r\n            float n = Hash21(id-offs);\r\n\t\t\tvec3 N = fract(n*vec3(10,100,1000));\r\n            vec2 p = (N.xy-.5)*.7;\r\n            \r\n            float brightness = Star(gv-p+offs, n*6.2831+t, sparkle);\r\n            vec3 star = brightness*vec3(.6+p.x, .4, .6+p.y)*N.z*N.z;\r\n            \r\n            \r\n            star *= 1.+sin((t+n)*20.)*smoothstep(sin(t)*.5+.5, 1., fract(10.*n));\r\n            \r\n            float d = length(gv+offs);\r\n            \r\n            col += star*smoothstep(1.5, .8, d);\r\n        }\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-.5*resolution.xy)/resolution.y;\r\n    vec2 M = vec2(0.);\r\n    \r\n    M *= 10.;\r\n    \r\n\tfloat t = -time*.3;\r\n\t\r\n    float twirl = sin(t*.1);\r\n    twirl *= twirl*twirl*sin(dot(uv,uv));\r\n    uv *= Rot(-t*.2);\r\n    \r\n    uv *= 2.+sin(t*.05);\r\n    \r\n    vec3 col = vec3(0);\r\n    float speed = -.2;\r\n    #ifdef BURST\r\n    speed = .1;\r\n    float bla = sin(t+sin(t+sin(t)*.5))*.5+.5;\r\n    float d = dot(uv,uv);\r\n    \r\n    float a = atan(uv.x, uv.y);\r\n    uv /= d;\r\n    float burst = sin(time*.05);\r\n    uv *= burst+.2;\r\n    #endif\r\n    \r\n    float stp = 1./NUM_LAYERS;\r\n        \r\n    for(float i=0.; i<1.; i+=stp) {\r\n    \tfloat lt = fract(t*speed+i);\r\n        float scale = mix(10., .25, lt);\r\n        float fade = smoothstep(0., .4, lt)*smoothstep(1., .95, lt); \r\n        vec2 sv = uv*scale+i*134.53-M;\r\n        //sv.x += t;\r\n        col += StarLayer(sv, t, fade)*fade;\r\n    }\r\n    \r\n    #ifdef BURST\r\n    //t = time*.5;\r\n    float burstFade = smoothstep(0., .02, abs(burst));\r\n    float size = .9*sin(t)+1.;\r\n    size = max(size, sqrt(size));\r\n    float fade = size/d;\r\n    col *= mix(1., fade, burstFade);\r\n    col += fade*.2*vec3(1., .5, .1)*bla*burstFade;\r\n    \r\n    t*=1.5;\r\n    \r\n    a -= M.x*.1;\r\n    float rays = sin(a*5.+t*3.)-cos(a*7.-t);\r\n    rays *= sin(a+t+sin(a*4.)*10.)*.5+.5;\r\n    col += rays*bla*.1*burstFade;\r\n    col += 1.-burstFade;\r\n    #else\r\n    col *= 4.;\r\n    #endif\r\n    \r\n    fragColor = vec4(col,1.0);\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/cosmicCycleShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/earthShader.js":
/*!*****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/earthShader.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.earthShader = void 0;\n;\nexports.earthShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform vec3 cameraPos;\r\nout vec4 fragColor;\r\n\r\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\r\n\r\nfloat hash12(vec2 p) {\r\n\tp = fract(p * vec2(5.3983, 5.4427));\r\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\r\n\treturn fract(p.x * p.y * 95.4337);\r\n}\r\n\r\nvec2 hash21(float p) {\r\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\r\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\r\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\r\n}\r\n\r\nfloat noise(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \r\n                   hash12(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12(i + vec2(0.0, 1.0)), \r\n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat hash12_3(vec2 p) {\r\n\tfloat f = hash12(p);\r\n    return f * f * f;\r\n}\r\n\r\nfloat noise_3(in vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \r\n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash12_3(i + vec2(0.0, 1.0)), \r\n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat fbm(vec2 p) {\r\n    float f = 0.0;\r\n    f += 0.5 * noise(p); p = m * p;\r\n    f += 0.25 * noise(p); p = m * p;\r\n    f += 0.125 * noise(p); p = m * p;\r\n    f += 0.0625 * noise(p); p = m * p;\r\n    f += 0.03125 * noise(p); p = m * p;\r\n    f += 0.015625 * noise(p);\r\n    return f / 0.984375;\r\n}\r\n\r\nvec3 getDir(vec2 screenPos) {\r\n    screenPos -= 0.5;\r\n\tscreenPos.x *= resolution.x / resolution.y;\r\n    \r\n    return normalize(vec3(0.0, -1.0, -3.0)\r\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\r\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\r\n}\r\n\r\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\r\n    bool valid = false;\r\n    \r\n\tfloat b = dot(camera, dir);\r\n\tfloat c = dot(camera, camera) - 1.0;\r\n\tfloat h = b * b - c;\r\n\tif (h > 0.0) {\r\n        valid = true;\r\n        \r\n        vec3 p = camera + (-b - sqrt(h)) * dir;\r\n        pos = p.xz + time * vec2(0.005, 0.02);\r\n\t}\r\n\r\n\treturn valid;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 screen = fragCoord.xy / resolution.xy;\r\n    \r\n    vec3 camera = cameraPos;//vec3(0.0, 1.2, 0.7);\r\n    vec3 dir = getDir(screen);\r\n\r\n    vec3 currentCamera = cameraPos;\r\n    \r\n    vec3 earth = vec3(0.0, 0.0, 0.0);\r\n    vec2 position;\r\n    if (getPosition(camera, dir, position)) {\r\n        float geography = fbm(6.0 * position);\r\n\r\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\r\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\r\n        vec2 p = 40.0 * position;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast); p = m * p;\r\n        population *= (noise_3(p) + coast);\r\n        population = smoothstep(0.0, 0.02, population);\r\n\r\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\r\n        vec3 water = vec3(0.0, 0.05, 0.1);\r\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\r\n\r\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\r\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\r\n\r\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\r\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \r\n\r\n        float lightning = 0.0;\r\n        vec2 strike;\r\n        if (getPosition(camera, getDir(hash21(time)), strike)) {\r\n            vec2 diff = position - strike;\r\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\r\n        }\r\n        lightning *= smoothstep(0.65, 0.75, weather);\r\n        earth += lightning * vec3(1.0, 1.0, 1.0);\r\n    }\r\n    \r\n    vec3 altitude = camera - dir * dot(camera, dir);\r\n    float horizon = sqrt(dot(altitude, altitude));\r\n    \r\n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\r\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\r\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\r\n\r\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\r\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\r\n}\r\n\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/earthShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/eventHorizon.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/eventHorizon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.eventHorizonShader = void 0;\nexports.eventHorizonShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform sampler2D iChannel0;\r\nuniform float zoom;\r\nout vec4 fragColor;\r\n\r\n\r\n// comment this string to see fluffy clouds\r\n#define DENSE_DUST\r\n#define DITHERING\r\n#define BACKGROUND\r\n\r\n//-------------------\r\n#define pi 3.14159265\r\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\r\n\r\nmat2 Spin(float angle)\r\n{\r\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\r\n}\r\n\r\n// iq's noise\r\nfloat pn( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy+vec2(2.0,4.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 2.8)/256.0, 2.5 ).yx;\r\n\treturn -1.0+0.7*mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat fpn(vec3 p)\r\n{\r\n   return pn(p*.06125)*.5 + pn(p*.125)*.15 + pn(p*.15)*.225;// + pn(p*.5)*.625;\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n\treturn fract(sin(dot(co*0.123,vec2(2.9898,1.233))) * 63758.5453);\r\n}\r\n\r\nfloat Ring(vec3 p)\r\n{\r\n  vec2 q = vec2(length(p.xy)-5.3,p.z);\r\n  return length(q)-0.51;\r\n}\r\n\r\nfloat length2( vec2 p )\r\n{\r\n\treturn sqrt( p.x*p.x + p.y*p.y );\r\n}\r\n\r\nfloat length8( vec2 p )\r\n{\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\n\r\n\r\nfloat Disk( vec3 p, vec3 t )\r\n{\r\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.15);\r\n    return max(length8(q)-t.y, abs(p.z) - t.z);\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.45 + 0.14*(b-a)/k, 1.250, 0.250 );\r\n\treturn mix( b, a, h ) - k*h*(2.0-h);\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float t=0.23*time;\r\n\tfloat d1 = Disk(p,vec3(2.75,0.88,0.45)) + fpn(vec3(Spin(t*3.25+p.z*1.20)*p.xy*24.,p.z*25.-t)*5.0) * 0.845;\r\n    float d2 = Ring(p);\r\n    return smin(d1,d2,1.52);\r\n\r\n}\r\n\r\n// assign color to the media\r\nvec3 computeColor( float density, float radius )\r\n{\r\n\t// color based on density alone, gives impression of occlusion within\r\n\t// the media\r\n\tvec3 result = mix( 0.6*vec3(0.26,0.5,0.4), vec3(0.8,0.25,0.1), density );\r\n\t\r\n\t// color added for disk\r\n\tvec3 colCenter = 2.*vec3(0.22,0.6,0.5);\r\n\tvec3 colEdge = 3.*vec3(0.08,0.23,0.5);\r\n\tresult *= mix( colCenter, colEdge, min( (radius+.2)/1.0, 0.25 ) );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\r\n{\r\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\r\n\tfloat a = dot(dir.xy, dir.xy);\r\n\tfloat b = dot(org.xy, dir.xy);\r\n\tfloat c = dot(org.xy, org.xy) - 11.;\r\n\r\n\tfloat delta = b * b - a * c;\r\n\tif( delta < 0.15 )\r\n\t\treturn false;\r\n\r\n\t// 2 roots\r\n\tfloat deltasqrt = sqrt(delta);\r\n\tfloat arcp = 1.1 / a;\r\n\tnear = (-b - deltasqrt) * arcp;\r\n\tfar = (-b + deltasqrt) * arcp;\r\n\t\r\n\t// order roots\r\n\tfloat temp = min(far, near);\r\n\tfar = max(far, near);\r\n\tnear = temp;\r\n\r\n\tfloat znear = org.z + near * dir.z;\r\n\tfloat zfar = org.z + far * dir.z;\r\n\r\n\t// top, bottom\r\n\tvec2 zcap = vec2(9.15, -2.85);\r\n\tvec2 cap = (zcap - org.z) / dir.z;\r\n\r\n\tif ( znear < zcap.y )\r\n\t\tnear = cap.y;\r\n\telse if ( znear > zcap.x )\r\n\t\tnear = cap.x;\r\n\r\n\tif ( zfar < zcap.y )\r\n\t\tfar = cap.y;\r\n\telse if ( zfar > zcap.x )\r\n\t\tfar = cap.x;\r\n\t\r\n\treturn far > 2.5 && far > near;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{  \r\n    const float KEY_1 = 49.5/256.0;\r\n\tconst float KEY_2 = 50.5/256.0;\r\n\tconst float KEY_3 = 51.5/256.0;\r\n    float key = 0.7;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_2,0.15)).x;\r\n    // key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\r\n\r\n\t// ro: ray origin\r\n\t// rd: direction of the ray\r\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*resolution.xy)/resolution.y, 2.5));\r\n\tvec3 ro = vec3(1.1, 1.2, -6.+key*0.2);\r\n\r\n   \r\n    R(rd.yz, -pi*3.65);\r\n    R(rd.xz, pi*3.2);\r\n    R(ro.yz, -pi*3.65);\r\n   \tR(ro.xz, pi*3.2);    \r\n \r\n    \r\n    #ifdef DITHERING\r\n\tvec2 dpos = ( fragCoord.xy / resolution.xy );\r\n\tvec2 seed = dpos + fract(time);\r\n   \t// randomizing the length \r\n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \r\n\t#endif \r\n    \r\n\t// ld, td: local, total density \r\n\t// w: weighting factor\r\n\tfloat ld=0.48, td=0.23, w=1.04;\r\n\r\n\t// t: length of the ray\r\n\t// d: distance function\r\n\tfloat d=21.8, t=21.2;\r\n   \r\n\tvec4 sum = vec4(0.1);\r\n   \r\n    float min_dist=2.52, max_dist=222.5;\r\n\r\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\r\n    {\r\n       \r\n\tt = min_dist*step(t,min_dist);\r\n   \r\n\t// raymarch loop\r\n\tfor (int i=0; i<36; i++) \r\n\t{\r\n\t \r\n\t\tvec3 pos = ro + t*rd;\r\n\r\n\t\tfloat fld = 0.40;\r\n       \r\n\t\t// Loop break conditions.\r\n        if(td>(0.9-1./7.) || d<0.008*t || t>13. || sum.a > 0.99 || t>max_dist) break;\r\n\t  \r\n\t\t// evaluate distance function\r\n\t\td = map(pos); \r\n       \r\n\t\t// direction to center\r\n\t\tvec3 stardir = normalize(vec3(3.4)-pos);\r\n      \r\n\t\t// change this string to control density \r\n\t\td = max(d,0.04);\r\n      \r\n\t\tif (d<0.1) \r\n\t\t{\r\n\t\t\t// compute local density \r\n\t\t\tld = 0.2 - d;\r\n\t\t\t\r\n            #ifdef DENSE_DUST          \r\n\t\t\tfld = clamp((ld - map(pos+4.2*stardir))/1.4, 0.22, 1.3 );\r\n\t\t\tld += fld;\r\n            #endif\r\n \t\t\t\r\n            // compute weighting factor \r\n\t\t\tw = (1.4 - td) * ld;\r\n     \r\n\t\t\t// accumulate density\r\n\t\t\ttd += w + 2./3.;\r\n\t\t\r\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.5));\r\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\r\n\t\t\r\n\t\t\t// uniform scale density\r\n\t\t\tcol.a *= 1.02;\r\n\t\t\t// colour by alpha\r\n\t\t\tcol.rgb *= col.a/11.08;\r\n\t\t\t// alpha blend in contribution\r\n\t\t\tsum = sum + col*(1.08 - sum.a);  \r\n\t\t}\r\n      \r\n\t\ttd += 1./110.;\r\n       \r\n        // point light calculations\r\n        vec3 ldst = vec3(1.32)-pos;\r\n        float lDist = max(length(ldst), 0.021);\r\n\r\n        // star in center\r\n        vec3 lightColor=vec3(0.81,0.31,0.15);\r\n        sum.rgb+=lightColor/(lDist*lDist*lDist*7.);//*10.); //add a bloom around the light\r\n\r\n        // using the light distance to perform some falloff\r\n        //float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\r\n        // accumulating the color\r\n        //sum += w*atten*fld;\r\n       \r\n        // enforce minimum stepsize\r\n        d = max(d, 0.24); \r\n      \r\n        #ifdef DITHERING\r\n        // add in noise to reduce banding and create fuzz\r\n        d=abs(d)*(1.+0.58*rand(seed*vec2(i)));\r\n        #endif \r\n\t  \r\n        t +=  max(d * 0.13, 0.19);\r\n      \r\n\t}\r\n    \r\n    //scattering test\r\n\t//sum *= 1. / exp( ld * 0.2 ) * 1.05;\r\n        \r\n   \tsum = clamp( sum, 0.0, 1.0 );\r\n   \r\n    sum.xyz = sum.xyz*sum.xyz*(3.0-1.0*sum.xyz);\r\n    \r\n\t}\r\n\r\n    #ifdef BACKGROUND\r\n    // stars background\r\n    if (td<1.8)\r\n    {\r\n        vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\r\n        vec3 starbg = vec3(0.0);\r\n        starbg = mix(starbg, vec3(0.1,0.3,0.2), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.4),rd)+0.75,0.4,1.0));\r\n        starbg = clamp(starbg, 0.0, 1.0);\r\n        sum.xyz += starbg; \r\n    }\r\n\t#endif\r\n    \r\n   fragColor = vec4(sum.xyz,1.0);\r\n}\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/eventHorizon.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/exoPlanetShader.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/exoPlanetShader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exoplanetShader = void 0;\nexports.exoplanetShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nout vec4 fragColor;\r\n\r\n\r\n\r\nconst float tau = 6.283185;\r\n\r\nfloat hash1(float p) {\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    p *= p + p;\r\n    return fract(p);\r\n}\r\n\r\nfloat hash1(float p, float q) {\r\n    vec3 p3  = fract(vec3(p, q, p) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec2 hash2(float p) {\r\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\n\r\nvec2 hash2(float p, float q) {\r\n    vec3 p3 = fract(vec3(p, q, p) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx+33.33);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\n\r\nvec3 hash3(float p) {\r\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\n\r\nvec3 hash3(vec3 p3) {\r\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\n\r\nvec4 hash4(float p) {\r\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\r\n    p4 += dot(p4, p4.wzxy+33.33);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \r\n}\r\n\r\nfloat noise1(float p) {\r\n    float i = floor(p);\r\n    float f = fract(p);\r\n    float u = f * f * (3.0 - 2.0 * f);\r\n    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);\r\n}\r\n\r\nvec3 noise3(vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\r\n    vec3 u = f * f * (3.0 - 2.0 * f);\r\n    return 1.0 - 2.0 * mix(mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)), \r\n                                   hash3(i + vec3(1.0, 0.0, 0.0)), u.x),\r\n                               mix(hash3(i + vec3(0.0, 1.0, 0.0)), \r\n                                   hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\r\n                           mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)), \r\n                                   hash3(i + vec3(1.0, 0.0, 1.0)), u.x),\r\n                               mix(hash3(i + vec3(0.0, 1.0, 1.0)), \r\n                                   hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\r\n}\r\n\r\nfloat fbm1(float p) {\r\n    float f = noise1(p); p = 2.0 * p;\r\n    f += 0.5 * noise1(p); p = 2.0 * p;\r\n    f += 0.25 * noise1(p); p = 2.0 * p;\r\n    f += 0.125 * noise1(p); p = 2.0 * p;\r\n    f += 0.0625 * noise1(p);\r\n    return f / 1.9375;\r\n}\r\n\r\nconst mat3 m = mat3( 0.51162, -1.54702,  1.15972,\r\n                    -1.70666, -0.92510, -0.48114,\r\n                     0.90858, -0.86654, -1.55678);\r\n\r\nvec3 fbm3(vec3 p) {\r\n    vec3 f = noise3(p); p = m * p;\r\n    f += 0.5 * noise3(p); p = m * p;\r\n    f += 0.25 * noise3(p); p = m * p;\r\n    f += 0.125 * noise3(p); p = m * p;\r\n    f += 0.0625 * noise3(p);\r\n    return f / 1.9375;\r\n}\r\n\r\nvec3 uniform3(float seed) {\r\n    vec2 hash = hash2(seed);\r\n    float x = 2.0 * hash.x - 1.0;\r\n    float r = sqrt(1.0 - x * x);\r\n    float t = tau * hash.y;\r\n    return vec3(x, r * sin(t), r * cos(t));\r\n}\r\n\r\nvec3 hsv(float hue, float sat, float val) {\r\n    return (val) * (vec3(1.0 - (sat)) + (sat) * (0.5 + 0.5 * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)))));\r\n}\r\n\r\nvec4 newMoon(float moonCount, vec3 pole, float seed, float moon) {\r\n    vec3 pos = uniform3(seed);\r\n    pos -= 0.75 * pole * dot(pole, pos);\r\n    pos = normalize(pos);\r\n    pos *= 1.5 + 2.0 * hash1(seed + 0.001);\r\n    pos *= step(moon, moonCount);\r\n    float r = 0.02 + 0.1 * pow(hash1(seed + 0.002), 6.0);\r\n    return vec4(pos, r);\r\n}\r\n\r\n#define hitMoon(moon, seed) { \\\r\n    vec3 v = eye - moon.xyz; \\\r\n    float b = dot(v, ray); \\\r\n    float c = dot(v, v) - moon.w * moon.w; \\\r\n    float h = b * b - c; \\\r\n    float mHit = step(0.0, h); \\\r\n    h = max(h, 0.0); \\\r\n    float mDepth = -b - sqrt(h); \\\r\n    vec3 p = eye + mDepth * ray; \\\r\n    vec3 mNorm = normalize(p - moon.xyz); \\\r\n    mHit *= step(mDepth, moonDepth); \\\r\n    moonDepth = mix(moonDepth, mDepth, mHit); \\\r\n    moonNorm = mix(moonNorm, mNorm, mHit); \\\r\n    moonSeed = mix(moonSeed, seed, mHit); \\\r\n}\r\n\r\nfloat moonShadow(vec3 pos, vec4 moon, vec3 dir) {\r\n    vec3 p = pos - moon.xyz;\r\n\tfloat m = dot(p, dir);\r\n    float n = dot(p, p);\r\n    return step(step(m, 0.0) * moon.w * moon.w, n - m * m);\r\n}\r\n\r\nfloat ring(vec3 pos, vec3 dir, vec3 pole, float seed, out float d, out float r, out vec3 q) {\r\n    vec2 bounds = 1.4 * hash2(seed + 0.9) + vec2(1.1, 1.6);\r\n    \r\n    d = dot(-pos, pole) / dot(dir, pole);\r\n    q = pos + d * dir;\r\n    r = length(q);\r\n    \r\n    float a = smoothstep(bounds.x, bounds.x + 0.1, r) * smoothstep(bounds.y, bounds.y - 0.1, r);\r\n    a *= smoothstep(-0.5, 1.0, fbm1(6.0 * (r + 3.0 * seed)));\r\n    return clamp(a, 0.0, 1.0);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    float t = 0.25 * time;\r\n    float seed = floor(t) + 1.0;\r\n    \r\n    vec3 center = vec3(0.0);\r\n    float s = 2.0 * fract(t) - 1.0;\r\n    float powS = s * s;\r\n    powS = powS * powS;\r\n    powS = powS * powS;\r\n    powS = powS * powS;    \r\n    center += s * powS * vec3(1.0, 3.0, 0.0);\r\n    vec3 eye = center + vec3(0.0, -5.0, 0.0) + fract(t) * vec3(1.0, 1.0, 0.0);\r\n    float zoom = 3.0;\r\n    \r\n    vec3 forward = normalize(center - eye);\r\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\r\n    vec3 up = cross(right, forward);\r\n    vec2 xy = 2.0 * fragCoord - resolution.xy;\r\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * resolution.y);\r\n    \r\n    vec3 light = uniform3(seed);\r\n    vec3 pole = uniform3(seed + 0.1);\r\n        \r\n    float dist = 1.0 + 1.2 * hash1(seed);\r\n    eye *= dist;\r\n\r\n    vec2 bandHash = hash2(seed + 0.2);\r\n    float bandScale = 1.0 + 6.0 * bandHash.x;\r\n    float bandTurbulence = 0.1 * pow(bandHash.y, 2.0);\r\n    \r\n    vec4 planetHash = hash4(seed + 0.3);\r\n    vec3 planetColor = hsv(planetHash.x, 0.5, 0.5 + 0.2 * planetHash.y);\r\n    vec3 planetMinorX = hsv(planetHash.x, 0.3, 0.5 + 0.2 * planetHash.y + 0.3 * planetHash.w) - planetColor;\r\n    vec3 planetMinorY = hsv(planetHash.x + 0.4 * planetHash.z, 0.5, 0.5 + 0.2 * planetHash.y) - planetColor;\r\n    vec3 planetMinorZ = hsv(planetHash.x + 0.4 * planetHash.z, 0.3, 0.5 + 0.2 * planetHash.y - 0.4 * planetHash.w) - planetColor;\r\n    \r\n    vec3 ringHash = hash3(seed + 0.4);\r\n    vec3 ringColor = hsv(ringHash.x, 0.2, 0.5 + 0.2 * ringHash.y);\r\n    vec3 ringMinor = hsv(ringHash.x + 0.3 * ringHash.z, 0.2, 0.7 + 0.2 * ringHash.y) - ringColor;\r\n    \r\n    float moonCount = hash1(seed + 0.5) * 8.0 - 2.0;    \r\n    \r\n    vec4 moon1 = newMoon(moonCount, pole, seed + 0.01, 0.0);\r\n    vec4 moon2 = newMoon(moonCount, pole, seed + 0.02, 1.0);\r\n    vec4 moon3 = newMoon(moonCount, pole, seed + 0.03, 2.0);\r\n    vec4 moon4 = newMoon(moonCount, pole, seed + 0.04, 3.0);\r\n    vec4 moon5 = newMoon(moonCount, pole, seed + 0.05, 4.0);\r\n    vec4 moon6 = newMoon(moonCount, pole, seed + 0.06, 5.0);\r\n    \r\n    float b = dot(eye, ray);\r\n    float c = dot(eye, eye) - 1.0;\r\n    float h = b * b - c;\r\n    float hit = step(0.0, h);\r\n    h = max(h, 0.0);\r\n    float depth = -b - sqrt(h);\r\n    vec3 pos = eye + depth * ray;\r\n    \r\n    vec3 poleX = normalize(cross(pole, vec3(0.0, 0.0, 1.0)));\r\n    vec3 poleY = cross(pole, poleX);\r\n    mat3 rot = inverse(mat3(pole, poleX, poleY));\r\n    \r\n    vec3 p = rot * pos;\r\n    //p.x = asin(p.x); // Latitude bands\r\n    p += bandTurbulence * fbm3(10.0 * p);\r\n    \r\n    vec3 bands = fbm3(bandScale * vec3(1.0, 0.05, 0.05) * p + seed);\r\n    vec3 color = planetColor;\r\n    color += planetMinorX * bands.x;\r\n    color += planetMinorY * bands.y;\r\n    color += planetMinorZ * bands.z;\r\n    \r\n    float moonDepth = 2.0 * depth;\r\n    vec3 moonNorm = vec3(0.0);\r\n    float moonSeed = 0.0;\r\n    hitMoon(moon1, 1.0);\r\n    hitMoon(moon2, 2.0);\r\n    hitMoon(moon3, 3.0);\r\n    hitMoon(moon4, 4.0);\r\n    hitMoon(moon5, 5.0);\r\n    hitMoon(moon6, 6.0);\r\n    float moonHit = 1.0 - step(depth, moonDepth) * hit;\r\n\r\n    vec3 moonPos = eye + moonDepth * ray;\r\n    \r\n    vec3 moonColor = fbm3(10.0 * moonPos);\r\n    float moonSat = 0.4 * hash1(seed + 0.123 * moonSeed) + 0.2 * moonColor.x;\r\n    moonColor = hsv(hash1(seed + 0.321 * moonSeed) + 0.2 * moonColor.y, moonSat, 0.4 + 0.7 * moonColor.z);\r\n    \r\n    pos = mix(pos, moonPos, moonHit);\r\n    color = mix(color, moonColor, moonHit);\r\n    depth = mix(depth, moonDepth, moonHit);\r\n    vec3 norm = mix(pos, moonNorm, moonHit);\r\n    hit = 1.0 - (1.0 - hit) * (1.0 - moonHit);\r\n    \r\n    float illumination = max(dot(norm, light), 0.0);\r\n\r\n    float m = dot(pos, light);\r\n    float n = dot(pos, pos);\r\n    illumination *= step(step(m, 0.0), n - m * m);\r\n    \r\n    illumination *= moonShadow(pos, moon1, light);\r\n    illumination *= moonShadow(pos, moon2, light);\r\n    illumination *= moonShadow(pos, moon3, light);\r\n    illumination *= moonShadow(pos, moon4, light);\r\n    illumination *= moonShadow(pos, moon5, light);\r\n    illumination *= moonShadow(pos, moon6, light);\r\n\r\n    float d, r;\r\n    vec3 q;\r\n    float ringShadow = ring(pos, light, pole, seed, d, r, q);\r\n    illumination *= 1.0 - ringShadow * step(0.0, d);\r\n\r\n    color *= hit * illumination;\r\n    \r\n    float ringAlpha = ring(eye, ray, pole, seed, d, r, q);\r\n    float ringLight = 0.5 + 0.5 * abs(dot(pole, light));\r\n    \r\n    m = dot(q, light);\r\n    n = dot(q, q);\r\n    ringLight *= step(step(m, 0.0), n - m * m);\r\n    \r\n    ringLight *= moonShadow(q, moon1, light);\r\n    ringLight *= moonShadow(q, moon2, light);\r\n    ringLight *= moonShadow(q, moon3, light);\r\n    ringLight *= moonShadow(q, moon4, light);\r\n    ringLight *= moonShadow(q, moon5, light);\r\n    ringLight *= moonShadow(q, moon6, light);\r\n    \r\n    ringColor += ringMinor * fbm1(15.0 * (r + 3.0 * seed));\r\n    ringColor *= ringLight;\r\n    \r\n    color = mix(color, ringColor, step(hit * d, depth) * ringAlpha);\r\n    \r\n    color *= 2.0;\r\n    float flare = max(0.0, dot(ray, light));\r\n    color += pow(flare, 10.0);\r\n    \r\n    fragColor = vec4(color, 1.0);\r\n}\r\n\r\n\r\n\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/exoPlanetShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/galaxyShader.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/galaxyShader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.galaxyShader = void 0;\nexports.galaxyShader = `uniform float time;\r\nuniform vec2 cameraPos;\r\nuniform vec2 resolution;\r\nuniform sampler2D iChannel0;\r\nuniform float zoom;\r\nout vec4 fragColor;\r\n\r\n#define iterations 17\r\n#define formuparam .53\r\n\r\n#define volsteps 20\r\n#define stepsize 0.1\r\n\r\n#define zoom   0.800\r\n#define tile   0.850\r\n#define speed  0.010 \r\n\r\n#define brightness 0.0015\r\n#define darkmatter 1.300\r\n#define distfading 0.730\r\n#define saturation 0.850\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/resolution.xy-.5;\r\n\tuv.y*=resolution.y/resolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=time*speed+.25;\r\n\r\n\r\n\tfloat a1=.5+cameraPos.x/resolution.x*2.;\r\n\tfloat a2=.8+cameraPos.y/resolution.y*2.;\r\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\r\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\r\n\tdir.xz*=rot1;\r\n\tdir.xy*=rot2;\r\n\tvec3 from=vec3(1.,.5,0.5);\r\n\tfrom+=vec3(time*2.,time,-2.);\r\n\tfrom.xz*=rot1;\r\n\tfrom.xy*=rot2;\r\n\t\r\n\t//volumetric rendering\r\n\tfloat s=0.1,fade=1.;\r\n\tvec3 v=vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\tvec3 p=from+s*dir*.5;\r\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\tpa=length(p);\r\n\t\t}\r\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\ta*=a*a; // add contrast\r\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\tv+=fade;\r\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\tfade*=distfading; // distance fading\r\n\t\ts+=stepsize;\r\n\t}\r\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\tfragColor = vec4(v*.01,1.);\t\r\n\t\r\n}\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/galaxyShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/lonlyPlanetShader.js":
/*!***********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/lonlyPlanetShader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lonlyPlanetShader = void 0;\nexports.lonlyPlanetShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nout vec4 fragColor;\r\n\r\nvec3 vec_tovec3(float a);\r\nvec3 noise_vec3_yzx(vec3 self);\r\nvec3 noise_vec2_xyx(vec2 self);\r\nvec2 sincos(float x);\r\nfloat noise_hash1_2(vec2 v);\r\nfloat noise_hash1_3(vec3 v);\r\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f);\r\nfloat noise_noise_white_1(vec2 p);\r\nfloat noise_noise_value_1(vec3 p);\r\nfloat map(vec3 p);\r\nfloat ray_march(vec3 ro, vec3 rd);\r\nvec3 get_normal(vec3 p);\r\nfloat fbm3(vec3 p);\r\nvec3 planet_palette(float x);\r\nvec3 planet_color(vec3 p);\r\nvec3 shade(vec3 rd, vec3 p);\r\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\r\nfloat expstep(float x, float k);\r\nvec3 get_background(vec3 rd);\r\nvec3 color_tonemap_aces(vec3 col);\r\nvec3 color_saturate(vec3 col, float sat);\r\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma);\r\nvec3 color_gamma_correction(vec3 col);\r\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount);\r\nvec3 dither(vec3 col, vec2 coord, float amount);\r\nvec3 sun_glare(vec3 rd);\r\n/* ------------------------------ DEFINITIONS ------------------------------- */\r\nvec3 vec_tovec3(float a) {\r\n  return vec3(a, a, a);\r\n}\r\nvec3 noise_vec3_yzx(vec3 self) {\r\n  return vec3(self.y, self.z, self.x);\r\n}\r\nvec3 noise_vec2_xyx(vec2 self) {\r\n  return vec3(self.x, self.y, self.x);\r\n}\r\nvec2 sincos(float x) {\r\n  return vec2(sin(x), cos(x));\r\n}\r\nfloat noise_hash1_2(vec2 v) {\r\n  vec3 v3 = noise_vec2_xyx(v);\r\n  v3 = fract((v3 * 0.1031));\r\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\r\n  return fract(((v3.x + v3.y) * v3.z));\r\n}\r\nfloat noise_hash1_3(vec3 v) {\r\n  vec3 v3 = v;\r\n  v3 = fract((v3 * 0.1031));\r\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\r\n  return fract(((v3.x + v3.y) * v3.z));\r\n}\r\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {\r\n  vec3 u = ((f * f) * (3.0 - (2.0 * f)));\r\n  vec3 u1 = (1.0 - u);\r\n  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));\r\n}\r\nfloat noise_noise_white_1(vec2 p) {\r\n  return noise_hash1_2(p);\r\n}\r\nfloat noise_noise_value_1(vec3 p) {\r\n  vec3 i = floor(p);\r\n  vec3 f = fract(p);\r\n  vec3 j = (i + 1.0);\r\n  float a1 = noise_hash1_3(i);\r\n  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));\r\n  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));\r\n  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));\r\n  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));\r\n  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));\r\n  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));\r\n  float d2 = noise_hash1_3(j);\r\n  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);\r\n}\r\nfloat sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {\r\n  vec3 oc = (ro - p);\r\n  float b = dot(oc, rd);\r\n  float c = (dot(oc, oc) - (r * r));\r\n  float h = ((b * b) - c);\r\n  if(h < 0.0) {\r\n    return -1.0f;\r\n  } else {\r\n    return ((-b) - sqrt(h));\r\n  }\r\n}\r\nfloat map(vec3 p) {\r\n  return (length(p) - 0.6);\r\n}\r\nfloat ray_march(vec3 ro, vec3 rd) {\r\n  float t = 0.0;\r\n  for(int i = 0; i < 128; i++) {\r\n    vec3 p = (ro + (t * rd));\r\n    float d = map(p);\r\n    if(d <= 0.0001) {\r\n      return t;\r\n    }\r\n    t = (t + d);\r\n    if(t > 10.0) {\r\n      return -1.0;\r\n    }\r\n  }\r\n  return -1.0;\r\n}\r\nfloat fbm3(vec3 p) {\r\n  float a = 1.0;\r\n  float t = 0.0;\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  a = (a * 0.5);\r\n  p = ((2.0 * p) + 100.0);\r\n  t = (t + (a * noise_noise_value_1(p)));\r\n  return t;\r\n}\r\nvec3 planet_palette(float x) {\r\n  vec3 col = vec3(0.1, 0.6, 0.9);\r\n  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));\r\n  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));\r\n  return col;\r\n}\r\nvec3 planet_color(vec3 p) {\r\n  p = (p * 2.0);\r\n  float t = time;\r\n  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));\r\n  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));\r\n  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);\r\n  vec3 col = planet_palette(r.y);\r\n  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));\r\n  col = clamp(col, 0.0, 1.0);\r\n  return col;\r\n}\r\nvec3 shade(vec3 rd, vec3 p) {\r\n  vec3 normal = normalize(p);\r\n  float ambient_dif = 0.03;\r\n  vec3 dif = vec_tovec3(ambient_dif);\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);\r\n  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);\r\n  dif = (dif + (sun_col * sun_dif));\r\n  vec3 mate = (planet_color(p) * 0.4);\r\n  vec3 col = (mate * dif);\r\n  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);\r\n  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));\r\n  col = (col * (1.0 - fres));\r\n  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));\r\n  return col;\r\n}\r\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\r\n  vec2 sc = sincos(tilt);\r\n  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));\r\n  vec3 w = normalize((lookat - lookfrom));\r\n  vec3 u = cross(w, vup);\r\n  vec3 v = cross(u, w);\r\n  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));\r\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\r\n}\r\nfloat expstep(float x, float k) {\r\n  return exp(((k * x) - k));\r\n}\r\nvec3 get_background(vec3 rd) {\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  float sun_dif = dot(rd, sun_dir);\r\n  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));\r\n  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));\r\n  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));\r\n  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));\r\n  return col;\r\n}\r\nvec3 color_tonemap_aces(vec3 col) {\r\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\r\n}\r\nvec3 color_saturate(vec3 col, float sat) {\r\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\r\n  return (grey + (sat * (col - grey)));\r\n}\r\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {\r\n  col = pow(col, vec_tovec3(invgamma));\r\n  return (((gain - lift) * col) + lift);\r\n}\r\nvec3 color_gamma_correction(vec3 col) {\r\n  return pow(col, vec_tovec3(0.454545455));\r\n}\r\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount) {\r\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\r\n}\r\nvec3 dither(vec3 col, vec2 coord, float amount) {\r\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\r\n}\r\nvec3 sun_glare(vec3 rd) {\r\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\r\n  vec3 glare_col = vec3(1.0, 0.6, 0.2);\r\n  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));\r\n}\r\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\r\n  vec2 res = vec2(resolution.x, resolution.y);\r\n\r\n  vec2 mouse =vec2(1.0);\r\n\r\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / resolution.y);\r\n  float theta = ((1.88495559 + (time * 0.2)) + (6.28318531 * mouse.x));\r\n  vec3 lookat = vec3(0.0, 0.0, 0.0);\r\n  vec2 sc = (sincos(theta) * 2.0);\r\n  vec3 ro = vec3(sc.x, 0.5, sc.y);\r\n  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);\r\n  float t = sphere_intersect(ro, rd, vec3(0.0, 0.0, 0.0), 0.6);\r\n  vec3 p = (ro + (rd * t));\r\n  vec3 col = get_background(rd);\r\n  float depth = 0.0;\r\n  if(t >= 0.0) {\r\n    col = shade(rd, p);\r\n  \tdepth = smoothstep(2.0, 2.0-0.6, t);\r\n  }\r\n  col = (col + (0.2 * sun_glare(rd)));\r\n  col = color_tonemap_aces(col);\r\n  col = color_tone_1(col, 1.7, 0.002, 1.2);\r\n  col = color_saturate(col, 0.9);\r\n  col = color_gamma_correction(col);\r\n  col = vignette(col, (frag_coord / res), 0.25, 0.7);\r\n  col = dither(col, frag_coord, 0.01);\r\n  frag_col = vec4(col.x, col.y, col.z, depth);\r\n}\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/lonlyPlanetShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainFragment.js":
/*!******************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainFragment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainFragment = void 0;\nexports.mainFragment = `\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nuniform float sI;\r\n\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform sampler2D iChannel4;\r\n\r\nout vec4 fragColor;\r\n\r\n#define iTime time\r\n#define res resolution \r\n\r\n\r\n//-------------------------------------------------------------------------------------------\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{\r\n\r\n\tvec4 color = vec4(vec3(0.),1.);\r\n\tvec2 uv = gl_FragCoord.xy / res.xy;\r\n\r\n\tcolor = texture(iChannel0,uv);\r\n\t\r\n\tfragColor = color; //multi1*multi2*blend2;\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainFragment.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/mainVertex.js":
/*!****************************************************!*\
  !*** ./build/wwwroot/assets/shaders/mainVertex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mainVertex = void 0;\nexports.mainVertex = `\r\nlayout(location = 0) in vec2 pos; \r\nout vec4 fragColor;\r\nvoid main(){\r\n    gl_Position = vec4(pos.xy,0.0,1.0);\r\n}`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/mainVertex.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/singularityShader.js":
/*!***********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/singularityShader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.singularityShader = void 0;\nexports.singularityShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nout vec4 fragColor;\r\n\r\nvec2 hash(vec2 x)\r\n{\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    x = x*k + k.yx;\r\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\r\n}\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n\r\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / resolution.xy;\r\n    float aspect = resolution.x / resolution.y;\r\n\tuv.y = -uv.y;\r\n    uv.y /= aspect;\r\n    \r\n    //vec2 sing = iMouse.xy / resolution.xy;\r\n    vec2 sing = vec2(0.5, 0.5 / aspect);\r\n    sing.y = -sing.y;\r\n    \r\n    uv -= sing;\r\n    uv *= pow(0.1, (time - 10.0) * 0.05);\r\n    uv += sing;\r\n    \r\n\tvec2 warp = 1. * normalize(sing - uv) * pow(distance(sing, uv) * 1000.0, -1.0);\r\n\tuv = uv + warp;\r\n    \r\n    uv = fract(uv - time / 8.0);\r\n    \r\n    float n = smoothstep(0.4, 0.5, noise(uv * 100.) + noise(uv * 25.) / 2.0);\r\n\t\r\n\tfloat light = clamp(distance(sing, uv), 0.0, 1.0);\r\n\t\r\n\t//vec4 color = texture(iChannel1, fract(uv - time / 8.0));\r\n    vec4 color = vec4(n);\r\n\tfragColor = color;// * light;\r\n}\r\n\r\n\r\n\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/singularityShader.js?");

/***/ }),

/***/ "./build/wwwroot/assets/shaders/warpSpeedShader.js":
/*!*********************************************************!*\
  !*** ./build/wwwroot/assets/shaders/warpSpeedShader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.warpSpeedShader = void 0;\nexports.warpSpeedShader = `uniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nout vec4 fragColor;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = (time+29.) * 60.0;\r\n\r\n    float s = 0.0, v = 0.0;\r\n    vec2 uv = (-resolution.xy + 2.0 * fragCoord ) / resolution.y;\r\n\tfloat t = time*0.005;\r\n\tuv.x += sin(t) * .3;\r\n\tfloat si = sin(t*1.5); // ...Squiffy rotation matrix!\r\n\tfloat co = cos(t);\r\n\tuv *= mat2(co, si, -si, co);\r\n\tvec3 col = vec3(0.0);\r\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * .1, time * 0.0008);\r\n\tfor (int r = 0; r < 100; r++) \r\n\t{\r\n\t\tvec3 p = init + s * vec3(uv, 0.143);\r\n\t\tp.z = mod(p.z, 2.0);\r\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\r\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\r\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\r\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\r\n\t\ts += .01;\r\n\t}\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\nvoid main(){\r\n    mainImage(fragColor,gl_FragCoord.xy);\r\n}\r\n\r\n`;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/assets/shaders/warpSpeedShader.js?");

/***/ }),

/***/ "./build/wwwroot/src/Fol06.js":
/*!************************************!*\
  !*** ./build/wwwroot/src/Fol06.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst entity_1 = __webpack_require__(/*! ../../src/Engine/entity */ \"./build/src/Engine/entity.js\");\nconst shaderEntity_1 = __webpack_require__(/*! ../../src/Engine/shaderEntity */ \"./build/src/Engine/shaderEntity.js\");\nconst mainFragment_1 = __webpack_require__(/*! ../assets/shaders/mainFragment */ \"./build/wwwroot/assets/shaders/mainFragment.js\");\nconst mainVertex_1 = __webpack_require__(/*! ../assets/shaders/mainVertex */ \"./build/wwwroot/assets/shaders/mainVertex.js\");\nconst sceneBuilder_1 = __webpack_require__(/*! ../../src/Engine/Helpers/sceneBuilder */ \"./build/src/Engine/Helpers/sceneBuilder.js\");\nconst SetupDemo_1 = __webpack_require__(/*! ./SetupDemo */ \"./build/wwwroot/src/SetupDemo.js\");\nconst earthShader_1 = __webpack_require__(/*! ../assets/shaders/earthShader */ \"./build/wwwroot/assets/shaders/earthShader.js\");\nconst fadeInOutTextEffect_1 = __webpack_require__(/*! ./effects/FoL/fadeInOutTextEffect */ \"./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js\");\nconst blackholeShader_1 = __webpack_require__(/*! ../assets/shaders/blackholeShader */ \"./build/wwwroot/assets/shaders/blackholeShader.js\");\nconst eventHorizon_1 = __webpack_require__(/*! ../assets/shaders/eventHorizon */ \"./build/wwwroot/assets/shaders/eventHorizon.js\");\nconst lonlyPlanetShader_1 = __webpack_require__(/*! ../assets/shaders/lonlyPlanetShader */ \"./build/wwwroot/assets/shaders/lonlyPlanetShader.js\");\nconst galaxyShader_1 = __webpack_require__(/*! ../assets/shaders/galaxyShader */ \"./build/wwwroot/assets/shaders/galaxyShader.js\");\nconst cosmicCycleShader_1 = __webpack_require__(/*! ../assets/shaders/cosmicCycleShader */ \"./build/wwwroot/assets/shaders/cosmicCycleShader.js\");\nconst debugHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/debugHelper */ \"./build/src/Engine/Helpers/debugHelper.js\");\nconst sequenceHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/sequenceHelper */ \"./build/src/Engine/Helpers/sequenceHelper.js\");\nconst conductor_1 = __webpack_require__(/*! ../../src/Engine/conductor */ \"./build/src/Engine/conductor.js\");\nconst warpSpeedShader_1 = __webpack_require__(/*! ../assets/shaders/warpSpeedShader */ \"./build/wwwroot/assets/shaders/warpSpeedShader.js\");\nconst audioLoader_1 = __webpack_require__(/*! ../../src/Engine/Audio/audioLoader */ \"./build/src/Engine/Audio/audioLoader.js\");\nconst EngineLogger_1 = __webpack_require__(/*! ../../src/Engine/EngineLogger */ \"./build/src/Engine/EngineLogger.js\");\nconst singularityShader_1 = __webpack_require__(/*! ../assets/shaders/singularityShader */ \"./build/wwwroot/assets/shaders/singularityShader.js\");\nconst exoPlanetShader_1 = __webpack_require__(/*! ../assets/shaders/exoPlanetShader */ \"./build/wwwroot/assets/shaders/exoPlanetShader.js\");\n// new SonantAudioLoader(sonantMusic) \nconst demo = new SetupDemo_1.SetupDemo(new audioLoader_1.DefaultAudioLoader(\"/wwwroot/assets/music/we float here.mp3\"));\n/**\n * The darkness at the end of time\n * a Fruit of the Loom demo\n * Released 2024\n * @class Fol06\n */\nclass Fol06 {\n    constructor(sequence, width, height, bmp) {\n        this.sequence = sequence;\n        this.width = width;\n        this.height = height;\n        this.bmp = bmp;\n        this.conductor = new conductor_1.Conductor();\n        sequence.conductor = this.conductor;\n    }\n    /**\n     * Create entitiesfor the intro scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    introScene() {\n        const mapEntities = new Array();\n        const textEffectEntity = new entity_1.Entity(\"intro-text\", {\n            y: this.height / 2,\n            margin: 0,\n            alignment: fadeInOutTextEffect_1.TextAlignment.CENTER,\n            texts: [\"The darkness at the end of time\",\n                \"a fruit of the loom production\",\n                \"inspired by a series of books\",\n                \"written by professor Ulf Danielsson\"],\n            font: \"Montserrat\",\n            size: 40,\n            fadeInDuration: sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 4) / 1000,\n            fadeOutDuration: sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 4) / 1000,\n            textDuration: sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 8) / 1000,\n            loop: false\n        }, (ts, ctx, props) => (0, fadeInOutTextEffect_1.textFadeInOut)(ts, ctx, props, this.sequence), sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 8));\n        mapEntities.push(textEffectEntity);\n        return mapEntities;\n    }\n    /**\n     * Create entities for Earth Scene\n     *\n     * @return {*}  {Map<string,IEntity>}\n     * @memberof Fol06\n     */\n    earthScene() {\n        const mapEntities = new Array();\n        const cameraPositions = [\n            [0.0, 1.2, 0.7],\n            [0.5, 1.0, 0.9],\n            [1.0, 0.8, 1.1],\n            [0.7, 1.3, 0.6],\n            [0.2, 1.1, 1.0],\n            [1.2, 0.9, 0.8],\n            [0.9, 1.4, 0.5],\n            [0.4, 1.0, 1.2]\n        ];\n        let cameraPos = cameraPositions[0];\n        const shader = new shaderEntity_1.ShaderEntity(\"earthShader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: earthShader_1.earthShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"cameraPos\": (uniformLoction, gl) => {\n                            if (uniformLoction) { // uniform cameraPos vec3 \n                                gl.uniform3fv(uniformLoction, cameraPos);\n                            }\n                            ;\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        shader.onBar((ts, count) => {\n            const positionIndex = (count) % cameraPositions.length;\n            cameraPos = cameraPositions[positionIndex];\n        });\n        const textEffectEntity = new entity_1.Entity(\"earth-text\", {\n            y: 40,\n            texts: [\"We are a cosmic accident,but a fortunate one.\", \"Swallowed by darkness, crushed by gravity.\"],\n            font: \"Montserrat\",\n            alignment: fadeInOutTextEffect_1.TextAlignment.RIGHT,\n            margin: 20,\n            size: 20,\n            fadeInDuration: 2,\n            fadeOutDuration: 2,\n            textDuration: (sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 4) / 1000) + 5,\n            loop: false\n        }, (ts, ctx, props) => (0, fadeInOutTextEffect_1.textFadeInOut)(ts, ctx, props, this.sequence), sequenceHelper_1.SequenceHelper.getDurationForBeats(this.bmp, 4));\n        mapEntities.push(shader, textEffectEntity);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the blackhole scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    blackhole() {\n        const mapEntities = new Array();\n        let zoom = 0.1;\n        const shader = new shaderEntity_1.ShaderEntity(\"earthShader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: blackholeShader_1.blackholeShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"zoom\": (uniformLoction, gl) => {\n                            if (uniformLoction) { // uniform cameraPos vec3 \n                                gl.uniform1f(uniformLoction, zoom);\n                            }\n                            ;\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        shader.onBar((ts, count) => {\n            zoom *= 0.2;\n        });\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the event-horizon scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    eventHorizon() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"eventHorizon\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: eventHorizon_1.eventHorizonShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the lonly planet and sun scene scene\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    lonlyPlanet() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"lonley-planet-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: lonlyPlanetShader_1.lonlyPlanetShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     * Cretate entities for the galaxy scene scene\n     *\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    galaxy() {\n        const mapEntities = new Array();\n        const cameraPositions = [\n            [0.0, 1.2],\n            [0.5, 1.0],\n            [1.0, 0.8],\n        ];\n        let cameraPos = cameraPositions[0];\n        let currentPosIndex = 0;\n        const shader = new shaderEntity_1.ShaderEntity(\"galaxy\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: galaxyShader_1.galaxyShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"cameraPos\": (uniformLoction, gl, program, time) => {\n                            gl.uniform2fv(uniformLoction, cameraPos);\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        this.conductor.addEvent({\n            action: (entity) => {\n                currentPosIndex++;\n                const positionIndex = (currentPosIndex) % cameraPositions.length;\n                cameraPos = cameraPositions[positionIndex];\n            },\n            targetEntity: \"galaxy\",\n            criteria: () => {\n                const avgFrequency = this.sequence.fftData.reduce((sum, val) => sum + val, 0) /\n                    this.sequence.fftData.length;\n                return avgFrequency > 100; // Trigger if average frequency is greater than 100\n            }\n        });\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    /**\n     *\n     *\n     * @return {*}  {Array<IEntity>}\n     * @memberof Fol06\n     */\n    expandingGalaxy() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"lonley-planet-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: cosmicCycleShader_1.cosmicCycleShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {\n                        \"NUM_LAYERS\": (uniformLoction, gl, program, time) => {\n                            gl.uniform1f(uniformLoction, 1 * this.sequence.currentBeat);\n                        }\n                    }\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    warpSpeed() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"warp-speed-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: warpSpeedShader_1.warpSpeedShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    singularity() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"singularity-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: singularityShader_1.singularityShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n    exoPlanets() {\n        const mapEntities = new Array();\n        const shader = new shaderEntity_1.ShaderEntity(\"singularity-shader\", {\n            mainFragmentShader: mainFragment_1.mainFragment,\n            mainVertexShader: mainVertex_1.mainVertex,\n            renderBuffers: [\n                {\n                    name: \"a_buffer\",\n                    fragment: exoPlanetShader_1.exoplanetShader,\n                    vertex: mainVertex_1.mainVertex,\n                    textures: [],\n                    customUniforms: {}\n                }\n            ]\n        }, () => {\n        }, this.width, this.height);\n        mapEntities.push(shader);\n        return mapEntities;\n    }\n}\nvar SCENE;\n(function (SCENE) {\n    SCENE[SCENE[\"INTRO\"] = 0] = \"INTRO\";\n    SCENE[SCENE[\"EARTH\"] = 1] = \"EARTH\";\n    SCENE[SCENE[\"LONLYPLANET\"] = 2] = \"LONLYPLANET\";\n    SCENE[SCENE[\"GALAXY\"] = 3] = \"GALAXY\";\n    SCENE[SCENE[\"GALAXYEXPAND\"] = 4] = \"GALAXYEXPAND\";\n    SCENE[SCENE[\"EXOPLANETS\"] = 5] = \"EXOPLANETS\";\n    SCENE[SCENE[\"WARPSPEED\"] = 6] = \"WARPSPEED\";\n    SCENE[SCENE[\"SINGULARITY\"] = 7] = \"SINGULARITY\";\n    SCENE[SCENE[\"BLACKHOLE\"] = 8] = \"BLACKHOLE\";\n    SCENE[SCENE[\"EVENTHORIZON\"] = 9] = \"EVENTHORIZON\";\n})(SCENE || (SCENE = {}));\ndemo.addAssets().then((demo) => {\n    const bpm = 123;\n    const fol06 = new Fol06(demo.sequence, 800, 450, bpm);\n    const sceneBuilder = new sceneBuilder_1.SceneBuilder(166000); // 2.46 mins\n    sceneBuilder\n        .addScene(\"intro\", sequenceHelper_1.SequenceHelper.getDurationForBeats(bpm, 32))\n        .addScene(\"earth\", sequenceHelper_1.SequenceHelper.getDurationForBars(bpm, 4, 16))\n        .addScene(\"lonly-planet-and-the-sun\", 15000)\n        .addScene(\"galaxy\", 15000)\n        .addScene(\"galaxy-expand\", 20000)\n        .addScene(\"warp-speed\", 5000)\n        .addScene(\"explanets\", 30000)\n        .addScene(\"singularity\", 25000)\n        .addScene(\"blackhole\", 5000).\n        durationUntilEndInMs(\"eventhorizon\");\n    EngineLogger_1.EngineLogger.log(`Total Scene duration ${sceneBuilder.totalScenesDuration}`);\n    const scenes = sceneBuilder.getScenes();\n    scenes[SCENE.INTRO].addEntities(...fol06.introScene());\n    scenes[SCENE.EARTH].addEntities(...fol06.earthScene());\n    scenes[SCENE.LONLYPLANET].addEntities(...fol06.lonlyPlanet());\n    scenes[SCENE.GALAXY].addEntities(...fol06.galaxy());\n    scenes[SCENE.GALAXYEXPAND].addEntities(...fol06.expandingGalaxy());\n    scenes[SCENE.EXOPLANETS].addEntities(...fol06.exoPlanets());\n    scenes[SCENE.WARPSPEED].addEntities(...fol06.warpSpeed());\n    scenes[SCENE.SINGULARITY].addEntities(...fol06.singularity());\n    scenes[SCENE.BLACKHOLE].addEntities(...fol06.blackhole());\n    scenes[SCENE.EVENTHORIZON].addEntities(...fol06.eventHorizon());\n    // create and add transitions to scenes\n    const transitionIn = (ctx, scene, progress) => {\n        ctx.globalAlpha = progress;\n    };\n    const transitionOut = (ctx, scene, progress) => {\n        ctx.globalAlpha = 1 - progress;\n    };\n    scenes[SCENE.EARTH].transitionIn(demo.sequence, 0, 2000, transitionIn);\n    scenes[SCENE.EARTH].transitionOut(demo.sequence, scenes[SCENE.EARTH].durationInMs - 2000, 2000, transitionOut);\n    demo.sequence.addSceneArray(scenes);\n    const jumpToScene = new URLSearchParams(location.search).get(\"scene\") || \"0\";\n    const debugHelper = new debugHelper_1.DebugHelper(demo.sequence, parseInt(jumpToScene));\n    //debugHelper.addControls();\n    demo.sequence.onFrame(() => debugHelper.update());\n}).catch(err => {\n    EngineLogger_1.EngineLogger.log(err);\n});\ndemo.sequence.onReady = () => {\n    const toggleFullscreen = (elem) => {\n        if (!document.fullscreenElement) {\n            elem.requestFullscreen().catch((err) => {\n                alert(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);\n            });\n        }\n        else {\n            document.exitFullscreen();\n        }\n    };\n    const btn = document.querySelector(\"BUTTON\");\n    btn.textContent = \"CLICK TO START!\";\n    btn.classList.remove(\"hide\");\n    btn.addEventListener(\"click\", () => {\n        var _a;\n        (_a = document.querySelector(\"#launch\")) === null || _a === void 0 ? void 0 : _a.remove();\n        demo.sequence.play();\n        // toggleFullscreen(document.querySelector(\"canvas\")!);\n    });\n};\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/Fol06.js?");

/***/ }),

/***/ "./build/wwwroot/src/SetupDemo.js":
/*!****************************************!*\
  !*** ./build/wwwroot/src/SetupDemo.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetupDemo = void 0;\nconst assetsHelper_1 = __webpack_require__(/*! ../../src/Engine/Helpers/assetsHelper */ \"./build/src/Engine/Helpers/assetsHelper.js\");\nconst sequence_1 = __webpack_require__(/*! ../../src/Engine/sequence */ \"./build/src/Engine/sequence.js\");\nclass SetupDemo {\n    constructor(audioLoader) {\n        this.scenes = [];\n        this.settings = {\n            width: 800,\n            height: 450,\n            audioProperties: {\n                bpm: 122,\n                ticks: 4,\n                beat: 0,\n                tick: 0,\n                bar: 0,\n                avgFreq: 0\n            },\n            font: \"Big Shoulders Stencil Text\"\n        };\n        this.sequence = new sequence_1.Sequence(document.querySelector(\"canvas\"), 122, 4, 4, [], audioLoader);\n    }\n    async addAssets(...urls) {\n        await assetsHelper_1.AssetsHelper.loadImages(urls);\n        return this;\n    }\n    addScene(scene) {\n        this.sequence.addScene(scene);\n    }\n    addEntity(key, entity) {\n        const scene = this.scenes.find(pre => {\n            return pre.name === key;\n        });\n        if (scene) {\n            scene.addEntity(entity);\n        }\n        else\n            throw Error(\"No such scene\");\n    }\n}\nexports.SetupDemo = SetupDemo;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/SetupDemo.js?");

/***/ }),

/***/ "./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js":
/*!**************************************************************!*\
  !*** ./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textFadeInOut = exports.TextAlignment = void 0;\nvar TextAlignment;\n(function (TextAlignment) {\n    TextAlignment[TextAlignment[\"LEFT\"] = 0] = \"LEFT\";\n    TextAlignment[TextAlignment[\"CENTER\"] = 1] = \"CENTER\";\n    TextAlignment[TextAlignment[\"RIGHT\"] = 2] = \"RIGHT\";\n})(TextAlignment || (exports.TextAlignment = TextAlignment = {}));\nconst textFadeInOut = (ts, ctx, propertybag, sequence) => {\n    const { x, y, texts, font, size, fadeInDuration, fadeOutDuration, textDuration, loop } = propertybag;\n    ctx.font = `${size}px ${font}`;\n    ctx.fillStyle = \"white\";\n    ctx.textAlign = \"center\";\n    const sceneStartTime = sequence.currentScene.startTimeinMs / 1000;\n    let elapsed = ts / 1000 - sceneStartTime; // Time elapsed since the start of the scene\n    // If looping, take the modulus to keep elapsed within the total duration\n    if (loop) {\n        const totalDuration = texts.length * textDuration;\n        elapsed = elapsed % totalDuration;\n    }\n    // Calculate the index of the current text element\n    let textIndex = Math.floor(elapsed / textDuration);\n    // If looping, take the modulus to keep the index within bounds\n    if (loop) {\n        textIndex = textIndex % texts.length;\n    }\n    else if (textIndex >= texts.length) { // Stop if not looping and reached the end\n        return;\n    }\n    const text = texts[textIndex];\n    const textElapsed = elapsed % textDuration;\n    let alpha = 1;\n    if (textElapsed < fadeInDuration) {\n        alpha = textElapsed / fadeInDuration; // Fade in\n    }\n    else if (textElapsed > textDuration - fadeOutDuration) {\n        alpha = (textDuration - textElapsed) / fadeOutDuration; // Fade out\n    }\n    // Calculate x-coordinate based on alignment and margin\n    let drawX;\n    switch (propertybag.alignment) {\n        case TextAlignment.LEFT:\n            drawX = propertybag.margin || 0;\n            ctx.textAlign = \"left\";\n            break;\n        case TextAlignment.RIGHT:\n            drawX = ctx.canvas.width - (propertybag.margin || 0);\n            ctx.textAlign = \"right\";\n            break;\n        case TextAlignment.CENTER:\n        default:\n            drawX = ctx.canvas.width / 2;\n            ctx.textAlign = \"center\";\n            break;\n    }\n    ctx.globalAlpha = alpha;\n    ctx.fillText(text, propertybag.x || drawX, y); // Use provided x or calculated drawX\n    ctx.globalAlpha = 1;\n};\nexports.textFadeInOut = textFadeInOut;\n\n\n//# sourceURL=webpack://demolished-rail/./build/wwwroot/src/effects/FoL/fadeInOutTextEffect.js?");

/***/ }),

/***/ "./node_modules/sonantx/dist/sonantx.bundle.js":
/*!*****************************************************!*\
  !*** ./node_modules/sonantx/dist/sonantx.bundle.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_539__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_539__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_539__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_539__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_539__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_539__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_539__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_539__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_539__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_539__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_539__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_539__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_539__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_539__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_539__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_539__(__nested_webpack_require_539__.s = \"./sonantx.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./sonantx.js\":\n/*!********************!*\\\n  !*** ./sonantx.js ***!\n  \\********************/\n/*! exports provided: generateSound, generateSong */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"generateSound\\\", function() { return generateSound; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"generateSong\\\", function() { return generateSong; });\\n// Oscillators\\nfunction osc_sin(value) {\\n  return Math.sin(value * Math.PI * 2);\\n}\\n\\nfunction osc_square(value) {\\n  if (osc_sin(value) < 0) {\\n    return -1;\\n  }\\n\\n  return 1;\\n}\\n\\nfunction osc_saw(value) {\\n  return value % 1 - 0.5;\\n}\\n\\nfunction osc_tri(value) {\\n  const v2 = value % 1 * 4;\\n\\n  if (v2 < 2) {\\n    return v2 - 1;\\n  }\\n\\n  return 3 - v2;\\n} // Array of oscillator functions\\n\\n\\nconst oscillators = [osc_sin, osc_square, osc_saw, osc_tri];\\n\\nfunction getnotefreq44100(n) {\\n  const val = 0.00390625 * Math.pow(1.059463094, n - 128);\\n  return val;\\n}\\n\\nfunction getnotefreq(audioCtx, n) {\\n  const x = getnotefreq44100(n);\\n  const val = x / audioCtx.sampleRate * 44100;\\n  return val;\\n}\\n\\nfunction effectiveRowLen(audioCtx, bpm) {\\n  return Math.round(60 * audioCtx.sampleRate / 4 / bpm);\\n}\\n\\nclass SoundWriter {\\n  constructor(audioCtx, instr, n, bpm) {\\n    this.audioCtx = audioCtx;\\n    this.instr = instr;\\n    this.n = n;\\n    this.bpm = bpm;\\n    this.c1 = 0;\\n    this.c2 = 0;\\n    this.low = 0;\\n    this.band = 0;\\n    this.j = 0;\\n  }\\n\\n  write(lchan, rchan, from) {\\n    const instr = this.instr;\\n    const n = this.n;\\n    let c = from;\\n    const osc_lfo = oscillators[instr.lfo_waveform];\\n    const osc1 = oscillators[instr.osc1_waveform];\\n    const osc2 = oscillators[instr.osc2_waveform];\\n    const panFreq = Math.pow(2, instr.fx_pan_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\\n    const lfoFreq = Math.pow(2, instr.lfo_freq - 8) / effectiveRowLen(this.audioCtx, this.bpm);\\n    const attackTime = instr.env_attack / 44100;\\n    const releaseTime = instr.env_release / 44100;\\n    const sustainTime = instr.env_sustain / 44100;\\n    const env_attack = attackTime * this.audioCtx.sampleRate;\\n    const env_release = releaseTime * this.audioCtx.sampleRate;\\n    const env_sustain = sustainTime * this.audioCtx.sampleRate; // Precalculate frequencues\\n\\n    const o1t = getnotefreq(this.audioCtx, n + (instr.osc1_oct - 8) * 12 + instr.osc1_det) * (1 + 0.0008 * instr.osc1_detune);\\n    const o2t = getnotefreq(this.audioCtx, n + (instr.osc2_oct - 8) * 12 + instr.osc2_det) * (1 + 0.0008 * instr.osc2_detune); // State variable init\\n\\n    const q = instr.fx_resonance / 255;\\n\\n    while (this.j < env_attack + env_sustain + env_release && c < lchan.length) {\\n      // LFO\\n      const lfor = osc_lfo(this.j * lfoFreq) * instr.lfo_amt / 512 + 0.5; // Envelope\\n\\n      let e = 1;\\n\\n      if (this.j < env_attack) {\\n        e = this.j / env_attack;\\n      } else if (this.j >= env_attack + env_sustain) {\\n        e -= (this.j - env_attack - env_sustain) / env_release;\\n      } // Oscillator 1\\n\\n\\n      let t = o1t;\\n\\n      if (instr.lfo_osc1_freq) {\\n        t += lfor;\\n      }\\n\\n      if (instr.osc1_xenv) {\\n        t *= e * e;\\n      }\\n\\n      this.c1 += t;\\n      let rsample = osc1(this.c1) * instr.osc1_vol; // Oscillator 2\\n\\n      t = o2t;\\n\\n      if (instr.osc2_xenv) {\\n        t *= e * e;\\n      }\\n\\n      this.c2 += t;\\n      rsample += osc2(this.c2) * instr.osc2_vol; // Noise oscillator\\n\\n      if (instr.noise_fader) {\\n        rsample += (2 * Math.random() - 1) * instr.noise_fader * e;\\n      }\\n\\n      rsample *= e / 255; // State variable filter\\n\\n      let f = instr.fx_freq;\\n\\n      if (instr.lfo_fx_freq) {\\n        f *= lfor;\\n      }\\n\\n      f = 1.5 * Math.sin(f * Math.PI / this.audioCtx.sampleRate);\\n      this.low += f * this.band;\\n      const high = q * (rsample - this.band) - this.low;\\n      this.band += f * high;\\n\\n      switch (instr.fx_filter) {\\n        case 1:\\n          // Hipass\\n          rsample = high;\\n          break;\\n\\n        case 2:\\n          // Lopass\\n          rsample = this.low;\\n          break;\\n\\n        case 3:\\n          // Bandpass\\n          rsample = this.band;\\n          break;\\n\\n        case 4:\\n          // Notch\\n          rsample = this.low + high;\\n          break;\\n\\n        default:\\n      } // Panning & master volume\\n\\n\\n      t = osc_sin(this.j * panFreq) * instr.fx_pan_amt / 512 + 0.5;\\n      rsample *= 39 * instr.env_master;\\n      let x = 32768 + rsample * (1 - t);\\n      let x1 = x & 255;\\n      let x2 = x >> 8 & 255;\\n      let y = 4 * (x1 + (x2 << 8) - 32768);\\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\\n      lchan[c] = lchan[c] + y / 32768;\\n      x = 32768 + rsample * t;\\n      x1 = x & 255;\\n      x2 = x >> 8 & 255;\\n      y = 4 * (x1 + (x2 << 8) - 32768);\\n      y = y < -32768 ? -32768 : y > 32767 ? 32767 : y;\\n      rchan[c] = rchan[c] + y / 32768;\\n      this.j++;\\n      c++;\\n    } // returns true if the sound finished\\n\\n\\n    if (c < lchan.length) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n}\\n\\nclass TrackGenerator {\\n  constructor(audioCtx, instr, bpm, endPattern) {\\n    bpm = bpm || 118;\\n    endPattern = endPattern || instr.p.length - 1;\\n    this.audioCtx = audioCtx;\\n    this.instr = instr;\\n    this.bpm = bpm;\\n    this.endPattern = endPattern;\\n    const source = this.audioCtx.createOscillator();\\n    const nullGain = this.audioCtx.createGain();\\n    nullGain.gain.value = 0;\\n    source.connect(nullGain);\\n    const scriptNode = this.audioCtx.createScriptProcessor(512, 2, 2);\\n    nullGain.connect(scriptNode);\\n    let currentSample = 0;\\n    let nextNote = 0;\\n    let sounds = [];\\n\\n    scriptNode.onaudioprocess = audioProcessingEvent => {\\n      const inputData = audioProcessingEvent.inputBuffer;\\n      const outputData = audioProcessingEvent.outputBuffer;\\n      const lchan = outputData.getChannelData(0);\\n      const rchan = outputData.getChannelData(1);\\n      lchan.set(inputData.getChannelData(0));\\n      rchan.set(inputData.getChannelData(1));\\n      sounds.slice().forEach(el => {\\n        const finished = el.write(lchan, rchan, 0);\\n\\n        if (finished) {\\n          sounds = sounds.filter(el2 => {\\n            return el2 !== el;\\n          });\\n        }\\n      });\\n      let nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\\n\\n      while (nextNoteSample >= currentSample && nextNoteSample < currentSample + inputData.length) {\\n        const pattern = instr.p[Math.floor(nextNote / 32) % (this.endPattern + 1)] || 0;\\n        const note = pattern === 0 ? 0 : (instr.c[pattern - 1] || {\\n          n: []\\n        }).n[nextNote % 32] || 0;\\n\\n        if (note !== 0) {\\n          const sw = new SoundWriter(this.audioCtx, instr, note, this.bpm);\\n          sw.write(lchan, rchan, nextNoteSample - currentSample);\\n          sounds.push(sw);\\n        }\\n\\n        nextNote += 1;\\n        nextNoteSample = nextNote * effectiveRowLen(this.audioCtx, this.bpm);\\n      }\\n\\n      currentSample += inputData.length;\\n    };\\n\\n    const delayTime = instr.fx_delay_time * (1 / (this.bpm / 60) / 8);\\n    const delayAmount = instr.fx_delay_amt / 255;\\n    const delayGain = this.audioCtx.createGain();\\n    delayGain.gain.value = delayAmount;\\n    scriptNode.connect(delayGain);\\n    const delay = this.audioCtx.createDelay();\\n    delay.delayTime.value = delayTime;\\n    delayGain.connect(delay);\\n    delay.connect(delayGain);\\n    const mixer = this.audioCtx.createGain();\\n    mixer.gain.value = 1;\\n    scriptNode.connect(mixer);\\n    delay.connect(mixer);\\n    this.chain = [source, nullGain, scriptNode, delayGain, delay, mixer];\\n  }\\n\\n  start(when) {\\n    this.chain[0].start(when);\\n  }\\n\\n  stop(when) {\\n    this.chain[0].stop(when);\\n    this.chain[this.chain.length - 1].disconnect();\\n  }\\n\\n  connect(target) {\\n    this.chain[this.chain.length - 1].connect(target);\\n  }\\n\\n}\\n\\nclass MusicGenerator {\\n  constructor(audioCtx, song) {\\n    this.audioCtx = audioCtx;\\n    this.song = song;\\n    const mixer = this.audioCtx.createGain();\\n    mixer.gain.value = 1;\\n    this.tracks = [];\\n    this.song.songData.forEach(el => {\\n      const track = new TrackGenerator(this.audioCtx, el, this.bpm, this.song.endPattern);\\n      track.connect(mixer);\\n      this.tracks.push(track);\\n    });\\n    this.chain = [this.tracks, mixer];\\n  }\\n\\n  get bpm() {\\n    // rowLen is a number of samples when using 44100hz\\n    return Math.round(60 * 44100 / 4 / this.song.rowLen);\\n  }\\n\\n  start(when) {\\n    when = when || this.audioCtx.currentTime;\\n    this.tracks.forEach(t => t.start(when));\\n  }\\n\\n  stop(when) {\\n    when = when || this.audioCtx.currentTime;\\n    this.tracks.forEach(t => t.stop(when));\\n    this.chain[this.chain.length - 1].disconnect();\\n  }\\n\\n  connect(target) {\\n    this.chain[this.chain.length - 1].connect(target);\\n  }\\n\\n}\\n/**\\n * Generates a single note from an instrument.\\n *\\n * @param {*} instr The instrument descriptor\\n * @param {*} n The note as a midi note\\n * @param {*} sampleRate The sample rate\\n * @param {*} bpm The bpm of the song\\n * @returns {AudioBuffer} The generated audio buffer\\n */\\n\\n\\nasync function generateSound(instr, n, sampleRate, bpm = 120) {\\n  const attackTime = instr.env_attack / 44100;\\n  const releaseTime = instr.env_release / 44100;\\n  const sustainTime = instr.env_sustain / 44100;\\n  const soundLenSeconds = attackTime + releaseTime + sustainTime + 8 * (1 / (bpm / 60));\\n  const nInstr = Object.assign({}, instr);\\n  nInstr.p = [1, 0, 0, 0];\\n  nInstr.c = [{\\n    n: new Array(32).map(() => 0)\\n  }];\\n  nInstr.c[0].n[0] = n + 75;\\n  const audioCtx = new OfflineAudioContext(2, soundLenSeconds * sampleRate, sampleRate);\\n  const soundGen = new TrackGenerator(audioCtx, nInstr, bpm, 0);\\n  soundGen.connect(audioCtx.destination);\\n  soundGen.start();\\n  const buf = await audioCtx.startRendering();\\n  return buf;\\n}\\n/**\\n * Generates a complete song from a song description.\\n *\\n * @param {*} song The song description\\n * @param {*} options `sampleRate`: the sample rate\\n * @returns {AudioBuffer} The generated audio buffer\\n */\\n\\nasync function generateSong(song, sampleRate) {\\n  const songLenSeconds = song.songLen;\\n  const audioCtx = new OfflineAudioContext(2, songLenSeconds * sampleRate, sampleRate);\\n  const soundGen = new MusicGenerator(audioCtx, song);\\n  soundGen.connect(audioCtx.destination);\\n  soundGen.start();\\n  const buf = await audioCtx.startRendering();\\n  return buf;\\n}\\n\\n//# sourceURL=webpack://sonantx/./sonantx.js?\");\n\n/***/ })\n\n/******/ });\n});\n\n//# sourceURL=webpack://demolished-rail/./node_modules/sonantx/dist/sonantx.bundle.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/wwwroot/src/Fol06.js");
/******/ 	
/******/ })()
;